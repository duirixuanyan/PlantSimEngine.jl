<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>内部 API · PlantSimEngine.jl</title><meta name="title" content="内部 API · PlantSimEngine.jl"/><meta property="og:title" content="内部 API · PlantSimEngine.jl"/><meta property="twitter:title" content="内部 API · PlantSimEngine.jl"/><meta name="description" content="Documentation for PlantSimEngine.jl."/><meta property="og:description" content="Documentation for PlantSimEngine.jl."/><meta property="twitter:description" content="Documentation for PlantSimEngine.jl."/><meta property="og:url" content="https://VirtualPlantLab.github.io/PlantSimEngine.jl/API\\API_private.html"/><meta property="twitter:url" content="https://VirtualPlantLab.github.io/PlantSimEngine.jl/API\\API_private.html"/><link rel="canonical" href="https://VirtualPlantLab.github.io/PlantSimEngine.jl/API\\API_private.html"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">PlantSimEngine.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">首页</a></li><li><span class="tocitem">简介</span><ul><li><a class="tocitem" href="../introduction/why_plantsimengine.html">为什么选择 PlantSimEngine？</a></li><li><a class="tocitem" href="../introduction/why_julia.html">为什么选择 Julia？</a></li></ul></li><li><span class="tocitem">前置条件</span><ul><li><a class="tocitem" href="../prerequisites/installing_plantsimengine.html">PlantSimEngine 的安装与运行</a></li><li><a class="tocitem" href="../prerequisites/key_concepts.html">关键概念</a></li><li><a class="tocitem" href="../prerequisites/julia_basics.html">Julia 语言基础</a></li></ul></li><li><span class="tocitem">分步教程 - 单尺度模拟</span><ul><li><a class="tocitem" href="../step_by_step/detailed_first_example.html">详细的第一个模拟</a></li><li><a class="tocitem" href="../step_by_step/simple_model_coupling.html">模型耦合</a></li><li><a class="tocitem" href="../step_by_step/model_switching.html">模型切换</a></li><li><a class="tocitem" href="../step_by_step/quick_and_dirty_examples.html">快速示例</a></li><li><a class="tocitem" href="../step_by_step/implement_a_process.html">实现一个过程</a></li><li><a class="tocitem" href="../step_by_step/implement_a_model.html">实现一个模型</a></li><li><a class="tocitem" href="../step_by_step/parallelization.html">并行化</a></li><li><a class="tocitem" href="../step_by_step/advanced_coupling.html">高级耦合与硬依赖</a></li><li><a class="tocitem" href="../step_by_step/implement_a_model_additional.html">实现一个模型：补充说明</a></li></ul></li><li><a class="tocitem" href="../model_execution.html">模型执行</a></li><li><span class="tocitem">数据处理</span><ul><li><a class="tocitem" href="../working_with_data/reducing_dof.html">降低自由度</a></li><li><a class="tocitem" href="../working_with_data/fitting.html">拟合</a></li><li><a class="tocitem" href="../working_with_data/inputs.html">输入类型</a></li><li><a class="tocitem" href="../working_with_data/visualising_outputs.html">可视化输出与数据</a></li><li><a class="tocitem" href="../working_with_data/floating_point_accumulation_error.html">浮点运算注意事项</a></li></ul></li><li><span class="tocitem">多尺度建模</span><ul><li><a class="tocitem" href="../multiscale/multiscale_considerations.html">多尺度建模考量</a></li><li><a class="tocitem" href="../multiscale/single_to_multiscale.html">单尺度模型转换为多尺度</a></li><li><a class="tocitem" href="../multiscale/multiscale.html">更多变量映射示例</a></li><li><a class="tocitem" href="../multiscale/multiscale_cyclic.html">循环依赖的处理</a></li><li><a class="tocitem" href="../multiscale/multiscale_coupling.html">多尺度耦合相关说明</a></li><li><input class="collapse-toggle" id="menuitem-7-6" type="checkbox"/><label class="tocitem" for="menuitem-7-6"><span class="docs-label">构建简单植株</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../multiscale/multiscale_example_1.html">简单植株模拟</a></li><li><a class="tocitem" href="../multiscale/multiscale_example_2.html">拓展植株模拟</a></li><li><a class="tocitem" href="../multiscale/multiscale_example_3.html">修复植株模拟中的错误</a></li></ul></li><li><a class="tocitem" href="../multiscale/multiscale_example_4.html">用 PlantGeom 可视化玩具植株</a></li></ul></li><li><span class="tocitem">故障排查与测试</span><ul><li><a class="tocitem" href="../troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting.html">故障排查</a></li><li><a class="tocitem" href="../troubleshooting_and_testing/downstream_tests.html">自动化测试</a></li><li><a class="tocitem" href="../troubleshooting_and_testing/tips_and_workarounds.html">技巧与常见问题</a></li><li><a class="tocitem" href="../troubleshooting_and_testing/implicit_contracts.html">隐性约定</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="API_public.html">公共 API</a></li><li><a class="tocitem" href="API_examples.html">示例模型</a></li><li class="is-active"><a class="tocitem" href="API_private.html">内部 API</a><ul class="internal"><li><a class="tocitem" href="#未导出成员"><span>未导出成员</span></a></li><li><a class="tocitem" href="#索引"><span>索引</span></a></li><li><a class="tocitem" href="#API-文档"><span>API 文档</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../documentation_improvement.html">改进文档</a></li><li><a class="tocitem" href="../developers.html">开发者指南</a></li><li><a class="tocitem" href="../planned_features.html">规划功能</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href="API_private.html">内部 API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="API_private.html">内部 API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/main/docs - 中文/src/API/API_private.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-内部函数"><a class="docs-heading-anchor" href="#API-内部函数">API - 内部函数</a><a id="API-内部函数-1"></a><a class="docs-heading-anchor-permalink" href="#API-内部函数" title="Permalink"></a></h1><h2 id="未导出成员"><a class="docs-heading-anchor" href="#未导出成员">未导出成员</a><a id="未导出成员-1"></a><a class="docs-heading-anchor-permalink" href="#未导出成员" title="Permalink"></a></h2><p><code>PlantSimEngine</code> 中的私有函数、类型或常量。这些内容均未导出，因此需要通过 <code>PlantSimEngine.</code> 前缀来访问（例如 <code>PlantSimEngine.DataFormat</code>）。大多数属于开发者代码，但其中有些内容对希望深入探索或需更精细控制模拟参数的用户也有用（未来文档版本可能会将这些类别分拆到不同页面以提升清晰度）。</p><h2 id="索引"><a class="docs-heading-anchor" href="#索引">索引</a><a id="索引-1"></a><a class="docs-heading-anchor-permalink" href="#索引" title="Permalink"></a></h2><ul><li><a href="API_private.html#DataFrames.DataFrame-Union{Tuple{ModelList{T, S}}, Tuple{S}, Tuple{T}} where {T, S&lt;:Status}"><code>DataFrames.DataFrame</code></a></li><li><a href="API_private.html#DataFrames.DataFrame-Tuple{T} where T&lt;:(AbstractArray{&lt;:ModelList})"><code>DataFrames.DataFrame</code></a></li><li><a href="API_private.html#PlantSimEngine.AbstractBasic_Current_TimestepModel"><code>PlantSimEngine.AbstractBasic_Current_TimestepModel</code></a></li><li><a href="API_private.html#PlantSimEngine.AbstractBasic_Next_TimestepModel"><code>PlantSimEngine.AbstractBasic_Next_TimestepModel</code></a></li><li><a href="API_private.html#PlantSimEngine.AbstractNodeMapping"><code>PlantSimEngine.AbstractNodeMapping</code></a></li><li><a href="API_private.html#PlantSimEngine.DataFormat-Tuple{Type{&lt;:AbstractDataFrame}}"><code>PlantSimEngine.DataFormat</code></a></li><li><a href="API_private.html#PlantSimEngine.DependencyGraph"><code>PlantSimEngine.DependencyGraph</code></a></li><li><a href="API_private.html#PlantSimEngine.DependencyTrait"><code>PlantSimEngine.DependencyTrait</code></a></li><li><a href="API_private.html#PlantSimEngine.GraphSimulation"><code>PlantSimEngine.GraphSimulation</code></a></li><li><a href="API_private.html#PlantSimEngine.MappedVar"><code>PlantSimEngine.MappedVar</code></a></li><li><a href="API_private.html#PlantSimEngine.MultiNodeMapping"><code>PlantSimEngine.MultiNodeMapping</code></a></li><li><a href="API_private.html#PlantSimEngine.ObjectDependencyTrait"><code>PlantSimEngine.ObjectDependencyTrait</code></a></li><li><a href="API_private.html#PlantSimEngine.RefVariable"><code>PlantSimEngine.RefVariable</code></a></li><li><a href="API_private.html#PlantSimEngine.RefVector"><code>PlantSimEngine.RefVector</code></a></li><li><a href="API_private.html#PlantSimEngine.SelfNodeMapping"><code>PlantSimEngine.SelfNodeMapping</code></a></li><li><a href="API_private.html#PlantSimEngine.SingleNodeMapping"><code>PlantSimEngine.SingleNodeMapping</code></a></li><li><a href="API_private.html#PlantSimEngine.TimeStepDependencyTrait-Tuple{Type}"><code>PlantSimEngine.TimeStepDependencyTrait</code></a></li><li><a href="API_private.html#PlantSimEngine.UninitializedVar"><code>PlantSimEngine.UninitializedVar</code></a></li><li><a href="API_private.html#Base.copy-Tuple{T} where T&lt;:ModelList"><code>Base.copy</code></a></li><li><a href="API_private.html#Base.copy-Tuple{T} where T&lt;:(AbstractArray{&lt;:ModelList})"><code>Base.copy</code></a></li><li><a href="API_private.html#Base.copy-Tuple{T} where T&lt;:(AbstractDict{N, &lt;:ModelList} where N)"><code>Base.copy</code></a></li><li><a href="API_private.html#Base.getindex-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:ModelList"><code>Base.getindex</code></a></li><li><a href="API_private.html#PlantSimEngine.add_mapped_variables_with_outputs_as_inputs!-Tuple{Any}"><code>PlantSimEngine.add_mapped_variables_with_outputs_as_inputs!</code></a></li><li><a href="API_private.html#PlantSimEngine.add_model_vars-Tuple{Any, Any, Any}"><code>PlantSimEngine.add_model_vars</code></a></li><li><a href="API_private.html#PlantSimEngine.check_dimensions-Tuple{Any, Any}"><code>PlantSimEngine.check_dimensions</code></a></li><li><a href="API_private.html#PlantSimEngine.convert_reference_values!-Tuple{Dict{String, Dict{Symbol, Any}}}"><code>PlantSimEngine.convert_reference_values!</code></a></li><li><a href="API_private.html#PlantSimEngine.convert_vars"><code>PlantSimEngine.convert_vars</code></a></li><li><a href="API_private.html#PlantSimEngine.convert_vars!"><code>PlantSimEngine.convert_vars!</code></a></li><li><a href="API_private.html#PlantSimEngine.convert_vars!-Tuple{Dict{String, Dict{Symbol, Any}}, Any}"><code>PlantSimEngine.convert_vars!</code></a></li><li><a href="API_private.html#PlantSimEngine.default_variables_from_mapping"><code>PlantSimEngine.default_variables_from_mapping</code></a></li><li><a href="API_private.html#PlantSimEngine.diff_vars-Tuple{Any, Any}"><code>PlantSimEngine.diff_vars</code></a></li><li><a href="API_private.html#PlantSimEngine.draw_guide-NTuple{5, Any}"><code>PlantSimEngine.draw_guide</code></a></li><li><a href="API_private.html#PlantSimEngine.draw_panel"><code>PlantSimEngine.draw_panel</code></a></li><li><a href="API_private.html#PlantSimEngine.drop_process-Tuple{Any, Symbol}"><code>PlantSimEngine.drop_process</code></a></li><li><a href="API_private.html#PlantSimEngine.flatten_vars-Tuple{Any}"><code>PlantSimEngine.flatten_vars</code></a></li><li><a href="API_private.html#PlantSimEngine.get_mapped_variables-Tuple{Any}"><code>PlantSimEngine.get_mapped_variables</code></a></li><li><a href="API_private.html#PlantSimEngine.get_model_nodes-Tuple{PlantSimEngine.DependencyGraph, Any}"><code>PlantSimEngine.get_model_nodes</code></a></li><li><a href="API_private.html#PlantSimEngine.get_models-Tuple{Any}"><code>PlantSimEngine.get_models</code></a></li><li><a href="API_private.html#PlantSimEngine.get_multiscale_default_value"><code>PlantSimEngine.get_multiscale_default_value</code></a></li><li><a href="API_private.html#PlantSimEngine.get_nsteps-Tuple{Any}"><code>PlantSimEngine.get_nsteps</code></a></li><li><a href="API_private.html#PlantSimEngine.get_status-Tuple{Any}"><code>PlantSimEngine.get_status</code></a></li><li><a href="API_private.html#PlantSimEngine.hard_dependencies-Tuple{Any}"><code>PlantSimEngine.hard_dependencies</code></a></li><li><a href="API_private.html#PlantSimEngine.homogeneous_ts_kwargs-Tuple{Any}"><code>PlantSimEngine.homogeneous_ts_kwargs</code></a></li><li><a href="API_private.html#PlantSimEngine.homogeneous_ts_kwargs-Union{Tuple{NamedTuple{N, T}}, Tuple{T}, Tuple{N}} where {N, T}"><code>PlantSimEngine.homogeneous_ts_kwargs</code></a></li><li><a href="API_private.html#PlantSimEngine.init_node_status!"><code>PlantSimEngine.init_node_status!</code></a></li><li><a href="API_private.html#PlantSimEngine.init_simulation-Tuple{Any, Any}"><code>PlantSimEngine.init_simulation</code></a></li><li><a href="API_private.html#PlantSimEngine.init_statuses-Tuple{Any, Any, Any}"><code>PlantSimEngine.init_statuses</code></a></li><li><a href="API_private.html#PlantSimEngine.init_variables_manual-Tuple{Any, Any}"><code>PlantSimEngine.init_variables_manual</code></a></li><li><a href="API_private.html#PlantSimEngine.initialise_all_as_hard_dependency_node-Tuple{Any, Any}"><code>PlantSimEngine.initialise_all_as_hard_dependency_node</code></a></li><li><a href="API_private.html#PlantSimEngine.is_graph_cyclic-Tuple{PlantSimEngine.DependencyGraph}"><code>PlantSimEngine.is_graph_cyclic</code></a></li><li><a href="API_private.html#PlantSimEngine.mapped_variables"><code>PlantSimEngine.mapped_variables</code></a></li><li><a href="API_private.html#PlantSimEngine.mapped_variables_no_outputs_from_other_scale"><code>PlantSimEngine.mapped_variables_no_outputs_from_other_scale</code></a></li><li><a href="API_private.html#PlantSimEngine.model_-Tuple{AbstractModel}"><code>PlantSimEngine.model_</code></a></li><li><a href="API_private.html#PlantSimEngine.object_parallelizable-Tuple{T} where T"><code>PlantSimEngine.object_parallelizable</code></a></li><li><a href="API_private.html#PlantSimEngine.parallelizable-Tuple{T} where T"><code>PlantSimEngine.parallelizable</code></a></li><li><a href="API_private.html#PlantSimEngine.ref_var-Tuple{Any}"><code>PlantSimEngine.ref_var</code></a></li><li><a href="API_private.html#PlantSimEngine.reverse_mapping-Union{Tuple{Dict{String, T}}, Tuple{T}} where T"><code>PlantSimEngine.reverse_mapping</code></a></li><li><a href="API_private.html#PlantSimEngine.save_results!-Tuple{PlantSimEngine.GraphSimulation, Any}"><code>PlantSimEngine.save_results!</code></a></li><li><a href="API_private.html#PlantSimEngine.search_inputs_in_multiscale_output-NTuple{6, Any}"><code>PlantSimEngine.search_inputs_in_multiscale_output</code></a></li><li><a href="API_private.html#PlantSimEngine.search_inputs_in_output-Tuple{Any, Any, Any}"><code>PlantSimEngine.search_inputs_in_output</code></a></li><li><a href="API_private.html#PlantSimEngine.set_variables_at_timestep!-Tuple{Status, Status, Any, Any}"><code>PlantSimEngine.set_variables_at_timestep!</code></a></li><li><a href="API_private.html#PlantSimEngine.soft_dependencies"><code>PlantSimEngine.soft_dependencies</code></a></li><li><a href="API_private.html#PlantSimEngine.status_from_template-Tuple{Dict{Symbol}}"><code>PlantSimEngine.status_from_template</code></a></li><li><a href="API_private.html#PlantSimEngine.timestep_parallelizable-Tuple{T} where T"><code>PlantSimEngine.timestep_parallelizable</code></a></li><li><a href="API_private.html#PlantSimEngine.transform_single_node_mapped_variables_as_self_node_output!-Tuple{Any}"><code>PlantSimEngine.transform_single_node_mapped_variables_as_self_node_output!</code></a></li><li><a href="API_private.html#PlantSimEngine.traverse_dependency_graph-Tuple{PlantSimEngine.DependencyGraph, Function}"><code>PlantSimEngine.traverse_dependency_graph</code></a></li><li><a href="API_private.html#PlantSimEngine.traverse_dependency_graph!-Tuple{PlantSimEngine.SoftDependencyNode, Function, Vector}"><code>PlantSimEngine.traverse_dependency_graph!</code></a></li><li><a href="API_private.html#PlantSimEngine.traverse_dependency_graph!-Tuple{PlantSimEngine.HardDependencyNode, Function, Vector}"><code>PlantSimEngine.traverse_dependency_graph!</code></a></li><li><a href="API_private.html#PlantSimEngine.variables_multiscale"><code>PlantSimEngine.variables_multiscale</code></a></li><li><a href="API_private.html#PlantSimEngine.variables_outputs_from_other_scale-Tuple{Any}"><code>PlantSimEngine.variables_outputs_from_other_scale</code></a></li><li><a href="API_private.html#PlantSimEngine.variables_typed-Tuple{T} where T&lt;:AbstractModel"><code>PlantSimEngine.variables_typed</code></a></li><li><a href="API_private.html#PlantSimEngine.vars_not_init_-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Status"><code>PlantSimEngine.vars_not_init_</code></a></li></ul><h2 id="API-文档"><a class="docs-heading-anchor" href="#API-文档">API 文档</a><a id="API-文档-1"></a><a class="docs-heading-anchor-permalink" href="#API-文档" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="DataFrames.DataFrame-Tuple{T} where T&lt;:(AbstractArray{&lt;:ModelList})"><a class="docstring-binding" href="#DataFrames.DataFrame-Tuple{T} where T&lt;:(AbstractArray{&lt;:ModelList})"><code>DataFrames.DataFrame</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">DataFrame(components &lt;: AbstractArray{&lt;:ModelList})
DataFrame(components &lt;: AbstractDict{N,&lt;:ModelList})</code></pre><p>从<a href="../step_by_step/simple_model_coupling.html#ModelList"><code>ModelList</code></a>（或其数组/字典）的状态中提取数据为一个DataFrame。</p><p><strong>示例</strong></p><pre><code class="language- hljs">using PlantSimEngine
using DataFrames

# 创建一个 ModelList
models = ModelList(
    process1=Process1Model(1.0),
    process2=Process2Model(),
    process3=Process3Model(),
    status=(var1=15.0, var2=0.3)
)

# 转换为 DataFrame
df = DataFrame(models)

# 创建一个包含 ModelList 的字典
models = Dict(
    &quot;Leaf&quot; =&gt; ModelList(
        process1=Process1Model(1.0),
        process2=Process2Model(),
        process3=Process3Model()
    ),
    &quot;InterNode&quot; =&gt; ModelList(
        process1=Process1Model(1.0),
        process2=Process2Model(),
        process3=Process3Model()
    )
)

# 转换为 DataFrame
df = DataFrame(models)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/dataframe.jl#L1-L41">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DataFrames.DataFrame-Union{Tuple{ModelList{T, S}}, Tuple{S}, Tuple{T}} where {T, S&lt;:Status}"><a class="docstring-binding" href="#DataFrames.DataFrame-Union{Tuple{ModelList{T, S}}, Tuple{S}, Tuple{T}} where {T, S&lt;:Status}"><code>DataFrames.DataFrame</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">DataFrame(components::ModelList{T,S}) where {T,S&lt;:Status}</code></pre><p>用于只有一个时间步的 <code>ModelList</code> 模型的 <code>DataFrame</code> 实现。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/dataframe.jl#L62-L66">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.AbstractBasic_Current_TimestepModel"><a class="docstring-binding" href="#PlantSimEngine.AbstractBasic_Current_TimestepModel"><code>PlantSimEngine.AbstractBasic_Current_TimestepModel</code></a> — <span class="docstring-category">Type</span></summary><section><div><p><code>basic_current_timestep</code> 过程的抽象模型类型。</p><p>所有模拟 <code>basic_current_timestep</code> 过程的模型都必须为此类型的子类型，例如:  <code>struct MyBasic_Current_TimestepModel &lt;: AbstractBasic_Current_TimestepModel end</code>。</p><p>可通过 <code>subtypes</code> 查看实现该过程的所有模型：</p><p><strong>例子</strong></p><pre><code class="language-julia hljs">subtypes(AbstractBasic_Current_TimestepModel)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/processes/process_generation.jl#L59-L72">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.AbstractBasic_Next_TimestepModel"><a class="docstring-binding" href="#PlantSimEngine.AbstractBasic_Next_TimestepModel"><code>PlantSimEngine.AbstractBasic_Next_TimestepModel</code></a> — <span class="docstring-category">Type</span></summary><section><div><p><code>basic_next_timestep</code> 过程的抽象模型类型。</p><p>所有模拟 <code>basic_next_timestep</code> 过程的模型都必须为此类型的子类型，例如:  <code>struct MyBasic_Next_TimestepModel &lt;: AbstractBasic_Next_TimestepModel end</code>。</p><p>可通过 <code>subtypes</code> 查看实现该过程的所有模型：</p><p><strong>例子</strong></p><pre><code class="language-julia hljs">subtypes(AbstractBasic_Next_TimestepModel)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/processes/process_generation.jl#L59-L72">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.AbstractNodeMapping"><a class="docstring-binding" href="#PlantSimEngine.AbstractNodeMapping"><code>PlantSimEngine.AbstractNodeMapping</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractNodeMapping</code></pre><p>用于节点映射类型的抽象类型，例如单节点映射或多节点映射。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/mtg/mapping/mapping.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.DataFormat-Tuple{Type{&lt;:AbstractDataFrame}}"><a class="docstring-binding" href="#PlantSimEngine.DataFormat-Tuple{Type{&lt;:AbstractDataFrame}}"><code>PlantSimEngine.DataFormat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">DataFormat(T::Type)</code></pre><p>返回类型 <code>T</code> 的数据格式。数据格式用于确定如何遍历数据。支持以下数据格式：</p><ul><li><code>TableAlike</code>：数据为类似表格的对象，例如 <code>DataFrame</code> 或 <code>TimeStepTable</code>。数据通过 <code>Tables.jl</code> 接口按行遍历。</li><li><code>SingletonAlike</code>：数据为类似单例的对象，例如 <code>NamedTuple</code> 或 <code>TimeStepRow</code>。数据通过按列遍历。</li><li><code>TreeAlike</code>：数据为类似树结构的对象，例如 <code>Node</code>。</li></ul><p>默认实现中，<code>AbstractDataFrame</code>、<code>TimeStepTable</code>、<code>AbstractVector</code> 和 <code>Dict</code> 返回 <code>TableAlike</code>；<code>GraphSimulation</code> 返回 <code>TreeAlike</code>；<code>Status</code>、<code>ModelList</code>、<code>NamedTuple</code> 和 <code>TimeStepRow</code> 返回 <code>SingletonAlike</code>。</p><p><code>Any</code> 的默认实现会抛出异常。如果用户希望使用其他输入类型，应为新数据格式定义此 trait，例如：</p><pre><code class="language-julia hljs">PlantSimEngine.DataFormat(::Type{&lt;:MyType}) = TableAlike()</code></pre><p><strong>示例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using PlantSimEngine, PlantMeteo, DataFrames

julia&gt; PlantSimEngine.DataFormat(DataFrame)
PlantSimEngine.TableAlike()

julia&gt; PlantSimEngine.DataFormat(TimeStepTable([Status(a = 1, b = 2, c = 3)]))
PlantSimEngine.TableAlike()

julia&gt; PlantSimEngine.DataFormat([1, 2, 3])
PlantSimEngine.TableAlike()

julia&gt; PlantSimEngine.DataFormat(Dict(:a =&gt; 1, :b =&gt; 2))
PlantSimEngine.TableAlike()

julia&gt; PlantSimEngine.DataFormat(Status(a = 1, b = 2, c = 3))
PlantSimEngine.SingletonAlike()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/traits/table_traits.jl#L6-L43">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.DependencyGraph"><a class="docstring-binding" href="#PlantSimEngine.DependencyGraph"><code>PlantSimEngine.DependencyGraph</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DependencyGraph{T}(roots::T, not_found::Dict{Symbol,DataType})</code></pre><p>模型之间依赖关系的图。</p><p><strong>参数</strong></p><ul><li><code>roots::T</code>：图的根节点。</li><li><code>not_found::Dict{Symbol,DataType}</code>：在图中未找到的模型。</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/dependencies/dependency_graph.jl#L32-L41">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.DependencyTrait"><a class="docstring-binding" href="#PlantSimEngine.DependencyTrait"><code>PlantSimEngine.DependencyTrait</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DependencyTrait(T::Type)</code></pre><p>返回关于模型 <code>T</code> 在计算时是否依赖于其他时间步或对象的信息。依赖特性用于判断模型能否并行化。</p><p>支持以下依赖特性：</p><ul><li><code>TimeStepDependencyTrait</code>：定义模型对于时间步是否可以并行化计算的特性。</li><li><code>ObjectDependencyTrait</code>：定义模型对于对象是否可以并行化计算的特性。</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/traits/parallel_traits.jl#L1-L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.GraphSimulation"><a class="docstring-binding" href="#PlantSimEngine.GraphSimulation"><code>PlantSimEngine.GraphSimulation</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GraphSimulation(graph, mapping)
GraphSimulation(graph, statuses, dependency_graph, models, outputs)</code></pre><p>一个类型，包含了图上仿真所需的所有信息。</p><p><strong>参数</strong></p><ul><li><code>graph</code>：一个图实例，比如 MTG</li><li><code>mapping</code>：模型映射字典</li><li><code>statuses</code>：定义每个节点状态的结构体</li><li><code>status_templates</code>：状态模板字典</li><li><code>reverse_multiscale_mapping</code>：多尺度下其它层次的映射字典</li><li><code>var_need_init</code>：需要初始化的变量字典</li><li><code>dependency_graph</code>：应用于图的模型的依赖图</li><li><code>models</code>：模型字典</li><li><code>outputs</code>：输出字典</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/mtg/GraphSimulation.jl#L1-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.MappedVar"><a class="docstring-binding" href="#PlantSimEngine.MappedVar"><code>PlantSimEngine.MappedVar</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MappedVar(source_organ, variable, source_variable, source_default)</code></pre><p>映射到其他层级的变量。</p><p><strong>参数</strong></p><ul><li><code>source_organ</code>: 映射所针对的器官（或多个器官）</li><li><code>variable</code>: 被映射的变量名</li><li><code>source_variable</code>: 来源器官中的变量名（实际计算该变量的变量名）</li><li><code>source_default</code>: 变量的默认值</li></ul><p><strong>示例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using PlantSimEngine</code></pre><pre><code class="language-julia-repl hljs">julia&gt; PlantSimEngine.MappedVar(PlantSimEngine.SingleNodeMapping(&quot;Leaf&quot;), :carbon_assimilation, :carbon_assimilation, 1.0)
PlantSimEngine.MappedVar{PlantSimEngine.SingleNodeMapping, Symbol, Symbol, Float64}(PlantSimEngine.SingleNodeMapping(&quot;Leaf&quot;), :carbon_assimilation, :carbon_assimilation, 1.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/mtg/mapping/mapping.jl#L40-L62">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.MultiNodeMapping"><a class="docstring-binding" href="#PlantSimEngine.MultiNodeMapping"><code>PlantSimEngine.MultiNodeMapping</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MultiNodeMapping(scale)</code></pre><p>用于多节点映射的类型，例如 <code>[:carbon_assimilation =&gt; [&quot;Leaf&quot;],]</code>。注意 &quot;Leaf&quot; 以向量形式给出， 这意味着 <code>:carbon_assimilation</code> 将会是从植物图中每个 &quot;Leaf&quot; 取得的值的向量。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/mtg/mapping/mapping.jl#L28-L33">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.ObjectDependencyTrait"><a class="docstring-binding" href="#PlantSimEngine.ObjectDependencyTrait"><code>PlantSimEngine.ObjectDependencyTrait</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ObjectDependencyTrait(::Type{T})</code></pre><p>定义模型 <code>T</code> 计算时是否依赖其他对象的特性。该依赖特性用于判断模型是否可以在对象上并行化。</p><p>支持以下依赖特性：</p><ul><li><code>IsObjectDependent</code>：模型依赖其他对象计算，不能并行。</li><li><code>IsObjectIndependent</code>：模型不依赖其他对象，可以并行。</li></ul><p>所有模型默认设为对象依赖（即 <code>IsObjectDependent</code>）。这样设计的考虑：</p><ol><li>这是最安全的默认值，如果用户忘记重载不会导致错误，而相反则可能出错。</li><li>对于对象独立模型，用户可以方便重载 trait。</li></ol><p><strong>参见</strong></p><ul><li><a href="API_private.html#PlantSimEngine.timestep_parallelizable-Tuple{T} where T"><code>timestep_parallelizable</code></a>：判断模型能否按时间步并行。</li><li><a href="API_private.html#PlantSimEngine.object_parallelizable-Tuple{T} where T"><code>object_parallelizable</code></a>：判断模型能否按对象并行。</li><li><a href="API_private.html#PlantSimEngine.parallelizable-Tuple{T} where T"><code>parallelizable</code></a>：判断模型是否可并行化。</li><li><a href="API_private.html#PlantSimEngine.TimeStepDependencyTrait-Tuple{Type}"><code>TimeStepDependencyTrait</code></a>：定义模型对其他时间步的依赖性。</li></ul><p><strong>示例</strong></p><p>定义一个测试过程:</p><pre><code class="language-julia hljs">using PlantSimEngine

# 定义一个测试过程:
@process &quot;TestProcess&quot;</code></pre><p>定义一个对象独立的模型:</p><pre><code class="language-julia hljs">struct MyModel &lt;: AbstractTestprocessModel end

# 重载对象依赖 trait:
PlantSimEngine.ObjectDependencyTrait(::Type{MyModel}) = IsObjectIndependent()</code></pre><p>检查模型能否按对象并行:</p><pre><code class="language-julia hljs">object_parallelizable(MyModel()) # false</code></pre><p>定义一个对象依赖的模型:</p><pre><code class="language-julia hljs">struct MyModel2 &lt;: AbstractTestprocessModel end

# 重载对象依赖 trait:
PlantSimEngine.ObjectDependencyTrait(::Type{MyModel2}) = IsObjectDependent()</code></pre><p>检查模型能否按对象并行:</p><pre><code class="language-julia hljs">object_parallelizable(MyModel()) # true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/traits/parallel_traits.jl#L127-L188">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.RefVariable"><a class="docstring-binding" href="#PlantSimEngine.RefVariable"><code>PlantSimEngine.RefVariable</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RefVariable(reference_variable)</code></pre><p>用于手动标记模型中的某个变量，以在<strong>相同尺度</strong>下采用另一个变量的值的结构体。 用于变量重命名，当某变量已经由一个模型计算，但被另一个名称所引用时使用。</p><p>注意：在 status 中我们并不会真正重命名变量（其他模型可能需要这个变量），而是新建一个对原有变量的引用。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/variables_wrappers.jl#L33-L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.RefVector"><a class="docstring-binding" href="#PlantSimEngine.RefVector"><code>PlantSimEngine.RefVector</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RefVector(field::Symbol, sts...)
RefVector(field::Symbol, sts::Vector{&lt;:Status})
RefVector(v::Vector{Base.RefValue{T}})</code></pre><p>一个引用结构体向量中特定字段的引用向量。 用于在不同尺度之间高效地传递数值。</p><p><strong>参数</strong></p><ul><li><code>field</code>: 要引用的结构体字段</li><li><code>sts...</code>: 要引用的结构体实例</li><li><code>sts::Vector{&lt;:Status}</code>: 要引用的结构体实例向量</li></ul><p><strong>示例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using PlantSimEngine</code></pre><p>假设有两个 Status 结构体：</p><pre><code class="language-julia-repl hljs">julia&gt; status1 = Status(a = 1.0, b = 2.0, c = 3.0);</code></pre><pre><code class="language-julia-repl hljs">julia&gt; status2 = Status(a = 2.0, b = 3.0, c = 4.0);</code></pre><p>我们可以创建引用结构体 status1 和 status2 字段 <code>a</code> 的 RefVector：</p><pre><code class="language-julia-repl hljs">julia&gt; rv = PlantSimEngine.RefVector(:a, status1, status2)
2-element PlantSimEngine.RefVector{Float64}:
 1.0
 2.0</code></pre><p>这等效于：</p><pre><code class="language-julia-repl hljs">julia&gt; rv = PlantSimEngine.RefVector(:a, [status1, status2])
2-element PlantSimEngine.RefVector{Float64}:
 1.0
 2.0</code></pre><p>可以访问 RefVector 的值：</p><pre><code class="language-julia-repl hljs">julia&gt; rv[1]
1.0</code></pre><p>修改 RefVector 中的值会同时修改原结构体中的值：</p><pre><code class="language-julia-repl hljs">julia&gt; rv[1] = 10.0
10.0</code></pre><pre><code class="language-julia-repl hljs">julia&gt; status1.a
10.0</code></pre><p>我们还可以通过引用向量创建 RefVector：</p><pre><code class="language-julia-repl hljs">julia&gt; vec = [Ref(1.0), Ref(2.0), Ref(3.0)]
3-element Vector{Base.RefValue{Float64}}:
 Base.RefValue{Float64}(1.0)
 Base.RefValue{Float64}(2.0)
 Base.RefValue{Float64}(3.0)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; rv = PlantSimEngine.RefVector(vec)
3-element PlantSimEngine.RefVector{Float64}:
 1.0
 2.0
 3.0</code></pre><pre><code class="language-julia-repl hljs">julia&gt; rv[1]
1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/component_models/RefVector.jl#L1-L90">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.SelfNodeMapping"><a class="docstring-binding" href="#PlantSimEngine.SelfNodeMapping"><code>PlantSimEngine.SelfNodeMapping</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SelfNodeMapping()</code></pre><p>自节点映射类型，即节点映射到其自身。 用于标记将会被其他模型以标量值引用的变量。可出现于两种情况：     - 该变量由其他层级计算，因此需要作为输入存在于本层级（否则不会在本层级计算）     - 该变量作为输入用于其他层级，但仅以单值（标量）引用，因此需要将其作为标量引用。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/mtg/mapping/mapping.jl#L18-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.SingleNodeMapping"><a class="docstring-binding" href="#PlantSimEngine.SingleNodeMapping"><code>PlantSimEngine.SingleNodeMapping</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SingleNodeMapping(scale)</code></pre><p>用于单节点映射的类型，例如 <code>[:soil_water_content =&gt; &quot;Soil&quot;,]</code>。注意 &quot;Soil&quot; 是以标量形式给出， 这意味着 <code>:soil_water_content</code> 将会是从植物图中特定的 &quot;Soil&quot; 节点取得的一个标量值。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/mtg/mapping/mapping.jl#L8-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.TimeStepDependencyTrait-Tuple{Type}"><a class="docstring-binding" href="#PlantSimEngine.TimeStepDependencyTrait-Tuple{Type}"><code>PlantSimEngine.TimeStepDependencyTrait</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">TimeStepDependencyTrait(::Type{T})</code></pre><p>定义模型 <code>T</code> 计算时是否依赖其他时间步的特性。该依赖特性用于判断模型是否可以在时间步上并行化。</p><p>支持以下依赖特性：</p><ul><li><code>IsTimeStepDependent</code>：该模型的计算依赖其他时间步，不能并行执行。</li><li><code>IsTimeStepIndependent</code>：该模型的计算不依赖其他时间步，可以并行执行。</li></ul><p>所有模型默认设为时间步依赖（即 <code>IsTimeStepDependent</code>）。虽然大多数模型不一定如此，但这样设计有两个原因：</p><ol><li>这是最安全的默认值——如果用户忘记重载这个 trait，不会导致错误结果，相反（设为独立）则可能出错。</li><li>对于时间步独立的模型，用户可以很方便地重载此 trait。</li></ol><p><strong>参见</strong></p><ul><li><a href="API_private.html#PlantSimEngine.timestep_parallelizable-Tuple{T} where T"><code>timestep_parallelizable</code></a>：判断模型能否在时间步并行。</li><li><a href="API_private.html#PlantSimEngine.object_parallelizable-Tuple{T} where T"><code>object_parallelizable</code></a>：判断模型能否在对象间并行。</li><li><a href="API_private.html#PlantSimEngine.parallelizable-Tuple{T} where T"><code>parallelizable</code></a>：判断模型是否可并行化。</li><li><a href="API_private.html#PlantSimEngine.ObjectDependencyTrait"><code>ObjectDependencyTrait</code></a>：定义模型对其他对象的依赖性。</li></ul><p><strong>示例</strong></p><p>定义一个测试过程:</p><pre><code class="language-julia hljs">using PlantSimEngine

# 定义一个测试过程:
@process &quot;TestProcess&quot;</code></pre><p>定义一个时间步独立的模型:</p><pre><code class="language-julia hljs">struct MyModel &lt;: AbstractTestprocessModel end

# 重载时间步依赖 trait:
PlantSimEngine.TimeStepDependencyTrait(::Type{MyModel}) = IsTimeStepIndependent()</code></pre><p>检查模型能否按时间步并行:</p><pre><code class="language-julia hljs">timestep_parallelizable(MyModel()) # false</code></pre><p>定义一个时间步依赖的模型:</p><pre><code class="language-julia hljs">struct MyModel2 &lt;: AbstractTestprocessModel end

# 重载时间步依赖 trait:
PlantSimEngine.TimeStepDependencyTrait(::Type{MyModel2}) = IsTimeStepDependent()</code></pre><p>检查模型能否按时间步并行:</p><pre><code class="language-julia hljs">timestep_parallelizable(MyModel()) # true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/traits/parallel_traits.jl#L17-L78">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.UninitializedVar"><a class="docstring-binding" href="#PlantSimEngine.UninitializedVar"><code>PlantSimEngine.UninitializedVar</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">UninitializedVar(variable, value)</code></pre><p>尚未初始化的变量，赋予一个名称和一个默认值。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/variables_wrappers.jl#L1-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.copy-Tuple{T} where T&lt;:(AbstractArray{&lt;:ModelList})"><a class="docstring-binding" href="#Base.copy-Tuple{T} where T&lt;:(AbstractArray{&lt;:ModelList})"><code>Base.copy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.copy(l::AbstractArray{&lt;:ModelList})</code></pre><p>复制 <a href="../step_by_step/simple_model_coupling.html#ModelList"><code>ModelList</code></a> 的数组类结构</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/component_models/ModelList.jl#L321-L325">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.copy-Tuple{T} where T&lt;:(AbstractDict{N, &lt;:ModelList} where N)"><a class="docstring-binding" href="#Base.copy-Tuple{T} where T&lt;:(AbstractDict{N, &lt;:ModelList} where N)"><code>Base.copy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.copy(l::AbstractDict{N,&lt;:ModelList} where N)</code></pre><p>复制字典类 <a href="../step_by_step/simple_model_coupling.html#ModelList"><code>ModelList</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/component_models/ModelList.jl#L330-L334">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.copy-Tuple{T} where T&lt;:ModelList"><a class="docstring-binding" href="#Base.copy-Tuple{T} where T&lt;:ModelList"><code>Base.copy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.copy(l::ModelList)
Base.copy(l::ModelList, status)</code></pre><p>复制一个 <a href="../step_by_step/simple_model_coupling.html#ModelList"><code>ModelList</code></a>，可选替换新的 status。</p><p><strong>示例</strong></p><pre><code class="language- hljs">using PlantSimEngine

# 包含示例过程和模型：
using PlantSimEngine.Examples;

# 创建模型列表：
models = ModelList(
    process1=Process1Model(1.0),
    process2=Process2Model(),
    process3=Process3Model(),
    status=(var1=15.0, var2=0.3)
)

# 复制模型列表：
ml2 = copy(models)

# 使用新 status 复制模型列表：
ml3 = copy(models, TimeStepTable([Status(var1=20.0, var2=0.5))])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/component_models/ModelList.jl#L274-L302">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.getindex-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:ModelList"><a class="docstring-binding" href="#Base.getindex-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:ModelList"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getindex(component&lt;:ModelList, key::Symbol)
getindex(component&lt;:ModelList, key)</code></pre><p>对组件模型结构进行索引:     - 当参数为整数时，会返回第 i 个时间步的状态     - 其他（Symbol、String）则会返回状态中的对应变量</p><p><strong>示例</strong></p><pre><code class="language-julia hljs">using PlantSimEngine

lm = ModelList(
    process1=Process1Model(1.0),
    process2=Process2Model(),
    process3=Process3Model(),
    status = (var1=[15.0, 16.0], var2=0.3)
);

lm[:var1] # 返回 Tₗ 变量的值
lm[2]  # 返回第二个时间步的状态
lm[2][:var1] # 返回第二个时间步的 Tₗ 变量的值
lm[:var1][2] # 等价于上面

# 输出
16.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/component_models/get_status.jl#L65-L93">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.add_mapped_variables_with_outputs_as_inputs!-Tuple{Any}"><a class="docstring-binding" href="#PlantSimEngine.add_mapped_variables_with_outputs_as_inputs!-Tuple{Any}"><code>PlantSimEngine.add_mapped_variables_with_outputs_as_inputs!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_mapped_variables_with_outputs_as_inputs!(mapped_vars)</code></pre><p>将计算于一个尺度并写入到另一个尺度的变量添加进映射字典。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/mtg/mapping/compute_mapping.jl#L129-L133">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.add_model_vars-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#PlantSimEngine.add_model_vars-Tuple{Any, Any, Any}"><code>PlantSimEngine.add_model_vars</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_model_vars(x, models, type_promotion)</code></pre><p>检测 <code>x</code> 中哪些变量还未初始化（根据一组 <code>models</code> 及其所需模拟变量）。如有变量未初始化，将其初始化为默认值。</p><p>本函数需根据不同类型的 <code>x</code> 实现。默认方法适用于任意 Tables.jl 兼容结构和 NamedTuples。</p><p>注意，该函数会在变量未齐全时复制输入 <code>x</code>。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/component_models/ModelList.jl#L186-L194">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.check_dimensions-Tuple{Any, Any}"><a class="docstring-binding" href="#PlantSimEngine.check_dimensions-Tuple{Any, Any}"><code>PlantSimEngine.check_dimensions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">check_dimensions(component,weather)
check_dimensions(status,weather)</code></pre><p>检查组件状态（或直接检查状态）和天气数据长度是否一致，或它们是否可以被复用（其中一个的长度为1）。</p><p><strong>示例</strong></p><pre><code class="language-julia hljs">using PlantSimEngine, PlantMeteo

# 引入包含虚拟过程和模型的示例脚本：
using PlantSimEngine.Examples

# 创建一个虚拟天气：
w = Atmosphere(T = 20.0, Rh = 0.5, Wind = 1.0)

# 创建一个虚拟组件：
models = ModelList(
    process1=Process1Model(1.0),
    process2=Process2Model(),
    process3=Process3Model(),
    status=(var1=[15.0, 16.0], var2=0.3)
)

# 检查时间步数是否兼容（此处兼容，返回nothing）：
PlantSimEngine.check_dimensions(models, w) 

# 创建一个包含3个时间步的虚拟天气：
w = Weather([
    Atmosphere(T = 20.0, Rh = 0.5, Wind = 1.0),
    Atmosphere(T = 25.0, Rh = 0.5, Wind = 1.0),
    Atmosphere(T = 30.0, Rh = 0.5, Wind = 1.0)
])

# 检查时间步数是否兼容（此处不兼容，会抛出错误）：
PlantSimEngine.check_dimensions(models, w)

# output
ERROR: DimensionMismatch: Component status has a vector variable : var1 implying multiple timesteps but weather data only provides a single timestep.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/checks/dimensions.jl#L1-L41">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.convert_reference_values!-Tuple{Dict{String, Dict{Symbol, Any}}}"><a class="docstring-binding" href="#PlantSimEngine.convert_reference_values!-Tuple{Dict{String, Dict{Symbol, Any}}}"><code>PlantSimEngine.convert_reference_values!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">convert_reference_values!(mapped_vars::Dict{String,Dict{Symbol,Any}})</code></pre><p>将<code>MappedVar{SelfNodeMapping}</code>或<code>MappedVar{SingleNodeMapping}</code>变量转为参考同一变量值的RefValue； 将<code>MappedVar{MultiNodeMapping}</code>转为RefVector，引用源器官的变量值。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/mtg/mapping/compute_mapping.jl#L277-L282">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.convert_vars"><a class="docstring-binding" href="#PlantSimEngine.convert_vars"><code>PlantSimEngine.convert_vars</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">convert_vars(ref_vars, type_promotion::Dict{DataType,DataType})
convert_vars(ref_vars, type_promotion::Nothing)
convert_vars!(ref_vars::Dict{Symbol}, type_promotion::Dict{DataType,DataType})
convert_vars!(ref_vars::Dict{Symbol}, type_promotion::Nothing)</code></pre><p>将 status 变量转换为 type_promotion 字典中指定的类型。 <em>注：带 ! 的变异版仅适用于变量字典。</em></p><p><strong>示例</strong></p><p>若需将所有 Real 类型变量转为 Float32，可使用：</p><pre><code class="language-julia hljs">using PlantSimEngine

# 包含示例过程和模型：
using PlantSimEngine.Examples;

ref_vars = init_variables(
    process1=Process1Model(1.0),
    process2=Process2Model(),
    process3=Process3Model(),
)
type_promotion = Dict(Real =&gt; Float32)

PlantSimEngine.convert_vars(type_promotion, ref_vars.process3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/component_models/ModelList.jl#L340-L368">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.convert_vars!"><a class="docstring-binding" href="#PlantSimEngine.convert_vars!"><code>PlantSimEngine.convert_vars!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">convert_vars(ref_vars, type_promotion::Dict{DataType,DataType})
convert_vars(ref_vars, type_promotion::Nothing)
convert_vars!(ref_vars::Dict{Symbol}, type_promotion::Dict{DataType,DataType})
convert_vars!(ref_vars::Dict{Symbol}, type_promotion::Nothing)</code></pre><p>将 status 变量转换为 type_promotion 字典中指定的类型。 <em>注：带 ! 的变异版仅适用于变量字典。</em></p><p><strong>示例</strong></p><p>若需将所有 Real 类型变量转为 Float32，可使用：</p><pre><code class="language-julia hljs">using PlantSimEngine

# 包含示例过程和模型：
using PlantSimEngine.Examples;

ref_vars = init_variables(
    process1=Process1Model(1.0),
    process2=Process2Model(),
    process3=Process3Model(),
)
type_promotion = Dict(Real =&gt; Float32)

PlantSimEngine.convert_vars(type_promotion, ref_vars.process3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/component_models/ModelList.jl#L340-L368">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.convert_vars!-Tuple{Dict{String, Dict{Symbol, Any}}, Any}"><a class="docstring-binding" href="#PlantSimEngine.convert_vars!-Tuple{Dict{String, Dict{Symbol, Any}}, Any}"><code>PlantSimEngine.convert_vars!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">convert_vars!(mapped_vars::Dict{String,Dict{String,Any}}, type_promotion)</code></pre><p>使用 <code>type_promotion</code> 字典将映射（<code>mapped_vars</code>）中的变量类型进行转换。</p><p><code>mapped_vars</code> 应为器官名称到变量字典的字典，变量名为 Symbol，变量值为值。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/component_models/ModelList.jl#L434-L440">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.default_variables_from_mapping"><a class="docstring-binding" href="#PlantSimEngine.default_variables_from_mapping"><code>PlantSimEngine.default_variables_from_mapping</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">default_variables_from_mapping(mapped_vars, verbose=true)</code></pre><p>递归从映射关系中查找原始映射值，获取映射变量的默认值。</p><p><strong>参数</strong></p><ul><li><code>mapped_vars::Dict{String,Dict{Symbol,Any}}</code>: 每个器官的映射变量。</li><li><code>verbose::Bool</code>: 是否打印在mapping中查找默认值的堆栈追踪。</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/mtg/mapping/compute_mapping.jl#L241-L250">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.diff_vars-Tuple{Any, Any}"><a class="docstring-binding" href="#PlantSimEngine.diff_vars-Tuple{Any, Any}"><code>PlantSimEngine.diff_vars</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">diff_vars(x, y)</code></pre><p>返回 x 和 y 中值不同的变量名称。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/processes/models_inputs_outputs.jl#L259-L263">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.draw_guide-NTuple{5, Any}"><a class="docstring-binding" href="#PlantSimEngine.draw_guide-NTuple{5, Any}"><code>PlantSimEngine.draw_guide</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">draw_guide(h, w, prefix, isleaf, guides)</code></pre><p>为依赖图的一个节点绘制连线引导</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/dependencies/printing.jl#L130-L134">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.draw_panel"><a class="docstring-binding" href="#PlantSimEngine.draw_panel"><code>PlantSimEngine.draw_panel</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">draw_panel(node, graph, prefix, dep_graph_guides, parent; title=&quot;Soft-coupled model&quot;)</code></pre><p>为所有依赖项绘制面板</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/dependencies/printing.jl#L40-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.drop_process-Tuple{Any, Symbol}"><a class="docstring-binding" href="#PlantSimEngine.drop_process-Tuple{Any, Symbol}"><code>PlantSimEngine.drop_process</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">drop_process(proc_vars, process)</code></pre><p>返回将 <code>NamedTuple</code> <code>proc_vars</code> 中 process <code>process</code> 删除后的新 <code>NamedTuple</code>。</p><p><strong>参数</strong></p><ul><li><code>proc_vars::NamedTuple</code>: 要删除进程的 <code>NamedTuple</code>。</li><li><code>process::Symbol</code>: 需要从 <code>NamedTuple</code> <code>proc_vars</code> 中删除的进程。</li></ul><p><strong>返回</strong></p><p>删除了 process 后的 <code>NamedTuple</code>。</p><p><strong>示例</strong></p><pre><code class="language-julia hljs">julia&gt; drop_process((a = 1, b = 2, c = 3), :b)
(a = 1, c = 3)

julia&gt; drop_process((a = 1, b = 2, c = 3), (:a, :c))
(b = 2,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/dependencies/soft_dependencies.jl#L324-L347">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.flatten_vars-Tuple{Any}"><a class="docstring-binding" href="#PlantSimEngine.flatten_vars-Tuple{Any}"><code>PlantSimEngine.flatten_vars</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">flatten_vars(vars)</code></pre><p>返回 <code>vars</code> 字典中的变量集合。</p><p><strong>参数</strong></p><ul><li><code>vars::Dict{Symbol, Tuple{Symbol, Vararg{Symbol}}}</code>: 进程到变量内容的字典。</li></ul><p><strong>返回</strong></p><p><code>vars</code> 字典中的变量集合。</p><p><strong>示例</strong></p><pre><code class="language-julia hljs">julia&gt; flatten_vars(Dict(:process1 =&gt; (:var1, :var2), :process2 =&gt; (:var3, :var4)))
Set{Symbol} with 4 elements:
  :var4
  :var3
  :var2
  :var1</code></pre><pre><code class="language-julia hljs">julia&gt; flatten_vars([:process1 =&gt; (var1 = -Inf, var2 = -Inf), :process2 =&gt; (var3 = -Inf, var4 = -Inf)])
(var2 = -Inf, var4 = -Inf, var3 = -Inf, var1 = -Inf)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/dependencies/soft_dependencies.jl#L523-L551">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.get_mapped_variables-Tuple{Any}"><a class="docstring-binding" href="#PlantSimEngine.get_mapped_variables-Tuple{Any}"><code>PlantSimEngine.get_mapped_variables</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_mapped_variables(m)</code></pre><p>获取模型映射字典中的变量映射。</p><p><strong>参数</strong></p><ul><li><code>m::Dict{String,Any}</code>: 一个模型映射的字典</li></ul><p>返回由符号和字符串或字符串向量组成的Pair的向量。</p><p><strong>示例</strong></p><p>参见<a href="API_private.html#PlantSimEngine.get_models-Tuple{Any}"><code>get_models</code></a>中的示例。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/mtg/mapping/getters.jl#L92-L106">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.get_model_nodes-Tuple{PlantSimEngine.DependencyGraph, Any}"><a class="docstring-binding" href="#PlantSimEngine.get_model_nodes-Tuple{PlantSimEngine.DependencyGraph, Any}"><code>PlantSimEngine.get_model_nodes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_model_nodes(dep_graph::DependencyGraph, model)</code></pre><p>获取依赖图中实现某种模型类型的节点。</p><p><strong>参数</strong></p><ul><li><code>dep_graph::DependencyGraph</code>：依赖关系图。</li><li><code>model</code>：要查找的模型类型。</li></ul><p><strong>返回</strong></p><ul><li>实现该模型类型的节点数组。</li></ul><p><strong>示例</strong></p><pre><code class="language-julia hljs">PlantSimEngine.get_model_nodes(dependency_graph, Beer)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/dependencies/get_model_in_dependency_graph.jl#L1-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.get_models-Tuple{Any}"><a class="docstring-binding" href="#PlantSimEngine.get_models-Tuple{Any}"><code>PlantSimEngine.get_models</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_models(m)</code></pre><p>获取模型映射字典中的模型。</p><p><strong>参数</strong></p><ul><li><code>m::Dict{String,Any}</code>: 一个模型映射的字典</li></ul><p>返回一个模型的向量</p><p><strong>示例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using PlantSimEngine;</code></pre><p>导入示例模型（可以在本包的<code>examples</code>文件夹或<code>Examples</code>子模块中找到）:</p><pre><code class="language-julia-repl hljs">julia&gt; using PlantSimEngine.Examples;</code></pre><p>如果只提供一个MultiScaleModel，将获得其模型，结果为单元素向量：</p><pre><code class="language-julia-repl hljs">julia&gt; models = MultiScaleModel( model=ToyCAllocationModel(), mapped_variables=[ :carbon_assimilation =&gt; [&quot;Leaf&quot;], :carbon_demand =&gt; [&quot;Leaf&quot;, &quot;Internode&quot;], :carbon_allocation =&gt; [&quot;Leaf&quot;, &quot;Internode&quot;] ], );</code></pre><pre><code class="language-julia-repl hljs">julia&gt; PlantSimEngine.get_models(models)
1-element Vector{ToyCAllocationModel}:
 ToyCAllocationModel()</code></pre><p>如果提供一个模型元组，将分别得到每个模型，返回为向量：</p><pre><code class="language-julia-repl hljs">julia&gt; models2 = (  MultiScaleModel( model=ToyAssimModel(), mapped_variables=[:soil_water_content =&gt; &quot;Soil&quot;,], ), ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0), Status(aPPFD=1300.0, TT=10.0), );</code></pre><p>注意此处在映射时提供的是&quot;Soil&quot;而不是[&quot;Soil&quot;]，因为此处只需要一个值。</p><pre><code class="language-julia-repl hljs">julia&gt; PlantSimEngine.get_models(models2)
2-element Vector{AbstractModel}:
 ToyAssimModel{Float64}(0.2)
 ToyCDemandModel{Float64}(10.0, 200.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/mtg/mapping/getters.jl#L1-L50">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.get_multiscale_default_value"><a class="docstring-binding" href="#PlantSimEngine.get_multiscale_default_value"><code>PlantSimEngine.get_multiscale_default_value</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_multiscale_default_value(mapped_vars, val, mapping_stacktrace=[])</code></pre><p>从映射关系获取变量的默认值。</p><p><strong>参数</strong></p><ul><li><code>mapped_vars::Dict{String,Dict{Symbol,Any}}</code>: 每个器官的映射变量。</li><li><code>val::Any</code>: 需要获取默认值的变量。</li><li><code>mapping_stacktrace::Vector{Any}</code>: 在向上查找映射值时的堆栈追踪。</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/mtg/mapping/compute_mapping.jl#L193-L203">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.get_nsteps-Tuple{Any}"><a class="docstring-binding" href="#PlantSimEngine.get_nsteps-Tuple{Any}"><code>PlantSimEngine.get_nsteps</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_nsteps(t)</code></pre><p>获取对象的时间步数量。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/checks/dimensions.jl#L97-L101">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.get_status-Tuple{Any}"><a class="docstring-binding" href="#PlantSimEngine.get_status-Tuple{Any}"><code>PlantSimEngine.get_status</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_status(m)</code></pre><p>获取模型映射字典中的状态。</p><p><strong>参数</strong></p><ul><li><code>m::Dict{String,Any}</code>: 一个模型映射的字典</li></ul><p>返回<a href="API_public.html#PlantSimEngine.Status"><code>Status</code></a>或<code>nothing</code>。</p><p><strong>示例</strong></p><p>参见<a href="API_private.html#PlantSimEngine.get_models-Tuple{Any}"><code>get_models</code></a>中的示例。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/mtg/mapping/getters.jl#L70-L84">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.hard_dependencies-Tuple{Any}"><a class="docstring-binding" href="#PlantSimEngine.hard_dependencies-Tuple{Any}"><code>PlantSimEngine.hard_dependencies</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hard_dependencies(models; verbose::Bool=true)
hard_dependencies(mapping::Dict{String,T}; verbose::Bool=true)</code></pre><p>计算模型之间的硬依赖关系。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/dependencies/hard_dependencies.jl#L1-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.homogeneous_ts_kwargs-Tuple{Any}"><a class="docstring-binding" href="#PlantSimEngine.homogeneous_ts_kwargs-Tuple{Any}"><code>PlantSimEngine.homogeneous_ts_kwargs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">homogeneous_ts_kwargs(kwargs)</code></pre><p>默认情况下，此函数直接返回其参数。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/component_models/ModelList.jl#L246-L250">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.homogeneous_ts_kwargs-Union{Tuple{NamedTuple{N, T}}, Tuple{T}, Tuple{N}} where {N, T}"><a class="docstring-binding" href="#PlantSimEngine.homogeneous_ts_kwargs-Union{Tuple{NamedTuple{N, T}}, Tuple{T}, Tuple{N}} where {N, T}"><code>PlantSimEngine.homogeneous_ts_kwargs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">kwargs_to_timestep(kwargs::NamedTuple{N,T}) where {N,T}</code></pre><p>将各变量为（可选）向量的 NamedTuple，转换为每个时间步为一个 NamedTuple 的向量。 可用于对某一变量在所有时间步赋常值。</p><p><strong>示例</strong></p><pre><code class="language- hljs">PlantSimEngine.homogeneous_ts_kwargs((Tₗ=[25.0, 26.0], aPPFD=1000.0))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/component_models/ModelList.jl#L253-L264">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.init_node_status!"><a class="docstring-binding" href="#PlantSimEngine.init_node_status!"><code>PlantSimEngine.init_node_status!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">init_node_status!(
    node, 
    statuses, 
    mapped_vars, 
    reverse_multiscale_mapping,
    vars_need_init=Dict{String,Any}(),
    type_promotion=nothing;
    check=true,
    attribute_name=:plantsimengine_status)
)</code></pre><p>初始化植物图节点的状态，考虑多尺度映射，并将状态添加到statuses字典中。</p><p><strong>参数</strong></p><ul><li><code>node</code>：要初始化的节点</li><li><code>statuses</code>：按节点类型分的状态字典</li><li><code>mapped_vars</code>：每个节点类型的状态模板</li><li><code>reverse_multiscale_mapping</code>：被映射到其他尺度的变量</li><li><code>var_need_init</code>：没有被其它模型初始化或计算的变量</li><li><code>nodes_with_models</code>：有模型定义的节点</li><li><code>type_promotion</code>：变量类型提升</li><li><code>check</code>：是否检查映射中的错误（见Details）</li><li><code>attribute_name</code>：状态存储到节点中的属性名，默认为<code>:plantsimengine_status</code></li></ul><p><strong>细节</strong></p><p>大部分参数可以根据图和映射计算获得：</p><ul><li><code>statuses</code>通过第一次初始化获得：<code>statuses = Dict(i =&gt; Status[] for i in nodes_with_models)</code></li><li><code>mapped_vars</code>用<code>mapped_variables()</code>得到，见<code>init_statuses</code>中的代码</li><li><code>vars_need_init</code>通过<code>vars_need_init = Dict(org =&gt; filter(x -&gt; isa(last(x), UninitializedVar), vars) |&gt; keys for (org, vars) in mapped_vars) |&gt; filter(x -&gt; length(last(x)) &gt; 0)</code> 计算获得</li></ul><p><code>check</code>参数表示是否检查变量初始化。在某些变量需要初始化（部分初始化映射）的情况下，会判断节点属性（按变量名）中是否可获取。如果<code>true</code>，当属性不存在时会报错，否则使用模型的默认值。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/mtg/initialisation.jl#L55-L89">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.init_simulation-Tuple{Any, Any}"><a class="docstring-binding" href="#PlantSimEngine.init_simulation-Tuple{Any, Any}"><code>PlantSimEngine.init_simulation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">init_simulation(mtg, mapping; nsteps=1, outputs=nothing, type_promotion=nothing, check=true, verbose=true)</code></pre><p>初始化仿真环境，返回：</p><ul><li>mtg</li><li>各器官类型下每个节点的status，考虑多尺度变量</li><li>模型依赖图</li><li>模型字典 organ type =&gt; NamedTuple of process =&gt; model mapping</li><li>预分配的输出outputs</li></ul><p><strong>参数</strong></p><ul><li><code>mtg</code>：MTG</li><li><code>mapping::Dict{String,Any}</code>：模型映射字典</li><li><code>nsteps</code>：仿真步数</li><li><code>outputs</code>：仿真需要的动态输出项</li><li><code>type_promotion</code>：变量类型提升</li><li><code>check</code>：是否检查映射错误，会传递到<code>init_node_status!</code></li><li><code>verbose</code>：关于映射错误的信息</li></ul><p><strong>细节</strong></p><p>本函数首先为每个在mapping中拥有模型的器官类型计算status模板。 然后利用该模板初始化每个节点的status，兼顾用户自定义的初始化和多尺度mapping。 mapping用于对跨尺度定义的变量创建引用，从而保证当变量在其它尺度更新时自动同步。 目前支持两种多尺度变量类型：<code>RefVector</code>和<code>MappedVar</code>。 前者用于变量映射到一组节点，后者用于变量映射到单个节点。 用法为：只要用字符串即可表示单节点（如<code>=&gt; &quot;Leaf&quot;</code>），用字符串数组表示多节点（如<code>=&gt; [&quot;Leaf&quot;]</code>或<code>=&gt; [&quot;Leaf&quot;, &quot;Internode&quot;]</code>）。</p><p>本函数还会计算模型的依赖图，即根据模型间的输入输出关系，确定仿真调用顺序。 依赖图用于仿真运行时保证模型调用的合理顺序。</p><p>注意，如果变量既没有被模型计算，也没有在mapping初始化，会在MTG属性中查找其值。 该值是拷贝，而非对MTG属性的引用，因为无法引用Dict中的值。 如需引用特定变量，可以在MTG中直接用<code>Ref</code>，会被自动原样传递。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/mtg/initialisation.jl#L259-L295">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.init_statuses-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#PlantSimEngine.init_statuses-Tuple{Any, Any, Any}"><code>PlantSimEngine.init_statuses</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">init_statuses(mtg, mapping, dependency_graph=dep(mapping); type_promotion=nothing, verbose=true, check=true)</code></pre><p>获取每个MTG节点的状态，按节点类型分组，预初始化，考虑多尺度变量。</p><p><strong>参数</strong></p><ul><li><code>mtg</code>：植物图</li><li><code>mapping</code>：模型映射的字典</li><li><code>dependency_graph::DependencyGraph</code>：一级依赖图，其中每个模型在映射中被分配为一个节点。 但是，识别为硬依赖的模型不会单独作为节点存在，而是作为子节点嵌套在其他模型下。</li><li><code>type_promotion</code>：用于变量的类型提升</li><li><code>verbose</code>：在编译映射时打印信息</li><li><code>check</code>：是否检查映射中的错误。此参数会传递给<code>init_node_status!</code>。</li></ul><p><strong>返回值</strong></p><p>返回一个NamedTuple，内容包含按节点类型分的状态、按节点类型分的状态模板、被映射到其他尺度的变量字典、 需要被其它模型初始化或计算的变量字典，以及一个有已定义模型符号的节点向量：</p><p><code>(;statuses, status_templates, reverse_multiscale_mapping, vars_need_init, nodes_with_models)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/mtg/initialisation.jl#L1-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.init_variables_manual-Tuple{Any, Any}"><a class="docstring-binding" href="#PlantSimEngine.init_variables_manual-Tuple{Any, Any}"><code>PlantSimEngine.init_variables_manual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">init_variables_manual(models...;vars...)</code></pre><p>以给定值初始化模型变量。</p><p><strong>示例</strong></p><pre><code class="language- hljs">using PlantSimEngine

# 加载包中的示例虚拟模型：
using PlantSimEngine.Examples

models = ModelList(
    process1=Process1Model(1.0),
    process2=Process2Model(),
    process3=Process3Model()
)

PlantSimEngine.init_variables_manual(status(models), (var1=20.0,))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/processes/model_initialisation.jl#L348-L369">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.initialise_all_as_hard_dependency_node-Tuple{Any, Any}"><a class="docstring-binding" href="#PlantSimEngine.initialise_all_as_hard_dependency_node-Tuple{Any, Any}"><code>PlantSimEngine.initialise_all_as_hard_dependency_node</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">initialise_all_as_hard_dependency_node(models)</code></pre><p>针对一组模型，为每个模型初始化一个硬依赖节点， 并返回<code>:process =&gt; HardDependencyNode</code>组成的字典。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/dependencies/hard_dependencies.jl#L87-L92">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.is_graph_cyclic-Tuple{PlantSimEngine.DependencyGraph}"><a class="docstring-binding" href="#PlantSimEngine.is_graph_cyclic-Tuple{PlantSimEngine.DependencyGraph}"><code>PlantSimEngine.is_graph_cyclic</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_graph_cyclic(dependency_graph::DependencyGraph; full_stack=false, verbose=true)</code></pre><p>判断依赖图是否包含环。</p><p><strong>参数</strong></p><ul><li><code>dependency_graph::DependencyGraph</code>：需要检查的依赖图。</li><li><code>full_stack::Bool=false</code>：若为<code>true</code>，返回构成环的所有节点栈，否则只返回环本身。</li><li><code>warn::Bool=true</code>：若为<code>true</code>，当检测到环时输出格式化的警告信息。</li></ul><p>返回一个布尔值指示图是否有环，以及作为向量的节点栈。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/dependencies/is_graph_cyclic.jl#L1-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.mapped_variables"><a class="docstring-binding" href="#PlantSimEngine.mapped_variables"><code>PlantSimEngine.mapped_variables</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">mapped_variables(mapping, dependency_graph=first(hard_dependencies(mapping; verbose=false)); verbose=false)</code></pre><p>从依赖图中获取每种器官类型的变量，并为多尺度映射构建<code>MappedVar</code>。</p><p><strong>参数</strong></p><ul><li><code>mapping::Dict{String,T}</code>: 模型与尺度的映射关系。</li><li><code>dependency_graph::DependencyGraph</code>: 第一阶依赖图，每个mapping中的模型为一个节点。 但被识别为“硬依赖”的模型不会分配单独节点，而是作为子节点嵌套到其他模型下。</li><li><code>verbose::Bool</code>: 是否打印在mapping中寻找默认值时的堆栈跟踪。</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/mtg/mapping/compute_mapping.jl#L1-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.mapped_variables_no_outputs_from_other_scale"><a class="docstring-binding" href="#PlantSimEngine.mapped_variables_no_outputs_from_other_scale"><code>PlantSimEngine.mapped_variables_no_outputs_from_other_scale</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">mapped_variables_no_outputs_from_other_scale(mapping, dependency_graph=first(hard_dependencies(mapping; verbose=false)))</code></pre><p>从依赖图中获取每种器官类型的变量，但不包括那些来自其他尺度输出的变量。</p><p><strong>参数</strong></p><ul><li><code>mapping::Dict{String,T}</code>: 模型与尺度的映射关系。</li><li><code>dependency_graph::DependencyGraph</code>: 第一阶依赖图，每个mapping中的模型为一个节点。但硬依赖模型不会分配独立节点，而作为子节点嵌套到其他模型下。</li></ul><p><strong>细节</strong></p><p>本函数返回每个器官类型的（多尺度）输入输出变量字典。</p><p>注意本函数不包括来自其他尺度但在本尺度未计算的输出变量， 相关处理见<code>mapped_variables_with_outputs_as_inputs</code>。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/mtg/mapping/compute_mapping.jl#L36-L52">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.model_-Tuple{AbstractModel}"><a class="docstring-binding" href="#PlantSimEngine.model_-Tuple{AbstractModel}"><code>PlantSimEngine.model_</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">model_(m::AbstractModel)</code></pre><p>获取抽象模型的模型（如果不是多尺度模型 MultiScaleModel，则返回其本身）。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/Abstract_model_structs.jl#L19-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.object_parallelizable-Tuple{T} where T"><a class="docstring-binding" href="#PlantSimEngine.object_parallelizable-Tuple{T} where T"><code>PlantSimEngine.object_parallelizable</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">object_parallelizable(x::T)
object_parallelizable(x::DependencyGraph)</code></pre><p>判断模型 <code>x</code> 是否可以并行化计算，即模型是否能在不同对象间并行计算，返回 <code>true</code> 或 <code>false</code>。</p><p>默认情况下，所有模型均返回 <code>false</code>。 如果你的模型可以按对象并行化，应为其添加 <a href="API_private.html#PlantSimEngine.ObjectDependencyTrait"><code>ObjectDependencyTrait</code></a> 方法。</p><p>本方法也可直接用于 <a href="API_private.html#PlantSimEngine.DependencyGraph"><code>DependencyGraph</code></a>，若图中所有模型可并行化则返回 <code>true</code>，否则为 <code>false</code>。</p><p><strong>参见</strong></p><ul><li><a href="API_private.html#PlantSimEngine.timestep_parallelizable-Tuple{T} where T"><code>timestep_parallelizable</code></a>：判断模型能否按时间步并行。</li><li><a href="API_private.html#PlantSimEngine.parallelizable-Tuple{T} where T"><code>parallelizable</code></a>：判断模型是否可并行化。</li><li><a href="API_private.html#PlantSimEngine.ObjectDependencyTrait"><code>ObjectDependencyTrait</code></a>：定义模型对其他对象的依赖性。</li></ul><p><strong>示例</strong></p><p>定义一个测试过程:</p><pre><code class="language-julia hljs">using PlantSimEngine

# 定义一个测试过程:
@process &quot;TestProcess&quot;</code></pre><p>定义一个对象独立的模型:</p><pre><code class="language-julia hljs">struct MyModel &lt;: AbstractTestprocessModel end

# 重载对象依赖 trait:
PlantSimEngine.ObjectDependencyTrait(::Type{MyModel}) = IsObjectIndependent()</code></pre><p>检查模型能否按对象并行:</p><pre><code class="language-julia hljs">object_parallelizable(MyModel()) # true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/traits/parallel_traits.jl#L194-L235">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.parallelizable-Tuple{T} where T"><a class="docstring-binding" href="#PlantSimEngine.parallelizable-Tuple{T} where T"><code>PlantSimEngine.parallelizable</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">parallelizable(::T)
object_parallelizable(x::DependencyGraph)</code></pre><p>判断模型 <code>T</code> 或整个依赖图是否可并行化，也即模型是否可在不同的时间步或对象之间并行计算。默认所有模型均返回 <code>false</code>。</p><p><strong>参见</strong></p><ul><li><a href="API_private.html#PlantSimEngine.timestep_parallelizable-Tuple{T} where T"><code>timestep_parallelizable</code></a>：判断模型能否按时间步并行。</li><li><a href="API_private.html#PlantSimEngine.object_parallelizable-Tuple{T} where T"><code>object_parallelizable</code></a>：判断模型能否按对象并行。</li><li><a href="API_private.html#PlantSimEngine.TimeStepDependencyTrait-Tuple{Type}"><code>TimeStepDependencyTrait</code></a>：定义模型对其他时间步的依赖性。</li></ul><p><strong>示例</strong></p><p>定义一个测试过程:</p><pre><code class="language-julia hljs">using PlantSimEngine

# 定义一个测试过程:
@process &quot;TestProcess&quot;</code></pre><p>定义一个可并行化模型:</p><pre><code class="language-julia hljs">struct MyModel &lt;: AbstractTestprocessModel end

# 重载时间步依赖 trait:
PlantSimEngine.TimeStepDependencyTrait(::Type{MyModel}) = IsTimeStepIndependent()

# 重载对象依赖 trait:
PlantSimEngine.ObjectDependencyTrait(::Type{MyModel}) = IsObjectIndependent()</code></pre><p>检查模型是否可并行化:</p><pre><code class="language-julia hljs">parallelizable(MyModel()) # true</code></pre><p>或者更细致地查看：</p><pre><code class="language-julia hljs">timestep_parallelizable(MyModel())
object_parallelizable(MyModel())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/traits/parallel_traits.jl#L240-L286">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.ref_var-Tuple{Any}"><a class="docstring-binding" href="#PlantSimEngine.ref_var-Tuple{Any}"><code>PlantSimEngine.ref_var</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ref_var(v)</code></pre><p>为变量创建引用。如果变量已经是<code>Base.RefValue</code>，则直接返回，否则返回其副本的Ref， 如果是RefVector则返回其Ref。</p><p><strong>示例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using PlantSimEngine;</code></pre><pre><code class="language-julia-repl hljs">julia&gt; PlantSimEngine.ref_var(1.0)
Base.RefValue{Float64}(1.0)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; PlantSimEngine.ref_var([1.0])
Base.RefValue{Vector{Float64}}([1.0])</code></pre><pre><code class="language-julia-repl hljs">julia&gt; PlantSimEngine.ref_var(Base.RefValue(1.0))
Base.RefValue{Float64}(1.0)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; PlantSimEngine.ref_var(Base.RefValue([1.0]))
Base.RefValue{Vector{Float64}}([1.0])</code></pre><pre><code class="language-julia-repl hljs">julia&gt; PlantSimEngine.ref_var(PlantSimEngine.RefVector([Ref(1.0), Ref(2.0), Ref(3.0)]))
Base.RefValue{PlantSimEngine.RefVector{Float64}}(RefVector{Float64}[1.0, 2.0, 3.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/mtg/initialisation.jl#L215-L251">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.reverse_mapping-Union{Tuple{Dict{String, T}}, Tuple{T}} where T"><a class="docstring-binding" href="#PlantSimEngine.reverse_mapping-Union{Tuple{Dict{String, T}}, Tuple{T}} where T"><code>PlantSimEngine.reverse_mapping</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">reverse_mapping(mapping::Dict{String,Tuple{Any,Vararg{Any}}}; all=true)
reverse_mapping(mapped_vars::Dict{String,Dict{Symbol,Any}})</code></pre><p>获取模型映射字典的反向映射，即，被映射到其他尺度的变量，换句话说， 从给定尺度向其他尺度传递了哪些变量。 这可以用于，例如，了解哪些尺度需要把数值赋给其他尺度。</p><p><strong>参数</strong></p><ul><li><code>mapping::Dict{String,Any}</code>: 模型映射的字典。</li><li><code>all::Bool</code>: 是否获取所有被映射到其他尺度的变量，包括那些被映射为单一值的变量。</li></ul><p><strong>返回值</strong></p><p>一个以器官（键）为主的字典，值为字典：源器官 =&gt; 一组变量对的字典。你可以这样理解输出结果： “对于每个器官（源器官），它向哪个其他器官（目标器官）传递了自己的哪些变量。然后对于每个源器官，具体哪个变量 传递到了目标器官（对中的第一个符号），以及它在目标器官中被映射为哪个变量（对中的第二个符号）。”</p><p><strong>示例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using PlantSimEngine</code></pre><p>导入示例模型（可在包的 <code>examples</code> 文件夹，或 <code>Examples</code> 子模块中找到）： </p><pre><code class="language-julia-repl hljs">julia&gt; using PlantSimEngine.Examples;</code></pre><pre><code class="language-julia-repl hljs">julia&gt; mapping = Dict( &quot;Plant&quot; =&gt; MultiScaleModel( model=ToyCAllocationModel(), mapped_variables=[ :carbon_assimilation =&gt; [&quot;Leaf&quot;], :carbon_demand =&gt; [&quot;Leaf&quot;, &quot;Internode&quot;], :carbon_allocation =&gt; [&quot;Leaf&quot;, &quot;Internode&quot;] ], ), &quot;Internode&quot; =&gt; ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0), &quot;Leaf&quot; =&gt; ( MultiScaleModel( model=ToyAssimModel(), mapped_variables=[:soil_water_content =&gt; &quot;Soil&quot;,], ), ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0), Status(aPPFD=1300.0, TT=10.0), ), &quot;Soil&quot; =&gt; ( ToySoilWaterModel(), ), );</code></pre><p>注意我们在 <code>Leaf</code> 的 <code>ToyAssimModel</code> 的映射中提供了 &quot;Soil&quot;，而不是 [&quot;Soil&quot;] 。 这是因为预期在这里映射 <code>soil_water_content</code> 的只有一个土壤，因此允许 将该值作为单值获取，而不是一个值向量。</p><pre><code class="language-julia-repl hljs">julia&gt; PlantSimEngine.reverse_mapping(mapping)
Dict{String, Dict{String, Dict{Symbol, Any}}} with 3 entries:
  &quot;Soil&quot;      =&gt; Dict(&quot;Leaf&quot;=&gt;Dict(:soil_water_content=&gt;:soil_water_content))
  &quot;Internode&quot; =&gt; Dict(&quot;Plant&quot;=&gt;Dict(:carbon_allocation=&gt;:carbon_allocation, :ca…
  &quot;Leaf&quot;      =&gt; Dict(&quot;Plant&quot;=&gt;Dict(:carbon_allocation=&gt;:carbon_allocation, :ca…</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/mtg/mapping/reverse_mapping.jl#L1-L47">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.save_results!-Tuple{PlantSimEngine.GraphSimulation, Any}"><a class="docstring-binding" href="#PlantSimEngine.save_results!-Tuple{PlantSimEngine.GraphSimulation, Any}"><code>PlantSimEngine.save_results!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">save_results!(object::GraphSimulation, i)</code></pre><p>将时间步 <code>i</code> 的仿真结果存储到 object 中。 对于 <code>GraphSimulation</code> 对象，此操作会把 <code>status(object)</code> 里的结果写入 <code>outputs(object)</code>。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/mtg/save_results.jl#L243-L248">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.search_inputs_in_multiscale_output-NTuple{6, Any}"><a class="docstring-binding" href="#PlantSimEngine.search_inputs_in_multiscale_output-NTuple{6, Any}"><code>PlantSimEngine.search_inputs_in_multiscale_output</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">search_inputs_in_multiscale_output(process, organ, inputs, soft_dep_graphs)</code></pre><p><strong>参数</strong></p><ul><li><code>process::Symbol</code>: 需要查找其它尺度下软依赖的进程。</li><li><code>organ::String</code>: 需要查找软依赖的器官（层级）。</li><li><code>inputs::Dict{Symbol, Vector{Pair{Symbol}, Tuple{Symbol, Vararg{Symbol}}}}</code>: 一个 dict，进程 =&gt; [:子进程 =&gt; (:var1, :var2)]。</li><li><code>soft_dep_graphs::Dict{String, ...}</code>: 一个 dict，器官 =&gt; (依赖子图, 输入, 输出)。</li><li><code>rev_mapping::Dict{Symbol, Symbol}</code>: 反向映射，映射变量 =&gt; 来源变量。</li><li>&#39;hard<em>dependencies</em>from<em>other</em>scale&#39; : 存储跨层级硬依赖的 HardDependencyNode 向量，便于不遍历整个图时访问</li></ul><p><strong>细节</strong></p><p>输入（输出同理）给出了每个进程的输入，按来源进程分类，来源可以是进程自身或硬依赖的其他进程。</p><p><strong>返回</strong></p><p>每个进程在其他层级下在输出中找到的软依赖变量组成的字典，例如：</p><pre><code class="language-julia hljs">Dict{String, Dict{Symbol, Vector{Symbol}}} with 2 entries:
    &quot;Internode&quot; =&gt; Dict(:carbon_demand=&gt;[:carbon_demand])
    &quot;Leaf&quot;      =&gt; Dict(:carbon_assimilation=&gt;[:carbon_assimilation], :carbon_demand=&gt;[:carbon_demand])</code></pre><p>上述结果表示变量 <code>:carbon_demand</code> 由 &quot;Internode&quot; 层级下的 :carbon<em>demand 过程计算，变量 `:carbon</em>assimilation` 则由 &quot;Leaf&quot; 层级下的 :carbon_assimilation 过程计算。这些变量作为当前进程的输入。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/dependencies/soft_dependencies.jl#L428-L455">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.search_inputs_in_output-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#PlantSimEngine.search_inputs_in_output-Tuple{Any, Any, Any}"><code>PlantSimEngine.search_inputs_in_output</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">search_inputs_in_output(process, inputs, outputs)</code></pre><p>返回依赖图 <code>d</code> 中进程的软依赖组成的字典。 软依赖是指模型中没有显式定义，但可以通过进程的输入输出推断出来的依赖关系。</p><p><strong>参数</strong></p><ul><li><code>process::Symbol</code>: 需要查找软依赖的进程。</li><li><code>inputs::Dict{Symbol, Vector{Pair{Symbol}, Tuple{Symbol, Vararg{Symbol}}}}</code>: 一个 dict，进程对应其输入符号。</li><li><code>outputs::Dict{Symbol, Tuple{Symbol, Vararg{Symbol}}}</code>: 一个 dict，进程对应其输出符号。</li></ul><p><strong>细节</strong></p><p>输入（输出同理）给出了每个进程的输入，按来源进程分类，来源可以是进程自身或硬依赖的其他进程。</p><p><strong>返回</strong></p><p>进程软依赖组成的字典。</p><p><strong>示例</strong></p><pre><code class="language-julia hljs">in_ = Dict(
    :process3 =&gt; [:process3=&gt;(:var4, :var5), :process2=&gt;(:var1, :var3), :process1=&gt;(:var1, :var2)],
    :process4 =&gt; [:process4=&gt;(:var0,)],
    :process6 =&gt; [:process6=&gt;(:var7, :var9)],
    :process5 =&gt; [:process5=&gt;(:var5, :var6)],
)

out_ = Dict(
    :process3 =&gt; Pair{Symbol}[:process3=&gt;(:var4, :var6), :process2=&gt;(:var4, :var5), :process1=&gt;(:var3,)],
    :process4 =&gt; [:process4=&gt;(:var1, :var2)],
    :process6 =&gt; [:process6=&gt;(:var8,)],
    :process5 =&gt; [:process5=&gt;(:var7,)],
)

search_inputs_in_output(:process3, in_, out_)
(process4 = (:var1, :var2),)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/dependencies/soft_dependencies.jl#L351-L391">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.set_variables_at_timestep!-Tuple{Status, Status, Any, Any}"><a class="docstring-binding" href="#PlantSimEngine.set_variables_at_timestep!-Tuple{Status, Status, Any, Any}"><code>PlantSimEngine.set_variables_at_timestep!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">set_variables_at_timestep!(status_timestep::Status, user_status::Status, variables_to_update, timestep)</code></pre><p>将 <code>status_timestep</code> 中所有在 <code>variables_to_update</code> 中的变量，更新为用户提供的 <code>user_status</code> 在指定 <code>timestep</code> 上的当前值。 变量名列表由 <code>variables_to_update</code> 提供，为符号向量。</p><p><code>status_timestep</code> 是表示单次时间步长的状态，<code>user_status</code> 是用户提供的状态，包含未被任何模型计算的变量的值。 其变量值可以为常量，也可以是向量。如果为向量，则用 <code>timestep</code> 指定当前步长所用的值。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/component_models/Status.jl#L145-L154">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.soft_dependencies"><a class="docstring-binding" href="#PlantSimEngine.soft_dependencies"><code>PlantSimEngine.soft_dependencies</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">soft_dependencies(d::DependencyGraph)</code></pre><p>返回一个带有依赖图 <code>d</code> 中进程的软依赖的 <a href="API_private.html#PlantSimEngine.DependencyGraph"><code>DependencyGraph</code></a>。 软依赖是指模型中没有显式定义，但可以通过进程的输入输出推断出来的依赖关系。</p><p><strong>参数</strong></p><ul><li><code>d::DependencyGraph</code>: 硬依赖图。</li></ul><p><strong>示例</strong></p><pre><code class="language-julia hljs">using PlantSimEngine

# 加载包中提供的示例模型：
using PlantSimEngine.Examples

# 创建模型列表：
models = ModelList(
    process1=Process1Model(1.0),
    process2=Process2Model(),
    process3=Process3Model(),
    process4=Process4Model(),
    process5=Process5Model(),
    process6=Process6Model(),
)

# 创建硬依赖图：
hard_dep = hard_dependencies(models.models, verbose=true)

# 获取软依赖图：
soft_dep = soft_dependencies(hard_dep)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/dependencies/soft_dependencies.jl#L1-L35">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.status_from_template-Tuple{Dict{Symbol}}"><a class="docstring-binding" href="#PlantSimEngine.status_from_template-Tuple{Dict{Symbol}}"><code>PlantSimEngine.status_from_template</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">status_from_template(d::Dict{Symbol,Any})</code></pre><p>从变量和值的模板字典创建一个status。如果值本身是RefValue或RefVector，则直接使用，否则会自动转为Ref。</p><p><strong>参数</strong></p><ul><li><code>d::Dict{Symbol,Any}</code>：变量和值的字典。</li></ul><p><strong>返回</strong></p><ul><li>一个<a href="API_public.html#PlantSimEngine.Status"><code>Status</code></a>。</li></ul><p><strong>示例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using PlantSimEngine</code></pre><pre><code class="language-julia-repl hljs">julia&gt; a, b = PlantSimEngine.status_from_template(Dict(:a =&gt; 1.0, :b =&gt; 2.0));</code></pre><pre><code class="language-julia-repl hljs">julia&gt; a
1.0</code></pre><pre><code class="language-julia-repl hljs">julia&gt; b
2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/mtg/initialisation.jl#L165-L197">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.timestep_parallelizable-Tuple{T} where T"><a class="docstring-binding" href="#PlantSimEngine.timestep_parallelizable-Tuple{T} where T"><code>PlantSimEngine.timestep_parallelizable</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">timestep_parallelizable(x::T)
timestep_parallelizable(x::DependencyGraph)</code></pre><p>返回 <code>true</code> 表示模型 <code>x</code> 可以按时间步进行并行计算，否则返回 <code>false</code>。</p><p>默认情况下，所有模型都返回 <code>false</code>。 如果您开发的模型能够按时间步并行，请为您的模型添加 <a href="API_private.html#PlantSimEngine.ObjectDependencyTrait"><code>ObjectDependencyTrait</code></a> 的方法。</p><p>本方法也可直接用于 <a href="API_private.html#PlantSimEngine.DependencyGraph"><code>DependencyGraph</code></a>，若图中所有模型可并行化则返回 <code>true</code>，否则为 <code>false</code>。</p><p><strong>参见</strong></p><ul><li><a href="API_private.html#PlantSimEngine.object_parallelizable-Tuple{T} where T"><code>object_parallelizable</code></a>：判断模型能否按时间步并行。</li><li><a href="API_private.html#PlantSimEngine.parallelizable-Tuple{T} where T"><code>parallelizable</code></a>：判断模型是否可并行化。</li><li><a href="API_private.html#PlantSimEngine.TimeStepDependencyTrait-Tuple{Type}"><code>TimeStepDependencyTrait</code></a>：定义模型对其他时间步的依赖性。</li></ul><p><strong>示例</strong></p><p>定义一个测试过程:</p><pre><code class="language-julia hljs">using PlantSimEngine

# 定义一个测试过程:
@process &quot;TestProcess&quot;</code></pre><p>定义一个时间步独立的模型:</p><pre><code class="language-julia hljs">struct MyModel &lt;: AbstractTestprocessModel end

# 重载时间步依赖 trait:
PlantSimEngine.TimeStepDependencyTrait(::Type{MyModel}) = IsTimeStepIndependent()</code></pre><p>检查模型能否按对象并行:</p><pre><code class="language-julia hljs">timestep_parallelizable(MyModel()) # true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/traits/parallel_traits.jl#L81-L122">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.transform_single_node_mapped_variables_as_self_node_output!-Tuple{Any}"><a class="docstring-binding" href="#PlantSimEngine.transform_single_node_mapped_variables_as_self_node_output!-Tuple{Any}"><code>PlantSimEngine.transform_single_node_mapped_variables_as_self_node_output!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">transform_single_node_mapped_variables_as_self_node_output!(mapped_vars)</code></pre><p>查找作为<code>SingleNodeMapping</code>输入到其他尺度的变量，并以自身为源在源尺度声明为MappedVar。 这样有助于我们在创建模板status对象时以引用方式声明。</p><p>这些节点表现为<code>[:variable_name =&gt; &quot;Plant&quot;]</code>的写法（注意&quot;Plant&quot;为标量）。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/mtg/mapping/compute_mapping.jl#L150-L157">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.traverse_dependency_graph!-Tuple{PlantSimEngine.HardDependencyNode, Function, Vector}"><a class="docstring-binding" href="#PlantSimEngine.traverse_dependency_graph!-Tuple{PlantSimEngine.HardDependencyNode, Function, Vector}"><code>PlantSimEngine.traverse_dependency_graph!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">traverse_dependency_graph(node::HardDependencyNode, f::Function, var::Vector)</code></pre><p>对 <code>node</code> 应用函数 <code>f</code>，然后遍历其子节点（硬依赖节点）。</p><p>通过将节点的进程名和函数 <code>f</code> 的结果组成的对推入向量 <code>var</code>，以实现对 <code>var</code> 的累加。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/dependencies/traversal.jl#L146-L152">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.traverse_dependency_graph!-Tuple{PlantSimEngine.SoftDependencyNode, Function, Vector}"><a class="docstring-binding" href="#PlantSimEngine.traverse_dependency_graph!-Tuple{PlantSimEngine.SoftDependencyNode, Function, Vector}"><code>PlantSimEngine.traverse_dependency_graph!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">traverse_dependency_graph(node::SoftDependencyNode, f::Function, var::Vector; visit_hard_dep=true)</code></pre><p>对 <code>node</code> 应用函数 <code>f</code>，遍历其硬依赖节点（当 <code>visit_hard_dep=true</code> 时），然后遍历其软依赖的子节点。</p><p>通过将节点的进程名和函数 <code>f</code> 的结果组成的对推入向量 <code>var</code>，以实现对 <code>var</code> 的累加。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/dependencies/traversal.jl#L111-L117">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.traverse_dependency_graph-Tuple{PlantSimEngine.DependencyGraph, Function}"><a class="docstring-binding" href="#PlantSimEngine.traverse_dependency_graph-Tuple{PlantSimEngine.DependencyGraph, Function}"><code>PlantSimEngine.traverse_dependency_graph</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">traverse_dependency_graph(graph::DependencyGraph, f::Function; visit_hard_dep=true)
traverse_dependency_graph(graph; visit_hard_dep=true)</code></pre><p>遍历依赖 <code>graph</code>，并对每个节点应用函数 <code>f</code>。如果未提供 <code>f</code>，则仅返回节点本身。</p><p>首先遍历第一层软依赖节点，然后遍历它们的硬依赖节点（如果 <code>visit_hard_dep=true</code>），最后遍历软依赖节点的子节点。</p><p>返回一个由节点与函数 <code>f</code> 结果组成的元组对的向量。</p><p><strong>示例</strong></p><pre><code class="language-julia hljs">using PlantSimEngine

# 包含示例进程和模型:
using PlantSimEngine.Examples;

function f(node)
    node.value
end

vars = (
    process1=Process1Model(1.0),
    process2=Process2Model(),
    process3=Process3Model(),
    process4=Process4Model(),
    process5=Process5Model(),
    process6=Process6Model(),
    process7=Process7Model(),
)

graph = dep(vars)
traverse_dependency_graph(graph, f)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/dependencies/traversal.jl#L1-L36">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.variables_multiscale"><a class="docstring-binding" href="#PlantSimEngine.variables_multiscale"><code>PlantSimEngine.variables_multiscale</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">variables_multiscale(node, organ, mapping, st=NamedTuple())</code></pre><p>获取 HardDependencyNode 的变量，考虑多尺度映射，也就是说， 如果变量被映射到了另一个尺度，则定义为 <code>MappedVar</code>。默认值 取自模型本身，如果用户未指定（<code>st</code>），且如果为节点的输入变量，则 用 <code>UninitializedVar</code> 标记。</p><p>返回一个包含变量及其默认值的 NamedTuple。</p><p><strong>参数</strong></p><ul><li><code>node::HardDependencyNode</code>：需要获取变量的节点。</li><li><code>organ::String</code>：器官类型，如 &quot;Leaf&quot;。</li><li><code>vars_mapping::Dict{String,T}</code>：模型的映射（详见下方）。</li><li><code>st::NamedTuple</code>：可选，包含变量默认值的 NamedTuple。</li></ul><p><strong>详情</strong></p><p><code>vars_mapping</code> 是一个以器官类型为 key、以字典为 value 的字典。 它由用户映射计算得到：</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/dependencies/dependency_graph.jl#L82-L103">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.variables_outputs_from_other_scale-Tuple{Any}"><a class="docstring-binding" href="#PlantSimEngine.variables_outputs_from_other_scale-Tuple{Any}"><code>PlantSimEngine.variables_outputs_from_other_scale</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">variables_outputs_from_other_scale(mapped_vars)</code></pre><p>对于<code>mapped_vars</code>中的每个器官，查找那些仅为其他尺度输出、而本尺度未计算的变量。 该函数用于mapped_variables。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/mtg/mapping/compute_mapping.jl#L61-L66">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.variables_typed-Tuple{T} where T&lt;:AbstractModel"><a class="docstring-binding" href="#PlantSimEngine.variables_typed-Tuple{T} where T&lt;:AbstractModel"><code>PlantSimEngine.variables_typed</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">variables_typed(model)
variables_typed(model, models...)</code></pre><p>返回模型所需变量（变量名及类型）的具名元组，或多个模型的变量类型联合。</p><p><strong>示例</strong></p><pre><code class="language-julia hljs">using PlantSimEngine;

# Load the dummy models given as example in the package:
using PlantSimEngine.Examples;

PlantSimEngine.variables_typed(Process1Model(1.0))
(var1 = Float64, var2 = Float64, var3 = Float64)

PlantSimEngine.variables_typed(Process1Model(1.0), Process2Model())

# output
(var4 = Float64, var5 = Float64, var1 = Float64, var2 = Float64, var3 = Float64)</code></pre><p><strong>参见</strong></p><p><a href="API_public.html#PlantSimEngine.inputs-Tuple{T} where T&lt;:AbstractModel"><code>inputs</code></a>, <a href="API_public.html#PlantSimEngine.outputs-Tuple{T} where T&lt;:AbstractModel"><code>outputs</code></a> and <a href="API_public.html#PlantSimEngine.variables-Tuple{Module}"><code>variables</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/processes/models_inputs_outputs.jl#L190-L217">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.vars_not_init_-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Status"><a class="docstring-binding" href="#PlantSimEngine.vars_not_init_-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Status"><code>PlantSimEngine.vars_not_init_</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vars_not_init_(st&lt;:Status, var_names)</code></pre><p>获取状态结构体中尚未正确初始化的变量。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/processes/model_initialisation.jl#L316-L320">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="API_examples.html">« 示例模型</a><a class="docs-footer-nextpage" href="../documentation_improvement.html">改进文档 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Saturday 10 January 2026 19:42">Saturday 10 January 2026</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
