<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>公共 API · PlantSimEngine.jl</title><meta name="title" content="公共 API · PlantSimEngine.jl"/><meta property="og:title" content="公共 API · PlantSimEngine.jl"/><meta property="twitter:title" content="公共 API · PlantSimEngine.jl"/><meta name="description" content="Documentation for PlantSimEngine.jl."/><meta property="og:description" content="Documentation for PlantSimEngine.jl."/><meta property="twitter:description" content="Documentation for PlantSimEngine.jl."/><meta property="og:url" content="https://VirtualPlantLab.github.io/PlantSimEngine.jl/API\\API_public.html"/><meta property="twitter:url" content="https://VirtualPlantLab.github.io/PlantSimEngine.jl/API\\API_public.html"/><link rel="canonical" href="https://VirtualPlantLab.github.io/PlantSimEngine.jl/API\\API_public.html"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">PlantSimEngine.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">首页</a></li><li><span class="tocitem">简介</span><ul><li><a class="tocitem" href="../introduction/why_plantsimengine.html">为什么选择 PlantSimEngine？</a></li><li><a class="tocitem" href="../introduction/why_julia.html">为什么选择 Julia？</a></li></ul></li><li><span class="tocitem">前置条件</span><ul><li><a class="tocitem" href="../prerequisites/installing_plantsimengine.html">PlantSimEngine 的安装与运行</a></li><li><a class="tocitem" href="../prerequisites/key_concepts.html">关键概念</a></li><li><a class="tocitem" href="../prerequisites/julia_basics.html">Julia 语言基础</a></li></ul></li><li><span class="tocitem">分步教程 - 单尺度模拟</span><ul><li><a class="tocitem" href="../step_by_step/detailed_first_example.html">详细的第一个模拟</a></li><li><a class="tocitem" href="../step_by_step/simple_model_coupling.html">模型耦合</a></li><li><a class="tocitem" href="../step_by_step/model_switching.html">模型切换</a></li><li><a class="tocitem" href="../step_by_step/quick_and_dirty_examples.html">快速示例</a></li><li><a class="tocitem" href="../step_by_step/implement_a_process.html">实现一个过程</a></li><li><a class="tocitem" href="../step_by_step/implement_a_model.html">实现一个模型</a></li><li><a class="tocitem" href="../step_by_step/parallelization.html">并行化</a></li><li><a class="tocitem" href="../step_by_step/advanced_coupling.html">高级耦合与硬依赖</a></li><li><a class="tocitem" href="../step_by_step/implement_a_model_additional.html">实现一个模型：补充说明</a></li></ul></li><li><a class="tocitem" href="../model_execution.html">模型执行</a></li><li><span class="tocitem">数据处理</span><ul><li><a class="tocitem" href="../working_with_data/reducing_dof.html">降低自由度</a></li><li><a class="tocitem" href="../working_with_data/fitting.html">拟合</a></li><li><a class="tocitem" href="../working_with_data/inputs.html">输入类型</a></li><li><a class="tocitem" href="../working_with_data/visualising_outputs.html">可视化输出与数据</a></li><li><a class="tocitem" href="../working_with_data/floating_point_accumulation_error.html">浮点运算注意事项</a></li></ul></li><li><span class="tocitem">多尺度建模</span><ul><li><a class="tocitem" href="../multiscale/multiscale_considerations.html">多尺度建模考量</a></li><li><a class="tocitem" href="../multiscale/single_to_multiscale.html">单尺度模型转换为多尺度</a></li><li><a class="tocitem" href="../multiscale/multiscale.html">更多变量映射示例</a></li><li><a class="tocitem" href="../multiscale/multiscale_cyclic.html">循环依赖的处理</a></li><li><a class="tocitem" href="../multiscale/multiscale_coupling.html">多尺度耦合相关说明</a></li><li><input class="collapse-toggle" id="menuitem-7-6" type="checkbox"/><label class="tocitem" for="menuitem-7-6"><span class="docs-label">构建简单植株</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../multiscale/multiscale_example_1.html">简单植株模拟</a></li><li><a class="tocitem" href="../multiscale/multiscale_example_2.html">拓展植株模拟</a></li><li><a class="tocitem" href="../multiscale/multiscale_example_3.html">修复植株模拟中的错误</a></li></ul></li><li><a class="tocitem" href="../multiscale/multiscale_example_4.html">用 PlantGeom 可视化玩具植株</a></li></ul></li><li><span class="tocitem">故障排查与测试</span><ul><li><a class="tocitem" href="../troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting.html">故障排查</a></li><li><a class="tocitem" href="../troubleshooting_and_testing/downstream_tests.html">自动化测试</a></li><li><a class="tocitem" href="../troubleshooting_and_testing/tips_and_workarounds.html">技巧与常见问题</a></li><li><a class="tocitem" href="../troubleshooting_and_testing/implicit_contracts.html">隐性约定</a></li></ul></li><li><span class="tocitem">API</span><ul><li class="is-active"><a class="tocitem" href="API_public.html">公共 API</a><ul class="internal"><li><a class="tocitem" href="#索引"><span>索引</span></a></li><li><a class="tocitem" href="#API-文档"><span>API 文档</span></a></li></ul></li><li><a class="tocitem" href="API_examples.html">示例模型</a></li><li><a class="tocitem" href="API_private.html">内部 API</a></li></ul></li><li><a class="tocitem" href="../documentation_improvement.html">改进文档</a></li><li><a class="tocitem" href="../developers.html">开发者指南</a></li><li><a class="tocitem" href="../planned_features.html">规划功能</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href="API_public.html">公共 API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="API_public.html">公共 API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/main/docs - 中文/src/API/API_public.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="公共-API"><a class="docs-heading-anchor" href="#公共-API">公共 API</a><a id="公共-API-1"></a><a class="docs-heading-anchor-permalink" href="#公共-API" title="Permalink"></a></h1><h2 id="索引"><a class="docs-heading-anchor" href="#索引">索引</a><a id="索引-1"></a><a class="docs-heading-anchor-permalink" href="#索引" title="Permalink"></a></h2><ul><li><a href="API_public.html#PlantMeteo.TimeStepTable-Union{Tuple{DataFrame}, Tuple{Status}, Tuple{DataFrame, Any}} where Status"><code>PlantMeteo.TimeStepTable</code></a></li><li><a href="API_public.html#PlantSimEngine.AbstractModel"><code>PlantSimEngine.AbstractModel</code></a></li><li><a href="API_public.html#PlantSimEngine.ModelList"><code>PlantSimEngine.ModelList</code></a></li><li><a href="API_public.html#PlantSimEngine.MultiScaleModel"><code>PlantSimEngine.MultiScaleModel</code></a></li><li><a href="API_public.html#PlantSimEngine.PreviousTimeStep"><code>PlantSimEngine.PreviousTimeStep</code></a></li><li><a href="API_public.html#PlantSimEngine.Status"><code>PlantSimEngine.Status</code></a></li><li><a href="API_public.html#PlantSimEngine.EF-Tuple{Any, Any}"><code>PlantSimEngine.EF</code></a></li><li><a href="API_public.html#PlantSimEngine.NRMSE-Tuple{Any, Any}"><code>PlantSimEngine.NRMSE</code></a></li><li><a href="API_public.html#PlantSimEngine.RMSE-Tuple{Any, Any}"><code>PlantSimEngine.RMSE</code></a></li><li><a href="API_public.html#PlantSimEngine.add_organ!-Tuple{MultiScaleTreeGraph.Node, Vararg{Any, 4}}"><code>PlantSimEngine.add_organ!</code></a></li><li><a href="API_public.html#PlantSimEngine.dep"><code>PlantSimEngine.dep</code></a></li><li><a href="API_public.html#PlantSimEngine.dr-Tuple{Any, Any}"><code>PlantSimEngine.dr</code></a></li><li><a href="API_public.html#PlantSimEngine.fit"><code>PlantSimEngine.fit</code></a></li><li><a href="API_public.html#PlantSimEngine.init_status!-Tuple{Dict{String, ModelList}}"><code>PlantSimEngine.init_status!</code></a></li><li><a href="API_public.html#PlantSimEngine.init_variables-Tuple{T} where T&lt;:AbstractModel"><code>PlantSimEngine.init_variables</code></a></li><li><a href="API_public.html#PlantSimEngine.inputs-Union{Tuple{Dict{String, T}}, Tuple{T}} where T"><code>PlantSimEngine.inputs</code></a></li><li><a href="API_public.html#PlantSimEngine.inputs-Tuple{T} where T&lt;:AbstractModel"><code>PlantSimEngine.inputs</code></a></li><li><a href="API_public.html#PlantSimEngine.is_initialized-Tuple{T} where T&lt;:ModelList"><code>PlantSimEngine.is_initialized</code></a></li><li><a href="API_public.html#PlantSimEngine.outputs-Tuple{T} where T&lt;:AbstractModel"><code>PlantSimEngine.outputs</code></a></li><li><a href="API_public.html#PlantSimEngine.outputs-Union{Tuple{Dict{String, T}}, Tuple{T}} where T"><code>PlantSimEngine.outputs</code></a></li><li><a href="API_public.html#PlantSimEngine.run!"><code>PlantSimEngine.run!</code></a></li><li><a href="API_public.html#PlantSimEngine.status-Tuple{Any}"><code>PlantSimEngine.status</code></a></li><li><a href="API_public.html#PlantSimEngine.to_initialize-Tuple{ModelList}"><code>PlantSimEngine.to_initialize</code></a></li><li><a href="API_public.html#PlantSimEngine.variables-Tuple{Module}"><code>PlantSimEngine.variables</code></a></li><li><a href="API_public.html#PlantSimEngine.variables-Union{Tuple{T}, Tuple{T, Vararg{Any}}} where T&lt;:Union{Missing, AbstractModel}"><code>PlantSimEngine.variables</code></a></li><li><a href="API_public.html#PlantSimEngine.variables-Union{Tuple{Dict{String, T}}, Tuple{T}} where T"><code>PlantSimEngine.variables</code></a></li><li><a href="API_public.html#PlantSimEngine.@process-Tuple{Any, Vararg{Any}}"><code>PlantSimEngine.@process</code></a></li></ul><h2 id="API-文档"><a class="docs-heading-anchor" href="#API-文档">API 文档</a><a id="API-文档-1"></a><a class="docs-heading-anchor-permalink" href="#API-文档" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PlantMeteo.TimeStepTable-Union{Tuple{DataFrame}, Tuple{Status}, Tuple{DataFrame, Any}} where Status"><a class="docstring-binding" href="#PlantMeteo.TimeStepTable-Union{Tuple{DataFrame}, Tuple{Status}, Tuple{DataFrame, Any}} where Status"><code>PlantMeteo.TimeStepTable</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">TimeStepTable{Status}(df::DataFrame)</code></pre><p>方法：从 <code>DataFrame</code> 构建 <code>TimeStepTable</code>（来自 <a href="https://palmstudio.github.io/PlantMeteo.jl/stable/">PlantMeteo.jl</a>），但每一行都是 <code>Status</code>。</p><p><strong>注意</strong></p><p><a href="../step_by_step/simple_model_coupling.html#ModelList"><code>ModelList</code></a> 默认使用 <code>TimeStepTable{Status}</code>（见下面的示例）。</p><p><strong>示例</strong></p><pre><code class="language-julia hljs">using PlantSimEngine, DataFrames

# 从 DataFrame 创建一个 TimeStepTable：
df = DataFrame(
    Tₗ=[25.0, 26.0],
    aPPFD=[1000.0, 1200.0],
    Cₛ=[400.0, 400.0],
    Dₗ=[1.0, 1.2],
)
TimeStepTable{Status}(df)

# 只要其中一个变量有多个值，叶片会自动用带时间步的 TimeStepTable{Status}：
models = ModelList(
    process1=Process1Model(1.0),
    process2=Process2Model(),
    process3=Process3Model(),
    status=(var1=15.0, var2=0.3)
)

# 叶片的 status 是一个 TimeStepTable：
status(models)

# 当然也可以手动用 Status 创建 TimeStepTable：
TimeStepTable(
    [
        Status(Tₗ=25.0, aPPFD=1000.0, Cₛ=400.0, Dₗ=1.0),
        Status(Tₗ=26.0, aPPFD=1200.0, Cₛ=400.0, Dₗ=1.2),
    ]
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/component_models/TimeStepTable.jl#L2-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.AbstractModel"><a class="docstring-binding" href="#PlantSimEngine.AbstractModel"><code>PlantSimEngine.AbstractModel</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>抽象模型类型。所有模型都是此类型的子类型。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/Abstract_model_structs.jl#L1-L3">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.ModelList"><a class="docstring-binding" href="#PlantSimEngine.ModelList"><code>PlantSimEngine.ModelList</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ModelList(models::M, status::S)
ModelList(;
    status=nothing,
    type_promotion=nothing,
    variables_check=true,
    kwargs...
)</code></pre><p>列举用于模拟的一组模型 (<code>models</code>)，并自动完成变量初始化、类型提升、时间步长处理等样板工作。</p><div class="admonition is-info" id="Note-fca7e9dea56e4cdb"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-fca7e9dea56e4cdb" title="Permalink"></a></header><div class="admonition-body"><p><code>status</code> 字段取决于输入的模型。你可以通过已实例化模型上的 <a href="API_public.html#PlantSimEngine.variables-Tuple{Module}"><code>variables</code></a> 方法获取模型所需变量，也可以使用 <a href="API_public.html#PlantSimEngine.inputs-Tuple{T} where T&lt;:AbstractModel"><code>inputs</code></a> 和 <a href="API_public.html#PlantSimEngine.outputs-Tuple{T} where T&lt;:AbstractModel"><code>outputs</code></a>。</p></div></div><p><strong>参数说明</strong></p><ul><li><code>models</code>: 一个模型的列表。通常采用 <code>NamedTuple</code>，但也可以是实现了 <code>getproperty</code> 的其他结构。</li><li><code>status</code>: 包含模型变量初始化的结构体。作为关键字参数时通常为 NamedTuple，或为实现了 <code>Tables.jl</code> 接口的任何结构体（如 DataFrame，详见下文）。</li><li><code>type_promotion</code>: 可选，用于默认值变量的类型转换。默认为 <code>nothing</code>（即不转换）。注意，用户以 <code>kwargs</code> 提供的变量不会自动转换（需要手动转换）。需提供以当前类型为键、新类型为值的 Dict。</li><li><code>variables_check=true</code>: 检查用户是否初始化了所有必需变量。</li><li><code>kwargs</code>: 各过程名称对应的模型。</li></ul><p><strong>细节</strong></p><p>如果你需要自定义 <code>status</code> 的类型，并希望用户能够只初始化部分字段，则必须为 <code>add_model_vars!</code> 实现一个方法，以在类型未完全初始化时添加模型变量。默认方法兼容任何实现了 <code>Tables.jl</code> 接口的类型（如 DataFrame），以及 <code>NamedTuples</code>。</p><p>注意，如果输入 <code>status</code> 未涵盖所有变量，<code>ModelList</code> 会对其进行复制。</p><p><strong>示例</strong></p><p>以下示例采用包中 <code>examples/dummy.jl</code> 的示例模型。其实现了三个虚拟过程：<code>Process1Model</code>、<code>Process2Model</code> 和 <code>Process3Model</code>，且每个过程有一个模型实现。</p><pre><code class="language-julia-repl hljs">julia&gt; using PlantSimEngine;</code></pre><p>包含示例过程和模型：</p><pre><code class="language-julia-repl hljs">julia&gt; using PlantSimEngine.Examples;</code></pre><pre><code class="language-julia-repl hljs">julia&gt; models = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model());
[ Info: Some variables must be initialized before simulation: (process1 = (:var1, :var2), process2 = (:var1,)) (see `to_initialize()`)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; typeof(models)
ModelList{@NamedTuple{process1::Process1Model, process2::Process2Model, process3::Process3Model}, Status{(:var5, :var4, :var6, :var1, :var3, :var2), NTuple{6, Base.RefValue{Float64}}}}</code></pre><p>未以关键字参数提供变量，意味着 ModelList 的 status 尚未设置，所有变量将按 inputs 和 outputs 中的默认值初始化（通常是 <code>typemin(Type)</code>，比如浮点数则为 <code>-Inf</code>）。此时组件尚不可模拟。</p><p>模拟前需初始化哪些变量，可通过 <a href="API_public.html#PlantSimEngine.to_initialize-Tuple{ModelList}"><code>to_initialize</code></a> 方法查询：</p><pre><code class="language-julia-repl hljs">julia&gt; to_initialize(models)
(process1 = (:var1, :var2), process2 = (:var1,))</code></pre><p>我们现在可以在 <code>status</code> 字段中为这些变量赋值，并对 ModelList 进行模拟。例如针对 <code>process3</code>（与 process1 和 process2 耦合）：</p><pre><code class="language-julia-repl hljs">julia&gt; models = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model(), status=(var1=15.0, var2=0.3));</code></pre><pre><code class="language-julia-repl hljs">julia&gt; meteo = Atmosphere(T = 22.0, Wind = 0.8333, P = 101.325, Rh = 0.4490995);</code></pre><pre><code class="language-julia-repl hljs">julia&gt; outputs_sim = run!(models,meteo)
TimeStepTable{Status{(:var5, :var4, :var6, ...}(1 x 6):
╭─────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────╮
│ Row │    var5 │    var4 │    var6 │    var1 │    var3 │    var2 │
│     │ Float64 │ Float64 │ Float64 │ Float64 │ Float64 │ Float64 │
├─────┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────┤
│   1 │ 36.0139 │    22.0 │ 58.0139 │    15.0 │     5.5 │     0.3 │
╰─────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────╯</code></pre><pre><code class="language-julia-repl hljs">julia&gt; outputs_sim[:var6]
1-element Vector{Float64}:
 58.0138985</code></pre><p>如需对变量使用特殊类型，可使用 <code>type_promotion</code> 参数：</p><pre><code class="language-julia-repl hljs">julia&gt; models = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model(), status=(var1=15.0, var2=0.3), type_promotion = Dict(Float64 =&gt; Float32));</code></pre><p>我们使用 <code>type_promotion</code> 将 status 强制转换为 Float32：</p><pre><code class="language-julia-repl hljs">julia&gt; [typeof(models[i][1]) for i in keys(status(models))]
6-element Vector{DataType}:
 Float32
 Float32
 Float32
 Float64
 Float64
 Float32</code></pre><p>可以看到，只有默认变量（未在 status 参数中给定的变量）被转换为 Float32，其余两个用户提供的变量未被转换。这样做是为了让用户可以为 status 中赋值的变量指定任意类型。如需全部变量都转为 Float32，可直接以 Float32 赋值：</p><pre><code class="language-julia-repl hljs">julia&gt; models = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model(), status=(var1=15.0f0, var2=0.3f0), type_promotion = Dict(Float64 =&gt; Float32));</code></pre><p>我们使用 <code>type_promotion</code> 将 status 强制转换为 Float32：</p><pre><code class="language-julia-repl hljs">julia&gt; [typeof(models[i][1]) for i in keys(status(models))]
6-element Vector{DataType}:
 Float32
 Float32
 Float32
 Float32
 Float32
 Float32</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/component_models/ModelList.jl#L2-L127">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.MultiScaleModel"><a class="docstring-binding" href="#PlantSimEngine.MultiScaleModel"><code>PlantSimEngine.MultiScaleModel</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MultiScaleModel(model, mapped_variables)</code></pre><p>一个用于实现多尺度模型的结构体。它定义了模型变量与节点标记之间的映射，变量值将从这些节点获取。</p><p><strong>参数</strong></p><ul><li><code>model&lt;:AbstractModel</code>：待多尺度化的模型</li><li><code>mapped_variables&lt;:Vector{Pair{Symbol,Union{AbstractString,Vector{AbstractString}}}}</code>：由符号和字符串（或字符串向量）组成的配对向量</li></ul><p>mapped_variables 参数可以有以下形式：</p><ol><li><code>[:variable_name =&gt; &quot;Plant&quot;]</code>：从 Plant 节点获取单个值</li><li><code>[:variable_name =&gt; [&quot;Leaf&quot;]]</code>：从所有 Leaf 节点获取一个值向量</li><li><code>[:variable_name =&gt; [&quot;Leaf&quot;, &quot;Internode&quot;]]</code>：从 Leaf 和 Internode 节点获取一个值向量</li><li><code>[:variable_name =&gt; &quot;Plant&quot; =&gt; :variable_name_in_plant_scale]</code>：从 Plant 节点以指定变量名获取值</li><li><code>[:variable_name =&gt; [&quot;Leaf&quot; =&gt; :variable_name_1, &quot;Internode&quot; =&gt; :variable_name_2]]</code>：从 Leaf 和 Internode 节点分别以不同变量名获取值，返回一个向量</li><li><code>[PreviousTimeStep(:variable_name) =&gt; ...]</code>：标记变量用前一时间步的值初始化，该变量不参与依赖图的构建</li><li><code>[:variable_name =&gt; :variable_name_from_another_model]</code>：从相同尺度的其它模型变量获取数据，并重命名</li><li><code>[PreviousTimeStep(:variable_name),]</code>：纯粹标记为 PreviousTimeStep，不参与依赖图构建</li></ol><p>不同形式的详细说明：</p><ol><li><p>模型的 <code>variable_name</code> 变量将从 <code>Plant</code> 节点获取，假设只有一个节点是 <code>Plant</code>。此时 status 里该值是标量，因此用户需确保 MTG 中只有一个 Plant 类型节点。</p></li><li><p>模型的 <code>variable_name</code> 变量将从所有 <code>Leaf</code> 节点获取。注意此处为向量，模型需能处理值向量。即使只有一个 Leaf 节点，取到的依然是只有一个元素的向量。</p></li><li><p>模型的 <code>variable_name</code> 变量将从所有 <code>Leaf</code> 和 <code>Internode</code> 节点获取。即取所有这两类节点的值向量。</p></li><li><p>模型的 <code>variable_name</code> 变量将从 Plant 节点中的 <code>variable_name_in_plant_scale</code> 变量获取。当模型变量名与节点变量名不同时可用。</p></li><li><p>模型的 <code>variable_name</code> 变量将分别从 Leaf 节点的 <code>variable_name_1</code> 及 Internode 节点的 <code>variable_name_2</code> 取得。</p></li><li><p>模型的 <code>variable_name</code> 变量使用上一步计算结果，不用于构建当前步依赖图。可用于变量依赖自身时避免循环依赖。需要时可在 Status 初始化其值。</p></li><li><p>模型的 <code>variable_name</code> 变量从同一尺度但不同变量名的其它模型获取。</p></li><li><p>模型的 <code>variable_name</code> 变量仅作 PreviousTimeStep 标记，不参与依赖图的构建。</p></li></ol><p>请注意，该映射不会复制变量值，仅引用。当某一节点的 status 被更新，其他节点引用的值也随之改变。</p><p><strong>示例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using PlantSimEngine;</code></pre><p>包含示例过程和模型：</p><pre><code class="language-julia-repl hljs">julia&gt; using PlantSimEngine.Examples;</code></pre><p>取一个模型示例：</p><pre><code class="language-julia-repl hljs">julia&gt; model = ToyCAllocationModel()
ToyCAllocationModel()</code></pre><p>我们通过定义模型变量和节点标记之间的映射，将其转为多尺度模型。</p><p>例如，假设 <code>carbon_allocation</code> 来源于 <code>Leaf</code> 和 <code>Internode</code> 节点，可以定义映射如下：</p><pre><code class="language-julia-repl hljs">julia&gt; mapped_variables=[:carbon_allocation =&gt; [&quot;Leaf&quot;, &quot;Internode&quot;]]
1-element Vector{Pair{Symbol, Vector{String}}}:
 :carbon_allocation =&gt; [&quot;Leaf&quot;, &quot;Internode&quot;]</code></pre><p>mapped<em>variables 参数是符号和字符串（或字符串向量）的配对向量。以上例只有一对，表示将 `carbon</em>allocation<code>变量与</code>Leaf<code>和</code>Internode` 关联。</p><p>现在将模型及变量映射传递给 <code>MultiScaleModel</code> 构造函数，实现多尺度模型：</p><pre><code class="language-julia-repl hljs">julia&gt; multiscale_model = PlantSimEngine.MultiScaleModel(model, mapped_variables)
MultiScaleModel{ToyCAllocationModel, Vector{Pair{Union{Symbol, PreviousTimeStep}, Union{Pair{String, Symbol}, Vector{Pair{String, Symbol}}}}}}(ToyCAllocationModel(), Pair{Union{Symbol, PreviousTimeStep}, Union{Pair{String, Symbol}, Vector{Pair{String, Symbol}}}}[:carbon_allocation =&gt; [&quot;Leaf&quot; =&gt; :carbon_allocation, &quot;Internode&quot; =&gt; :carbon_allocation]])</code></pre><p>可访问映射变量和模型：</p><pre><code class="language-julia-repl hljs">julia&gt; PlantSimEngine.mapped_variables_(multiscale_model)
1-element Vector{Pair{Union{Symbol, PreviousTimeStep}, Union{Pair{String, Symbol}, Vector{Pair{String, Symbol}}}}}:
 :carbon_allocation =&gt; [&quot;Leaf&quot; =&gt; :carbon_allocation, &quot;Internode&quot; =&gt; :carbon_allocation]</code></pre><pre><code class="language-julia-repl hljs">julia&gt; PlantSimEngine.model_(multiscale_model)
ToyCAllocationModel()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/mtg/MultiScaleModel.jl#L1-L92">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.PreviousTimeStep"><a class="docstring-binding" href="#PlantSimEngine.PreviousTimeStep"><code>PlantSimEngine.PreviousTimeStep</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PreviousTimeStep(variable)</code></pre><p>用于手动标记模型中某变量以采用上一个时间步中计算的值的结构体。 这意味着该变量不会被用于构建依赖关系图，因为依赖关系图仅适用于当前时间步。 当变量依赖于自身时，为了避免循环依赖，可以使用该方法。 如有需要，其值可以在 Status 中初始化。</p><p>当构建 MultiScaleModel 时会添加该过程，以避免不同进程之间具有相同变量名时的冲突。 例如，一个进程可以将变量 <code>:carbon_biomass</code> 定义为 <code>PreviousTimeStep</code>，而另一个进程则将该变量作为当前时间步的依赖项使用（这样是允许的，因为它们不会出现循环依赖的问题）。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/variables_wrappers.jl#L15-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.Status"><a class="docstring-binding" href="#PlantSimEngine.Status"><code>PlantSimEngine.Status</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Status(vars)</code></pre><p>Status类型用于在模拟过程中存储变量的值。主要用作<code>TimeStepTable</code>的<code>TimeStepRow</code>中用于保存变量的结构体（参见<a href="https://palmstudio.github.io/PlantMeteo.jl/stable/"><code>PlantMeteo.jl</code> 文档</a>），也用于<a href="../step_by_step/simple_model_coupling.html#ModelList"><code>ModelList</code></a>。</p><p>大部分代码来自 MasonProtter/MutableNamedTuples.jl，因此<code>Status</code>本质上是一个经过少量修改的MutableNamedTuples， 也就是一个用来存储对变量值的引用的<code>NamedTuple</code>结构体，使其为可变类型。</p><p><strong>示例</strong></p><p>所有变量只有一个值的叶片将得到一个只有一个时间步长的状态对象：</p><pre><code class="language-julia-repl hljs">julia&gt; using PlantSimEngine</code></pre><pre><code class="language-julia-repl hljs">julia&gt; st = PlantSimEngine.Status(Ra_SW_f=13.747, sky_fraction=1.0, d=0.03, aPPFD=1500.0);</code></pre><p>以下索引方法均可用：</p><pre><code class="language-julia-repl hljs">julia&gt; st[:Ra_SW_f]
13.747</code></pre><pre><code class="language-julia-repl hljs">julia&gt; st.Ra_SW_f
13.747</code></pre><pre><code class="language-julia-repl hljs">julia&gt; st[1]
13.747</code></pre><p>设置 Status 变量也很简单：</p><pre><code class="language-julia-repl hljs">julia&gt; st[:Ra_SW_f] = 20.0
20.0</code></pre><pre><code class="language-julia-repl hljs">julia&gt; st.Ra_SW_f = 21.0
21.0</code></pre><pre><code class="language-julia-repl hljs">julia&gt; st[1] = 22.0
22.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/component_models/Status.jl#L1-L54">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.EF-Tuple{Any, Any}"><a class="docstring-binding" href="#PlantSimEngine.EF-Tuple{Any, Any}"><code>PlantSimEngine.EF</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">EF(obs,sim)</code></pre><p>使用NSE（Nash-Sutcliffe效率）模型，返回观测值 <code>obs</code> 和模拟值 <code>sim</code> 之间的效率系数（Efficiency Factor）。 更多信息见 https://en.wikipedia.org/wiki/Nash%E2%80%93Sutcliffe<em>model</em>efficiency_coefficient 。</p><p>值越接近1越好。</p><p><strong>示例</strong></p><pre><code class="language- hljs">using PlantSimEngine

obs = [1.0, 2.0, 3.0]
sim = [1.1, 2.1, 3.1]

EF(obs, sim)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/evaluation/statistics.jl#L45-L63">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.NRMSE-Tuple{Any, Any}"><a class="docstring-binding" href="#PlantSimEngine.NRMSE-Tuple{Any, Any}"><code>PlantSimEngine.NRMSE</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">NRMSE(obs,sim)</code></pre><p>返回观测值 <code>obs</code> 和模拟值 <code>sim</code> 之间的归一化均方根误差（Normalized Root Mean Squared Error）。 归一化方法是除以观测值的范围（最大值-最小值）。</p><p><strong>示例</strong></p><pre><code class="language- hljs">using PlantSimEngine

obs = [1.0, 2.0, 3.0]
sim = [1.1, 2.1, 3.1]

NRMSE(obs, sim)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/evaluation/statistics.jl#L24-L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.RMSE-Tuple{Any, Any}"><a class="docstring-binding" href="#PlantSimEngine.RMSE-Tuple{Any, Any}"><code>PlantSimEngine.RMSE</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">RMSE(obs,sim)</code></pre><p>返回观测值 <code>obs</code> 和模拟值 <code>sim</code> 之间的均方根误差（Root Mean Squared Error）。</p><p>值越接近0越好。</p><p><strong>示例</strong></p><pre><code class="language- hljs">using PlantSimEngine

obs = [1.0, 2.0, 3.0]
sim = [1.1, 2.1, 3.1]

RMSE(obs, sim)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/evaluation/statistics.jl#L2-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.add_organ!-Tuple{MultiScaleTreeGraph.Node, Vararg{Any, 4}}"><a class="docstring-binding" href="#PlantSimEngine.add_organ!-Tuple{MultiScaleTreeGraph.Node, Vararg{Any, 4}}"><code>PlantSimEngine.add_organ!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_organ!(node::MultiScaleTreeGraph.Node, sim_object, link, symbol, scale; index=0, id=MultiScaleTreeGraph.new_id(MultiScaleTreeGraph.get_root(node)), attributes=Dict{Symbol,Any}(), check=true)</code></pre><p>向图中添加一个器官，并自动初始化该器官的（多尺度）变量状态。</p><p>此函数应从实现器官出现的模型中调用，例如基于热时间的函数。</p><p><strong>参数说明</strong></p><ul><li><code>node</code>：要向其添加器官的节点（新器官的父节点）</li><li><code>sim_object</code>：模拟对象，例如模型的<code>extra</code>参数中的 <code>GraphSimulation</code> 对象。</li><li><code>link</code>：新节点与器官之间的连接类型：<ul><li><code>&quot;&lt;&quot;</code>：新节点在父器官之后</li><li><code>&quot;+&quot;</code>：新节点从父器官分枝</li><li><code>&quot;/&quot;</code>：新节点分解父器官，即更改尺度</li></ul></li><li><code>symbol</code>：器官的符号，例如 <code>&quot;Leaf&quot;</code></li><li><code>scale</code>：器官的尺度，例如 <code>2</code>。</li><li><code>index</code>：器官的序号，例如 <code>1</code>。<code>index</code> 可用于方便地标识分枝顺序，或轴上的生长单元序号。它不同于唯一的节点 <code>id</code>。</li><li><code>id</code>：新节点的唯一编号。如果未提供，则自动生成新编号。</li><li><code>attributes</code>：新节点的属性。如果未提供，则使用空字典。</li><li><code>check</code>：布尔值，表示是否检查变量初始化。会传递给 <code>init_node_status!</code>。</li></ul><p><strong>返回值</strong></p><ul><li><code>status</code>：新节点的状态</li></ul><p><strong>示例</strong></p><p>具体用法请参考 <code>Examples</code> 模块中的 <code>ToyInternodeEmergence</code> 示例模型（也可在 <code>examples</code> 文件夹找到），或 <code>test-mtg-dynamic.jl</code> 测试文件。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/mtg/add_organ.jl#L1-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.dep"><a class="docstring-binding" href="#PlantSimEngine.dep"><code>PlantSimEngine.dep</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">dep(m::ModelList)
dep(mapping::Dict{String,T}; verbose=true)
dep!(m::ModelList, nsteps=1)</code></pre><p>给定 ModelList 或多尺度模型映射，获取模型的依赖图。如果返回一个图，则所有模型耦合在一起；如果返回多个图，则每个图内的模型相互耦合，不同图中的模型不耦合。 <code>nsteps</code> 是依赖图将被使用的步数，用于决定每个软依赖在图中的 <code>simulation_id</code> 参数长度。对于多尺度映射，该值为 <code>1</code>。</p><p><strong>细节</strong></p><p>依赖图通过在每个过程的输入中查找其本层或其他层输出构建。针对每个模型（一个模型模拟一个过程）有五种情况：</p><ol><li>过程无输入。它是完全独立的，作为依赖图的根节点之一。</li><li>过程需要同层模型输入。被放置为另一个过程的子节点。</li><li>过程需要来自另一层的输入。被设置为另一个层过程的子节点。</li><li>过程需要本层和另一层的输入。分别作为两个过程的子节点。</li><li>过程作为另一个过程的硬依赖（仅可能在同层）。此时该过程被设为另一个过程的硬依赖，仿真由该过程直接控制。</li></ol><p>第四种情况，过程有两个父过程。这样处理没有问题，因为仿真时会检查两个父节点是否都已运行，仅当均已运行后再运行当前过程。</p><p>第五种情况，依然需要检查变量是否来自另一层。此时父节点作为另一层过程的子节点。需注意，可能存在多层硬依赖图，因此此过程是递归完成的。</p><p>如何实现以上功能？首先识别硬依赖，然后将硬依赖根节点的输入输出与其它层连接（如有必要）。随后将所有这些节点转为软依赖，放入一个 Dict（Scale =&gt; Dict(process =&gt; SoftDependencyNode)）中。 遍历所有节点，将需要其它节点输出作为输入的节点，设置为子/父节点关系。 如某节点无任何依赖，则设置为根节点并推入新 Dict（independant<em>process</em>root）。此 Dict 就是返回的依赖图，根节点为各子图的独立起点，这些子图即为被耦合在一起的模型。此后可分别遍历每个子图进行仿真。</p><p><strong>备注</strong></p><p><code>dep(m::ModelList)</code> 与 <code>dep!(m::ModelList, nsteps)</code> 的区别在于，前者返回模型列表中的依赖图，后者返回指定步数的依赖图，并对每个节点的 simulation<em>id 进行修正（`simulation</em>id=fill(0, nsteps)`）。</p><p><strong>示例</strong></p><pre><code class="language- hljs">using PlantSimEngine

# 包含示例过程与模型：
using PlantSimEngine.Examples;

models = ModelList(
    process1=Process1Model(1.0),
    process2=Process2Model(),
    process3=Process3Model(),
    status=(var1=15.0, var2=0.3)
)

dep(models)

# 或直接用过程：
models = (
    process1=Process1Model(1.0),
    process2=Process2Model(),
    process3=Process3Model(),
    process4=Process4Model(),
    process5=Process5Model(),
    process6=Process6Model(),
    process7=Process7Model(),
)

dep(;models...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/dependencies/dependencies.jl#L3-L63">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.dr-Tuple{Any, Any}"><a class="docstring-binding" href="#PlantSimEngine.dr-Tuple{Any, Any}"><code>PlantSimEngine.dr</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dr(obs,sim)</code></pre><p>返回Willmott提出的改进一致性指数dᵣ。 参考：Willmot et al. 2011. A refined index of model performance. https://rmets.onlinelibrary.wiley.com/doi/10.1002/joc.2419</p><p>值越接近1越好。</p><p><strong>示例</strong></p><pre><code class="language- hljs">using PlantSimEngine

obs = [1.0, 2.0, 3.0]
sim = [1.1, 2.1, 3.1]

dr(obs, sim)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/evaluation/statistics.jl#L70-L88">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.fit"><a class="docstring-binding" href="#PlantSimEngine.fit"><code>PlantSimEngine.fit</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fit()</code></pre><p>利用观测值（以及可能的初始化值）优化模型参数。</p><p>建模者应为其模型实现一个 <code>fit</code> 方法，建议采用以下设计模式：</p><p>函数调用应将模型类型作为第一个参数（T::Type{&lt;:AbstractModel}）， 数据作为第二个参数（支持 Table.jl 的类型，如 DataFrame），并将参数初始化作为关键字参数传递（必要时可设默认值）。</p><p>例如，拟合示例脚本中的 <code>Beer</code> 模型的方法（参考 <code>src/examples/Beer.jl</code>）如下：</p><pre><code class="language-julia hljs">function PlantSimEngine.fit(::Type{Beer}, df; J_to_umol=PlantMeteo.Constants().J_to_umol)
    k = Statistics.mean(log.(df.Ri_PAR_f ./ (df.aPPFD ./ J_to_umol)) ./ df.LAI)
    return (k=k,)
end</code></pre><p>该函数应返回以 <code>NamedTuple</code> 形式包含优化参数的元组，如 <code>(parameter_name=parameter_value,)</code>。</p><p>以下是使用 <code>Beer</code> 模型的一个示例，其中通过&quot;aPPFD&quot;、&quot;LAI&quot; 和 &quot;Ri<em>PAR</em>f&quot; 的观测值拟合参数 <code>k</code>。</p><pre><code class="language-julia hljs"># 引入示例过程与模型：
using PlantSimEngine.Examples;

m = ModelList(Beer(0.6), status=(LAI=2.0,))
meteo = Atmosphere(T=20.0, Wind=1.0, P=101.3, Rh=0.65, Ri_PAR_f=300.0)
run!(m, meteo)
df = DataFrame(aPPFD=m[:aPPFD][1], LAI=m.status.LAI[1], Ri_PAR_f=meteo.Ri_PAR_f[1])
fit(Beer, df)</code></pre><p>注意，这是一个用于演示拟合方法有效性的虚拟示例。在该例中，通过设置 <code>k=0.6</code> 用 Beer-Lambert 定律模拟 aPPFD，并再次利用模拟得到的 aPPFD 来拟合 <code>k</code>，最终得到与模拟时一致的参数值。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/evaluation/fit.jl#L2-L37">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.init_status!-Tuple{Dict{String, ModelList}}"><a class="docstring-binding" href="#PlantSimEngine.init_status!-Tuple{Dict{String, ModelList}}"><code>PlantSimEngine.init_status!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">init_status!(object::Dict{String,ModelList};vars...)
init_status!(component::ModelList;vars...)</code></pre><p>为组件赋予用户输入的初值。</p><p><strong>示例</strong></p><pre><code class="language- hljs">using PlantSimEngine

# 加载包中的示例虚拟模型：
using PlantSimEngine.Examples

models = Dict(
    &quot;Leaf&quot; =&gt; ModelList(
        process1=Process1Model(1.0),
        process2=Process2Model(),
        process3=Process3Model()
    ),
    &quot;InterNode&quot; =&gt; ModelList(
        process1=Process1Model(1.0),
    )
)

init_status!(models, var1=1.0 , var2=2.0)
status(models[&quot;Leaf&quot;])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/processes/model_initialisation.jl#L163-L191">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.init_variables-Tuple{T} where T&lt;:AbstractModel"><a class="docstring-binding" href="#PlantSimEngine.init_variables-Tuple{T} where T&lt;:AbstractModel"><code>PlantSimEngine.init_variables</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">init_variables(models...)</code></pre><p>用模型的默认值初始化变量。这些变量取自模型的输入和输出。</p><p><strong>示例</strong></p><pre><code class="language- hljs">using PlantSimEngine

# 加载包中的示例虚拟模型：
using PlantSimEngine.Examples

init_variables(Process1Model(2.0))
init_variables(process1=Process1Model(2.0), process2=Process2Model())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/processes/model_initialisation.jl#L217-L233">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.inputs-Tuple{T} where T&lt;:AbstractModel"><a class="docstring-binding" href="#PlantSimEngine.inputs-Tuple{T} where T&lt;:AbstractModel"><code>PlantSimEngine.inputs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">inputs(model::AbstractModel)
inputs(...)</code></pre><p>获取一个或多个模型的输入变量。</p><p>对于 <code>AbstractModel</code>（无输入变量）或 <code>Missing</code> 类型的模型，默认返回空元组。</p><p><strong>示例</strong></p><pre><code class="language-julia hljs">using PlantSimEngine;

# Load the dummy models given as example in the package:
using PlantSimEngine.Examples;

inputs(Process1Model(1.0))

# output
(:var1, :var2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/processes/models_inputs_outputs.jl#L1-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.inputs-Union{Tuple{Dict{String, T}}, Tuple{T}} where T"><a class="docstring-binding" href="#PlantSimEngine.inputs-Union{Tuple{Dict{String, T}}, Tuple{T}} where T"><code>PlantSimEngine.inputs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">inputs(mapping::Dict{String,T})</code></pre><p>获取映射中每个过程和器官类型的模型输入变量。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/processes/models_inputs_outputs.jl#L39-L43">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.is_initialized-Tuple{T} where T&lt;:ModelList"><a class="docstring-binding" href="#PlantSimEngine.is_initialized-Tuple{T} where T&lt;:ModelList"><code>PlantSimEngine.is_initialized</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_initialized(m::T) where T &lt;: ModelList
is_initialized(m::T, models...) where T &lt;: ModelList</code></pre><p>检查必须初始化的变量是否已经被初始化。如果已初始化全部变量，返回 <code>true</code>，否则返回 <code>false</code> 并给出信息提示。</p><p><strong>注意</strong></p><p>无法预先知道用户将仿真哪些过程，因此，如果一个组件为每个过程都定义了模型，则需要初始化的变量始终是所有变量中最小的那个子集，即认为用户将仿真其它模型所需的变量。</p><p><strong>示例</strong></p><pre><code class="language- hljs">using PlantSimEngine

# 加载包中的示例虚拟模型：
using PlantSimEngine.Examples

models = ModelList(
    process1=Process1Model(1.0),
    process2=Process2Model(),
    process3=Process3Model()
)

is_initialized(models)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/processes/model_initialisation.jl#L268-L294">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.outputs-Tuple{T} where T&lt;:AbstractModel"><a class="docstring-binding" href="#PlantSimEngine.outputs-Tuple{T} where T&lt;:AbstractModel"><code>PlantSimEngine.outputs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">outputs(model::AbstractModel)
outputs(...)</code></pre><p>获取一个或多个模型的输出变量。</p><p>对于 <code>AbstractModel</code>（无输出变量）或 <code>Missing</code> 类型的模型，默认返回空元组。</p><p><strong>示例</strong></p><pre><code class="language-julia hljs">using PlantSimEngine;

# Load the dummy models given as example in the package:
using PlantSimEngine.Examples;

outputs(Process1Model(1.0))

# output
(:var3,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/processes/models_inputs_outputs.jl#L54-L75">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.outputs-Union{Tuple{Dict{String, T}}, Tuple{T}} where T"><a class="docstring-binding" href="#PlantSimEngine.outputs-Union{Tuple{Dict{String, T}}, Tuple{T}} where T"><code>PlantSimEngine.outputs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">outputs(mapping::Dict{String,T})</code></pre><p>获取映射中每个过程和器官类型的模型输出变量。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/processes/models_inputs_outputs.jl#L84-L88">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.run!"><a class="docstring-binding" href="#PlantSimEngine.run!"><code>PlantSimEngine.run!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">run!(object, meteo, constants, extra=nothing; check=true, executor=Floops.ThreadedEx())
run!(object, mapping, meteo, constants, extra; nsteps, outputs, check, executor)</code></pre><p>运行仿真，对模型列表中的每个模型按照正确顺序（即按照依赖关系图）执行。</p><p>如果给定多个时间步，模型将在每个时间步顺序运行。</p><p><strong>参数说明</strong></p><ul><li><code>object</code>：一个 <a href="../step_by_step/simple_model_coupling.html#ModelList"><code>ModelList</code></a>、<code>ModelList</code> 的数组或字典，或者一个植物图（MTG）。</li><li><code>meteo</code>：一个 <a href="https://palmstudio.github.io/PlantMeteo.jl/stable/API/#PlantMeteo.TimeStepTable"><code>PlantMeteo.TimeStepTable</code></a>，其元素为 <a href="https://palmstudio.github.io/PlantMeteo.jl/stable/API/#PlantMeteo.Atmosphere"><code>PlantMeteo.Atmosphere</code></a>，或单一 <code>PlantMeteo.Atmosphere</code>。</li><li><code>constants</code>：一个 <a href="https://palmstudio.github.io/PlantMeteo.jl/stable/API/#PlantMeteo.Constants"><code>PlantMeteo.Constants</code></a> 对象，或由常量键和值组成的 NamedTuple。</li><li><code>extra</code>：额外参数。在仿真植物图（MTG）时不可用（仿真对象通过此参数传递）。</li><li><code>check</code>：若为 <code>true</code>，在运行仿真前检查模型列表合法性（会花费少量时间），且在运行过程中返回更多信息。</li><li><code>executor</code>：用于运行仿真的 <a href="https://juliafolds.github.io/FLoops.jl/stable/"><code>Floops</code></a> 执行器，可以顺序执行（<code>executor=SequentialEx()</code>）、多线程并行（<code>executor=ThreadedEx()</code>，默认）、分布式并行（<code>executor=DistributedEx()</code>）。</li><li><code>mapping</code>：MTG 与模型列表之间的映射关系。</li><li><code>nsteps</code>：需要运行的时间步数，仅在未给定 meteo 时需要（否则会自动从 meteo 推断）。</li><li><code>outputs</code>：对于 MTG 的每个节点类型，需动态获得的输出变量。</li></ul><p><strong>返回值</strong></p><p>在原地修改对象的 status。用户可通过 <a href="https://virtualplantlab.github.io/PlantSimEngine.jl/stable/API/#PlantSimEngine.status-Tuple{Any}"><code>status</code></a> 函数（参见示例）从对象获取结果。</p><p><strong>细节</strong></p><p><strong>模型执行</strong></p><p>模型按照依赖图顺序运行。如果一个模型对另一个模型有软依赖（即输入由另一模型计算），会优先运行被依赖模型。若有多个软依赖，则会优先计算所有父模型（软依赖）。</p><p><strong>并行执行</strong></p><p>用户可以通过为 <code>executor</code> 参数提供兼容执行器实现并行。软件包会自动检查是否允许并行。如果不允许而用户指定了并行，将会发出警告，并转为顺序执行。 我们使用 <a href="https://juliafolds.github.io/FLoops.jl/stable/"><code>Floops</code></a> 包实现并行仿真，意味着你可将任何相容的执行器传入 <code>executor</code> 参数。 可参考 <a href="https://github.com/JuliaFolds/FoldsThreads.jl">FoldsThreads.jl</a>（线程执行器）、<a href="https://github.com/JuliaFolds/FoldsDagger.jl">FoldsDagger.jl</a>（Dagger 框架并行 fold）、以及即将发布的 <a href="https://github.com/JuliaFolds/FoldsCUDA.jl">FoldsCUDA.jl</a>（GPU 计算，详见 <a href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/issues/22">本议题</a>）和 <a href="https://github.com/JuliaFolds/FoldsKernelAbstractions.jl">FoldsKernelAbstractions.jl</a>。也可以通过 <a href="https://github.com/JuliaFolds/ParallelMagics.jl">ParallelMagics.jl</a> 检查是否可自动并行。</p><p><strong>示例</strong></p><p>导入相关包：</p><pre><code class="language-julia-repl hljs">julia&gt; using PlantSimEngine, PlantMeteo;</code></pre><p>加载 <code>Examples</code> 子模块中给出的示例模型：</p><pre><code class="language-julia-repl hljs">julia&gt; using PlantSimEngine.Examples;</code></pre><p>创建模型列表：</p><pre><code class="language-julia-repl hljs">julia&gt; models = ModelList(Process1Model(1.0), Process2Model(), Process3Model(), status = (var1=1.0, var2=2.0));</code></pre><p>创建气象数据：</p><pre><code class="language-julia-repl hljs">julia&gt; meteo = Atmosphere(T=20.0, Wind=1.0, P=101.3, Rh=0.65, Ri_PAR_f=300.0);</code></pre><p>运行仿真：</p><pre><code class="language-julia-repl hljs">julia&gt; outputs_sim = run!(models, meteo);</code></pre><p>获取仿真输出：</p><pre><code class="language-julia-repl hljs">julia&gt; (outputs_sim[:var4],outputs_sim[:var6])
([12.0], [41.95])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/run.jl#L1-L75">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.status-Tuple{Any}"><a class="docstring-binding" href="#PlantSimEngine.status-Tuple{Any}"><code>PlantSimEngine.status</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">status(m)
status(m::AbstractArray{&lt;:ModelList})
status(m::AbstractDict{T,&lt;:ModelList})</code></pre><p>获取 ModelList 的状态，即输入（和输出）变量的状态。</p><p>另见 <a href="API_public.html#PlantSimEngine.is_initialized-Tuple{T} where T&lt;:ModelList"><code>is_initialized</code></a> 和 <a href="API_public.html#PlantSimEngine.to_initialize-Tuple{ModelList}"><code>to_initialize</code></a></p><p><strong>示例</strong></p><pre><code class="language-julia hljs">using PlantSimEngine

# Including example models and processes:
using PlantSimEngine.Examples;

# Create a ModelList
models = ModelList(
    process1=Process1Model(1.0),
    process2=Process2Model(),
    process3=Process3Model(),
    status = (var1=[15.0, 16.0], var2=0.3)
);

status(models)

# Or just one variable:
status(models,:var1)


# Or the status at the ith time-step:
status(models, 2)

# Or even more simply:
models[:var1]
# output
2-element Vector{Float64}:
 15.0
 16.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/component_models/get_status.jl#L1-L42">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.to_initialize-Tuple{ModelList}"><a class="docstring-binding" href="#PlantSimEngine.to_initialize-Tuple{ModelList}"><code>PlantSimEngine.to_initialize</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">to_initialize(; verbose=true, vars...)
to_initialize(m::T)  where T &lt;: ModelList
to_initialize(m::DependencyGraph)
to_initialize(mapping::Dict{String,T}, graph=nothing)</code></pre><p>返回必须初始化的变量，提供一组模型与过程。 该函数考虑模型耦合，仅返回必需的变量，即只返回那些由于部分模型的输出变量被其他模型作为输入变量而需要的变量。</p><p><strong>参数</strong></p><ul><li><code>verbose</code>: 如果为<code>true</code>，打印信息消息。</li><li><code>vars...</code>: 要考虑的模型和过程。</li><li><code>m::T</code>: 一个<a href="../step_by_step/simple_model_coupling.html#ModelList"><code>ModelList</code></a>。</li><li><code>m::DependencyGraph</code>: 一个 <a href="API_private.html#PlantSimEngine.DependencyGraph"><code>DependencyGraph</code></a>。</li><li><code>mapping::Dict{String,T}</code>: 一个模型与器官的映射。</li><li><code>graph</code>: 表示植物或场景的图（如多尺度树图）。该图被用于检测未初始化变量是否在图节点属性中已存在。</li></ul><p><strong>示例</strong></p><pre><code class="language- hljs">using PlantSimEngine

# 加载包中的示例虚拟模型：
using PlantSimEngine.Examples

to_initialize(process1=Process1Model(1.0), process2=Process2Model())

# 或直接使用组件：
models = ModelList(process1=Process1Model(1.0), process2=Process2Model())
to_initialize(models)

m = ModelList(
    (
        process1=Process1Model(1.0),
        process2=Process2Model()
    ),
    Status(var1 = 5.0, var2 = -Inf, var3 = -Inf, var4 = -Inf, var5 = -Inf)
)

to_initialize(m)</code></pre><p>或者带有映射：</p><pre><code class="language- hljs">using PlantSimEngine

# 加载包中的示例虚拟模型：
using PlantSimEngine.Examples

mapping = Dict(
    &quot;Leaf&quot; =&gt; ModelList(
        process1=Process1Model(1.0),
        process2=Process2Model(),
        process3=Process3Model()
    ),
    &quot;Internode&quot; =&gt; ModelList(
        process1=Process1Model(1.0),
    )
)

to_initialize(mapping)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/processes/model_initialisation.jl#L1-L65">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.variables-Tuple{Module}"><a class="docstring-binding" href="#PlantSimEngine.variables-Tuple{Module}"><code>PlantSimEngine.variables</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">variables(pkg::Module)</code></pre><p>返回某个依赖 PlantSimEngine 的包中所有变量、变量描述及单位的数据表（需包作者实现）。</p><p><strong>开发者注意事项</strong></p><p>依赖 PlantSimEngine 的包开发者应将变量信息写入 &quot;data/variables.csv&quot; 文件， 该函数会返回此文件的内容。</p><p><strong>示例</strong></p><p>以下为 PlantBiophysics 包的示例：</p><pre><code class="language-julia hljs">#] add PlantBiophysics
using PlantBiophysics
variables(PlantBiophysics)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/processes/models_inputs_outputs.jl#L152-L171">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.variables-Union{Tuple{Dict{String, T}}, Tuple{T}} where T"><a class="docstring-binding" href="#PlantSimEngine.variables-Union{Tuple{Dict{String, T}}, Tuple{T}} where T"><code>PlantSimEngine.variables</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">variables(mapping::Dict{String,T})</code></pre><p>获取映射中每个过程和器官类型模型的变量（输入与输出）。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/processes/models_inputs_outputs.jl#L176-L180">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.variables-Union{Tuple{T}, Tuple{T, Vararg{Any}}} where T&lt;:Union{Missing, AbstractModel}"><a class="docstring-binding" href="#PlantSimEngine.variables-Union{Tuple{T}, Tuple{T, Vararg{Any}}} where T&lt;:Union{Missing, AbstractModel}"><code>PlantSimEngine.variables</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">variables(model)
variables(model, models...)</code></pre><p>返回模型所需变量的名称元组，或多个模型变量名的并集。</p><p><strong>注意</strong></p><p>每个模型都可以（且应该）为此函数定义一个方法。</p><pre><code class="language-julia hljs">
using PlantSimEngine;

# Load the dummy models given as example in the package:
using PlantSimEngine.Examples;

variables(Process1Model(1.0))

variables(Process1Model(1.0), Process2Model())

# output

(var1 = -Inf, var2 = -Inf, var3 = -Inf, var4 = -Inf, var5 = -Inf)</code></pre><p><strong>参见</strong></p><p><a href="API_public.html#PlantSimEngine.inputs-Tuple{T} where T&lt;:AbstractModel"><code>inputs</code></a>, <a href="API_public.html#PlantSimEngine.outputs-Tuple{T} where T&lt;:AbstractModel"><code>outputs</code></a> and <a href="API_private.html#PlantSimEngine.variables_typed-Tuple{T} where T&lt;:AbstractModel"><code>variables_typed</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/processes/models_inputs_outputs.jl#L108-L137">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantSimEngine.@process-Tuple{Any, Vararg{Any}}"><a class="docstring-binding" href="#PlantSimEngine.@process-Tuple{Any, Vararg{Any}}"><code>PlantSimEngine.@process</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@process(process::String, doc::String=&quot;&quot;; verbose::Bool=true)</code></pre><p>该宏用于生成某一过程的抽象类型及部分仿真的样板代码，并自动生成相关文档。如果<code>verbose=true</code>，还会输出简短的模型实现教程。</p><p>该抽象过程类型会作为所有该过程模型实现的父类型，其名称形式为 &quot;Abstract&lt;ProcessName&gt;Model&quot;，例如对于过程名 &quot;growth&quot;，其父类型为 <code>AbstractGrowthModel</code>。</p><p>@process 的第一个参数为新过程名称，第二个参数为附加到 <code>Abstract&lt;ProcessName&gt;Model</code> 类型上的额外文档内容，第三个参数决定是否打印简短教程。</p><p>建议新用户使用该宏，因为它会详细说明后续的操作流程。更有经验的用户可直接定义 abstract type 并指定为 <code>AbstractModel</code> 的子类，而不输出教程：</p><pre><code class="language-julia hljs">abstract type MyNewProcess &lt;: AbstractModel end</code></pre><p><strong>例子</strong></p><pre><code class="language-julia hljs">@process &quot;dummy_process&quot; &quot;This is a dummy process that shall not be used&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/1a8f3d15f3b55df3a8b2258baaa6467207c096ad/src/processes/process_generation.jl#L1-L21">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../troubleshooting_and_testing/implicit_contracts.html">« 隐性约定</a><a class="docs-footer-nextpage" href="API_examples.html">示例模型 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Saturday 10 January 2026 19:41">Saturday 10 January 2026</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
