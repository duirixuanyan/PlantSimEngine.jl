<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>关键概念 · PlantSimEngine.jl</title><meta name="title" content="关键概念 · PlantSimEngine.jl"/><meta property="og:title" content="关键概念 · PlantSimEngine.jl"/><meta property="twitter:title" content="关键概念 · PlantSimEngine.jl"/><meta name="description" content="Documentation for PlantSimEngine.jl."/><meta property="og:description" content="Documentation for PlantSimEngine.jl."/><meta property="twitter:description" content="Documentation for PlantSimEngine.jl."/><meta property="og:url" content="https://VirtualPlantLab.github.io/PlantSimEngine.jl/prerequisites\\key_concepts.html"/><meta property="twitter:url" content="https://VirtualPlantLab.github.io/PlantSimEngine.jl/prerequisites\\key_concepts.html"/><link rel="canonical" href="https://VirtualPlantLab.github.io/PlantSimEngine.jl/prerequisites\\key_concepts.html"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">PlantSimEngine.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">首页</a></li><li><span class="tocitem">简介</span><ul><li><a class="tocitem" href="../introduction/why_plantsimengine.html">为什么选择 PlantSimEngine？</a></li><li><a class="tocitem" href="../introduction/why_julia.html">为什么选择 Julia？</a></li></ul></li><li><span class="tocitem">前置条件</span><ul><li><a class="tocitem" href="installing_plantsimengine.html">PlantSimEngine 的安装与运行</a></li><li class="is-active"><a class="tocitem" href="key_concepts.html">关键概念</a><ul class="internal"><li><a class="tocitem" href="#作物模型"><span>作物模型</span></a></li><li><a class="tocitem" href="#FSPM（功能-结构植物模型）"><span>FSPM（功能-结构植物模型）</span></a></li><li><a class="tocitem" href="#PlantSimEngine-术语"><span>PlantSimEngine 术语</span></a></li></ul></li><li><a class="tocitem" href="julia_basics.html">Julia 语言基础</a></li></ul></li><li><span class="tocitem">分步教程 - 单尺度模拟</span><ul><li><a class="tocitem" href="../step_by_step/detailed_first_example.html">详细的第一个模拟</a></li><li><a class="tocitem" href="../step_by_step/simple_model_coupling.html">模型耦合</a></li><li><a class="tocitem" href="../step_by_step/model_switching.html">模型切换</a></li><li><a class="tocitem" href="../step_by_step/quick_and_dirty_examples.html">快速示例</a></li><li><a class="tocitem" href="../step_by_step/implement_a_process.html">实现一个过程</a></li><li><a class="tocitem" href="../step_by_step/implement_a_model.html">实现一个模型</a></li><li><a class="tocitem" href="../step_by_step/parallelization.html">并行化</a></li><li><a class="tocitem" href="../step_by_step/advanced_coupling.html">高级耦合与硬依赖</a></li><li><a class="tocitem" href="../step_by_step/implement_a_model_additional.html">实现一个模型：补充说明</a></li></ul></li><li><a class="tocitem" href="../model_execution.html">模型执行</a></li><li><span class="tocitem">数据处理</span><ul><li><a class="tocitem" href="../working_with_data/reducing_dof.html">降低自由度</a></li><li><a class="tocitem" href="../working_with_data/fitting.html">拟合</a></li><li><a class="tocitem" href="../working_with_data/inputs.html">输入类型</a></li><li><a class="tocitem" href="../working_with_data/visualising_outputs.html">可视化输出与数据</a></li><li><a class="tocitem" href="../working_with_data/floating_point_accumulation_error.html">浮点运算注意事项</a></li></ul></li><li><span class="tocitem">多尺度建模</span><ul><li><a class="tocitem" href="../multiscale/multiscale_considerations.html">多尺度建模考量</a></li><li><a class="tocitem" href="../multiscale/single_to_multiscale.html">单尺度模型转换为多尺度</a></li><li><a class="tocitem" href="../multiscale/multiscale.html">更多变量映射示例</a></li><li><a class="tocitem" href="../multiscale/multiscale_cyclic.html">循环依赖的处理</a></li><li><a class="tocitem" href="../multiscale/multiscale_coupling.html">多尺度耦合相关说明</a></li><li><input class="collapse-toggle" id="menuitem-7-6" type="checkbox"/><label class="tocitem" for="menuitem-7-6"><span class="docs-label">构建简单植株</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../multiscale/multiscale_example_1.html">简单植株模拟</a></li><li><a class="tocitem" href="../multiscale/multiscale_example_2.html">拓展植株模拟</a></li><li><a class="tocitem" href="../multiscale/multiscale_example_3.html">修复植株模拟中的错误</a></li></ul></li><li><a class="tocitem" href="../multiscale/multiscale_example_4.html">用 PlantGeom 可视化玩具植株</a></li></ul></li><li><span class="tocitem">故障排查与测试</span><ul><li><a class="tocitem" href="../troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting.html">故障排查</a></li><li><a class="tocitem" href="../troubleshooting_and_testing/downstream_tests.html">自动化测试</a></li><li><a class="tocitem" href="../troubleshooting_and_testing/tips_and_workarounds.html">技巧与常见问题</a></li><li><a class="tocitem" href="../troubleshooting_and_testing/implicit_contracts.html">隐性约定</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../API/API_public.html">公共 API</a></li><li><a class="tocitem" href="../API/API_examples.html">示例模型</a></li><li><a class="tocitem" href="../API/API_private.html">内部 API</a></li></ul></li><li><a class="tocitem" href="../documentation_improvement.html">改进文档</a></li><li><a class="tocitem" href="../developers.html">开发者指南</a></li><li><a class="tocitem" href="../planned_features.html">规划功能</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">前置条件</a></li><li class="is-active"><a href="key_concepts.html">关键概念</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="key_concepts.html">关键概念</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/main/docs - 中文/src/prerequisites/key_concepts.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="关键概念"><a class="docs-heading-anchor" href="#关键概念">关键概念</a><a id="关键概念-1"></a><a class="docs-heading-anchor-permalink" href="#关键概念" title="Permalink"></a></h1><p>本页简要介绍了与 PlantSimEngine 相关及在使用过程中涉及到的一些主要概念和术语。</p><ul><li><a href="key_concepts.html#关键概念">关键概念</a></li><li class="no-marker"><ul><li><a href="key_concepts.html#作物模型">作物模型</a></li><li><a href="key_concepts.html#FSPM（功能-结构植物模型）">FSPM（功能-结构植物模型）</a></li><li><a href="key_concepts.html#PlantSimEngine-术语">PlantSimEngine 术语</a></li><li class="no-marker"><ul><li><a href="key_concepts.html#过程（Processes）">过程（Processes）</a></li><li><a href="key_concepts.html#模型（Models）">模型（Models）</a></li><li><a href="key_concepts.html#变量、输入、输出与模型耦合">变量、输入、输出与模型耦合</a></li><li><a href="key_concepts.html#依赖图（Dependency-graphs）">依赖图（Dependency graphs）</a></li><li><a href="key_concepts.html#hard_dependency_def">“硬依赖”和“软依赖”</a></li><li><a href="key_concepts.html#天气数据">天气数据</a></li><li><a href="key_concepts.html#器官-/-尺度（Organ/Scale）">器官 / 尺度（Organ/Scale）</a></li><li><a href="key_concepts.html#多尺度建模">多尺度建模</a></li><li><a href="key_concepts.html#多尺度树图（MTG,-Multi-scale-Tree-Graphs）">多尺度树图（MTG, Multi-scale Tree Graphs）</a></li><li class="no-marker"><ul><li><a href="key_concepts.html#尺度-/-符号（symbol）术语的混淆">尺度 / 符号（symbol）术语的混淆</a></li><li><a href="key_concepts.html#TLDR">TLDR</a></li></ul></li><li><a href="key_concepts.html#状态机">状态机</a></li></ul></li></ul></li></ul><h2 id="作物模型"><a class="docs-heading-anchor" href="#作物模型">作物模型</a><a id="作物模型-1"></a><a class="docs-heading-anchor-permalink" href="#作物模型" title="Permalink"></a></h2><h2 id="FSPM（功能-结构植物模型）"><a class="docs-heading-anchor" href="#FSPM（功能-结构植物模型）">FSPM（功能-结构植物模型）</a><a id="FSPM（功能-结构植物模型）-1"></a><a class="docs-heading-anchor-permalink" href="#FSPM（功能-结构植物模型）" title="Permalink"></a></h2><h2 id="PlantSimEngine-术语"><a class="docs-heading-anchor" href="#PlantSimEngine-术语">PlantSimEngine 术语</a><a id="PlantSimEngine-术语-1"></a><a class="docs-heading-anchor-permalink" href="#PlantSimEngine-术语" title="Permalink"></a></h2><p>本页对 PlantSimEngine 中用到的核心概念和术语进行了总体说明。如果你需要更贴近实现的详细设计与术语释义，请参见<a href="../step_by_step/detailed_first_example.html#detailed-walkthrough-of-a-simple-simulation">简单模拟流程详解</a>。</p><p>!!! 注意     某些术语在不同语境下可能含义不同，尤以“器官”、“尺度”（scale）和“符号”（symbol）为甚：这些词在<a href="../multiscale/multiscale_considerations.html#多尺度树图">多尺度树图</a>中与 PlantSimEngine 其他部分的含义略有区别（见下文<a href="key_concepts.html#尺度-/-符号（symbol）术语的混淆">尺度 / 符号（symbol）术语的混淆</a>小节）。遇到相关疑问时，请务必参阅对应子章节及相关示例。</p><h3 id="过程（Processes）"><a class="docs-heading-anchor" href="#过程（Processes）">过程（Processes）</a><a id="过程（Processes）-1"></a><a class="docs-heading-anchor-permalink" href="#过程（Processes）" title="Permalink"></a></h3><p>在本包中，“过程”指一个生物或物理现象。你可以将其理解为系统中发生的任何过程，如光拦截、光合作用、水分、碳和能量通量、生长、产量，甚至太阳能电池产生的电力等。</p><p>如需了解如何声明一个新过程，可参见<a href="../step_by_step/implement_a_process.html#实现一个新过程">实现一个新过程</a>。</p><h3 id="模型（Models）"><a class="docs-heading-anchor" href="#模型（Models）">模型（Models）</a><a id="模型（Models）-1"></a><a class="docs-heading-anchor-permalink" href="#模型（Models）" title="Permalink"></a></h3><p>在 PlantSimEngine 中，“模型”指的是针对某一过程进行仿真的具体实现。</p><p>对于同一个过程，可能存在多种不同的模型选择。例如，针对光合作用有多种建模假说和粒度、精度不同的模型。一种简单光合模型可能只是对总叶面积用一个简明公式进行计算，而更复杂的模型则会模拟光拦截和光衰减等过程。</p><p>!!! 注意     配套包 PlantBiophysics.jl 提供了用于实现光衰减 Beer-Lambert 定律的 <a href="https://vezy.github.io/PlantBiophysics.jl/stable/functions/#PlantBiophysics.Beer"><code>Beer</code></a> 结构体。本包也为 <code>light_interception</code> 过程和 <code>Beer</code> 模型提供了示例脚本，见 <a href="https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/master/examples/Beer.jl"><code>examples/Beer.jl</code></a>。</p><p>模型不仅仅用于文献定义的生理过程，也可以用于各种临时计算或非标准功能。在 PlantSimEngine 中，一切皆为模型。在许多场景下，自定义模型非常实用，比如汇总计算或处理特定信息。例如油棕模型 XPalm 就有多个模型用于管理不同器官的状态，还有专门进行叶片修剪的模型，其实现见 <a href="https://github.com/PalmStudio/XPalm.jl/blob/main/src/plant/phytomer/leaves/leaf_pruning.jl">leaf_pruning.jl</a>。</p><p>要准备一次模拟，你需声明一个 ModelList，包含你所需的全部模型，并初始化各自的参数。具体用法请参见<a href="../step_by_step/detailed_first_example.html#detailed-walkthrough-of-a-simple-simulation">逐步操作详解</a>。</p><p>对于多尺度模拟，模型在使用时应当与特定尺度（scale）绑定。具体细节见下文的<a href="key_concepts.html#多尺度建模">多尺度建模</a>内容，或参见<a href="../multiscale/multiscale_considerations.html#多尺度建模的注意事项">多尺度建模的注意事项</a>页面获取更完整的描述。</p><h3 id="变量、输入、输出与模型耦合"><a class="docs-heading-anchor" href="#变量、输入、输出与模型耦合">变量、输入、输出与模型耦合</a><a id="变量、输入、输出与模型耦合-1"></a><a class="docs-heading-anchor-permalink" href="#变量、输入、输出与模型耦合" title="Permalink"></a></h3><p>在模拟过程中，模型需要某些输入数据和参数，并计算输出其它数据，这些输出可供其它模型使用。根据组合的模型不同，同一个变量可能是某些模型的输入、另一些模型的输出，也可能只是中间计算步骤，或者是整个模拟的用户输入。</p><p>下面给出一个模型耦合的概念示意图：每个“节点”代表一个不同的 PlantSimEngine 模型，图中的 <code>compute()</code> 等价于模型的 &quot;run!&quot; 函数：</p><p><img src="../www/GUID-12E2DDAD-7B20-4FE2-AA36-7FAC950382A6-low.png" alt="模型耦合示例"/> (图源: <a href="https://help.autodesk.com/view/MAYAUL/2016/ENU/?guid=__files_GUID_A9070270_9B5D_4511_8012_BC948149884D_htm&quot;">Autodesk</a>)</p><h3 id="依赖图（Dependency-graphs）"><a class="docs-heading-anchor" href="#依赖图（Dependency-graphs）">依赖图（Dependency graphs）</a><a id="依赖图（Dependency-graphs）-1"></a><a class="docs-heading-anchor-permalink" href="#依赖图（Dependency-graphs）" title="Permalink"></a></h3><p>通过上述方式将模型耦合起来，会形成所谓的<a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">有向无环图（Directed Acyclic Graph, DAG）</a>，它是一类常见的<a href="https://en.wikipedia.org/wiki/Dependency_graph">依赖图</a>。模型的执行顺序由这个依赖图决定。</p><p><img src="../www/dags_acyclic_vs_cyclic-d1a669bf1b8b6bfa8ac3041788e81171.png" alt="有向无环图（DAG）示例"/> 一个简单的有向无环图，注意其中不允许出现环（循环）。图源: <a href="https://www.astronomer.io/docs/learn/dags/">Astronomer</a>（注：&quot;Not Acyclic&quot; 即为环状图）</p><p>PlantSimEngine 会自动根据变量和模型关系生成这样的有向无环依赖图。用户只需要声明模型，无需手动编写模型之间的连接代码，只要模型间的耦合不存在循环依赖，剩下的连接、调度都会自动完成。</p><h3 id="hard_dependency_def"><a class="docs-heading-anchor" href="#hard_dependency_def">“硬依赖”和“软依赖”</a><a id="hard_dependency_def-1"></a><a class="docs-heading-anchor-permalink" href="#hard_dependency_def" title="Permalink"></a></h3><p>通过将一个模型的输出变量设为另一个模型的输入变量，可以处理大多数常见的模型耦合（多尺度模型和变量带来更多复杂情况）。但如果两个模型之间互相依赖，需要相互迭代、多次交换数据，该怎么办？</p><p>你可以在配套包 <a href="https://github.com/VEZY/PlantBiophysics.jl">PlantBioPhysics.jl</a> 中找到一个典型案例。例如，能量平衡模型 <a href="https://github.com/VEZY/PlantBiophysics.jl/blob/master/src/processes/energy/Monteith.jl">Monteith 模型</a>需要在其 <a href="../API/API_public.html#PlantSimEngine.run!"><code>run!</code></a> 函数中<a href="https://github.com/VEZY/PlantBiophysics.jl/blob/c1a75f294109d52dc619f764ce51c6ca1ea897e8/src/processes/energy/Monteith.jl#L154">多次迭代调用光合模型</a>。</p><p>下图展示了这种模型互为依赖的方式：</p><p><img src="../www/ecophysio_coupling_diagram.png" alt="存在环的耦合示意图"/></p><p>存在环的耦合示例。图片来源：PlantBioPhysics.jl</p><p>这类模型耦合会导致模拟步骤出现“双向流动”，从而破坏依赖图中的“无环”假设。</p><p>PlantSimEngine 对这种情况的处理是：不把这些“高度耦合”的模型（下称 <strong>硬依赖</strong>）纳入主依赖图中。相反，开发者需要在一个模型内部手动调用这些硬依赖模型。这样，被调用的模型就作为父/祖先模型的内部子节点处理，不再与依赖图里的其他节点发生（外部）连接。这样得到的高级依赖图只保留没有双向依赖的模型之间的链接，依然是有向图，可以保证仿真的有序执行。上层依赖图中较简单的“外部”耦合我们称为“软依赖”。</p><p><img src="../www/PBP_dependency_graph.png" alt="PlantSimEngine 中的硬依赖耦合可视化"/></p><p>如上图所示，PlantSimEngine 对此类耦合的处理方式： 红色的模型（“硬依赖”）不会暴露在最终的依赖图中，最终依赖图只包含蓝色的“软依赖”关系，无任何环路。</p><p>这种方法对联动互依类模型的开发有如下影响：硬依赖模型必须被显式声明，并且其父模型需要在自己的 <a href="../API/API_public.html#PlantSimEngine.run!"><code>run!</code></a> 函数中显式调用该硬依赖模型的 <a href="../API/API_public.html#PlantSimEngine.run!"><code>run!</code></a> 方法。每个硬依赖模型只能对应一个父模型。</p><p>依赖其他过程使得此类模型的开发和验证稍显复杂，但这种方式依然保留了实现的灵活性，因为任何实现了该“硬依赖”过程的模型都可由用户传入。</p><p>请注意，硬依赖模型自身也可以继续嵌套更深一层的硬依赖，因此也可能出现更为复杂的多重耦合情形。</p><h3 id="天气数据"><a class="docs-heading-anchor" href="#天气数据">天气数据</a><a id="天气数据-1"></a><a class="docs-heading-anchor-permalink" href="#天气数据" title="Permalink"></a></h3><p>要运行一次模拟，通常需要获取靠近目标或部件的气候/气象条件数据。</p><p>强烈建议用户使用 <a href="https://github.com/PalmStudio/PlantMeteo.jl"><code>PlantMeteo.jl</code></a> —— 这是一个配套包，用于高效管理气象数据，内置了一些默认的预处理及高效计算相关的数据结构。本文档将始终使用 PlantMeteo.jl，也推荐大家一同使用。</p><p>该包中最基础的数据结构是 <a href="https://palmstudio.github.io/PlantMeteo.jl/stable/#PlantMeteo.Atmosphere"><code>Atmosphere</code></a> 类型，代表稳态的大气条件，即假设环境处于平衡状态。若需存储多个连续时步的气象数据，则可使用 <a href="https://palmstudio.github.io/PlantMeteo.jl/stable/#PlantMeteo.TimeStepTable"><code>TimeStepTable</code></a>。</p><p>创建 <a href="https://palmstudio.github.io/PlantMeteo.jl/stable/#PlantMeteo.Atmosphere"><code>Atmosphere</code></a> 对象时必须提供以下变量：<code>T</code>（空气温度，单位为 °C）、<code>Rh</code>（相对湿度，取值范围为 0-1）以及 <code>Wind</code>（风速，单位为 m s⁻¹）。</p><p>如下例所示，还可以额外传入（可选项）光合有效辐射通量（<code>Ri_PAR_f</code>, 单位：W m⁻²）。我们可以这样声明条件：</p><pre><code class="language-julia hljs">using PlantMeteo
meteo = Atmosphere(T = 20.0, Wind = 1.0, Rh = 0.65, Ri_PAR_f = 500.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Atmosphere(date = Dates.DateTime(&quot;2026-01-10T19:41:10.008&quot;), duration = Dates.Second(1), T = 20.0, Wind = 1.0, P = 101.325, Rh = 0.65, Precipitations = 0.0, Cₐ = 400.0, e = 1.5255470730405223, eₛ = 2.3469954969854188, VPD = 0.8214484239448965, ρ = 1.2040822421461452, λ = 2.4537e6, γ = 0.06725339460440805, ε = 0.5848056484857892, Δ = 0.14573378083416522, clearness = Inf, Ri_SW_f = Inf, Ri_PAR_f = 500.0, Ri_NIR_f = Inf, Ri_TIR_f = Inf, Ri_custom_f = Inf)</code></pre><p>详细信息可参考<a href="https://vezy.github.io/PlantMeteo.jl/stable">该包文档</a>。如果你不打算使用 PlantMeteo.jl，也可以自行提供气象数据，只要遵循 <a href="https://tables.juliadata.org/stable/#Implementing-the-Interface-(i.e.-becoming-a-Tables.jl-source)">Tables.jl 接口</a>（例如直接用 <code>DataFrame</code>）即可。</p><p>如果你希望使用更精细的逐时或逐步气象数据，那么往往需要自己扩展模型并操作 MTG 结构，模拟流程也会更复杂。</p><h3 id="器官-/-尺度（Organ/Scale）"><a class="docs-heading-anchor" href="#器官-/-尺度（Organ/Scale）">器官 / 尺度（Organ/Scale）</a><a id="器官-/-尺度（Organ/Scale）-1"></a><a class="docs-heading-anchor-permalink" href="#器官-/-尺度（Organ/Scale）" title="Permalink"></a></h3><p>植物拥有不同的器官，每种器官具有不同的生理特性与过程。当对植物生长进行更细致的模拟时，许多模型会绑定到植物的某个特定器官。例如，处理开花状态或根系吸水的模型即属于此类。其他模型（如碳分配与碳需求）则可以以稍微不同的方式被复用于同一植物的多个器官。</p><p>在 PlantSimEngine 的文档中，通常“器官”（organ）与“尺度”（scale）这两个术语可以互换使用。实际上，“尺度”更为通用且准确，因为有些模型并不在特定器官方向运行，例如可以作用于整个场景(Scene)层级。因此，MTG 结构及用户所提供的数据中可能会出现“Scene”这一尺度。</p><p>处理多尺度数据时，往往需要明确指定尺度以进行变量映射，或指明模型所处的尺度层级。你会看到类似如下的代码：</p><pre><code class="language-julia hljs">&quot;Root&quot; =&gt; (RootGrowthModel(), OrganAgeModel()),
&quot;Leaf&quot; =&gt; (LightInterceptionModel(), OrganAgeModel()),
&quot;Plant&quot; =&gt; (TotalBiomassModel(),),</code></pre><p>这个示例将具体的模型绑定到了具体的尺度。注意其中一个模型被复用于两个不同的尺度；注意 &quot;Plant&quot; 其实并不是具体的器官，因此推荐更常用“尺度”这个词。</p><h3 id="多尺度建模"><a class="docs-heading-anchor" href="#多尺度建模">多尺度建模</a><a id="多尺度建模-1"></a><a class="docs-heading-anchor-permalink" href="#多尺度建模" title="Permalink"></a></h3><p>多尺度建模指的是同时在多个细致层次下对系统进行模拟。有些模型可能在器官尺度运行，另一些模型可能在地块（plot）尺度运行。每个模型可以（如有需要）访问其本尺度以及其他尺度的变量，从而得到对系统更全面的表现。这种方法还可以帮助识别在单一层次下难以发现的新兴特征。</p><p>例如，可以在叶尺度下采用光合模型，与在植株尺度下的碳分配模型结合，以模拟植物的生长与发育。又如，模拟森林的能量平衡时，既需要针对植物的每一种器官类型的模型，也需要土壤层面的模型，最后还需有一个整合所有模型的地块（plot）尺度模型。</p><p>当进行多尺度模拟（即包含在植物不同器官层级上运行的模型）时，用户需要额外提供信息，以指明模型运行所需的尺度。由于有些模型在不同器官层级间复用，因此有必要说明每个模型所作用的器官（尺度）是什么。</p><p>这正是多尺度模拟会用到“映射（mapping）”结构的原因：单尺度示例中的 ModelList 没有办法将模型绑定到具体的植物器官，而那些更灵活的模型可以在多处被用到。用户还需要说明模型间如何跨尺度交互，比如输入变量若来自其他尺度，则必须指明其映射自哪个尺度。</p><p>你可以在这里了解作为用户针对单尺度与多尺度模拟的实际差异：<a href="../multiscale/multiscale_considerations.html#多尺度建模的注意事项">多尺度建模的注意事项</a>。</p><div class="admonition is-info" id="Note-e64cd6564182c421"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-e64cd6564182c421" title="Permalink"></a></header><div class="admonition-body"><p>当你遇到“单尺度模拟”（Single-scale simulations）或“ModelList 模拟”这样的术语时，它们均指“不具备多尺度映射的模拟”。多尺度模拟使用了器官/尺度之间的映射；而单尺度模拟则没有这种映射，仅使用更简单的 ModelList 接口。当然，你完全可以实现一个仅包含单一尺度层级的映射，这可称为“单尺度的多尺度模拟”。但<strong>除非特别说明，单尺度以及所有关于单尺度模拟的章节默认均指的是 ModelList 对象及无映射结构的模拟。</strong></p></div></div><h3 id="多尺度树图（MTG,-Multi-scale-Tree-Graphs）"><a class="docs-heading-anchor" href="#多尺度树图（MTG,-Multi-scale-Tree-Graphs）">多尺度树图（MTG, Multi-scale Tree Graphs）</a><a id="多尺度树图（MTG,-Multi-scale-Tree-Graphs）-1"></a><a class="docs-heading-anchor-permalink" href="#多尺度树图（MTG,-Multi-scale-Tree-Graphs）" title="Permalink"></a></h3><p><img src="../www/Grassy_plant_MTG_vertical.svg" alt="禾本科植物及其等价 MTG"/></p><p>一个禾本科植物与对应的 MTG</p><p>多尺度树图（Multi-scale Tree Graphs，简称 MTG）是一种用于表示植物结构的数据结构。有关 MTG 格式与属性的详细介绍，请参考 <a href="https://vezy.github.io/MultiScaleTreeGraph.jl/stable/the_mtg/mtg_concept/">MultiScaleTreeGraph.jl 软件包文档</a>。</p><p>多尺度模拟可以直接在 MTG 对象上操作；随着植物生长、产生新器官，将会向 MTG 添加对应的新节点。</p><p>你可以在 REPL 中直接输入 MTG 的变量名，获得其基本的信息展示：</p><p><img src="../www/MTG_output.png" alt="在 PlantSimEngine 中 MTG 展示的例子"/></p><div class="admonition is-info" id="Note-6f73c3a8979f1ddf"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-6f73c3a8979f1ddf" title="Permalink"></a></header><div class="admonition-body"><p>另一个配套包 <a href="https://github.com/VEZY/PlantGeom.jl">PlantGeom.jl</a> 也可以通过 .opf 文件（对应 <a href="https://amap-dev.cirad.fr/projects/xplo/wiki/The_opf_format_(*opf)">Open Plant Format</a>，用于计算机上描述植物的另一种格式）来创建 MTG 对象。</p></div></div><h4 id="尺度-/-符号（symbol）术语的混淆"><a class="docs-heading-anchor" href="#尺度-/-符号（symbol）术语的混淆">尺度 / 符号（symbol）术语的混淆</a><a id="尺度-/-符号（symbol）术语的混淆-1"></a><a class="docs-heading-anchor-permalink" href="#尺度-/-符号（symbol）术语的混淆" title="Permalink"></a></h4><p>多尺度树图（MTG）中的一些术语与 PlantSimEngine 不完全相同（参见 <a href="key_concepts.html#器官-/-尺度（Organ/Scale）">器官 / 尺度（Organ/Scale）</a>）：</p><ul><li>MTG 节点的 <strong>symbol（符号）</strong> 指代像 &quot;Plant&quot;、&quot;Root&quot;、&quot;Scene&quot; 或 &quot;Leaf&quot; 这样的实体。它对应 PlantSimEngine 中的 <em>尺度</em>，与 Julia 语言中 <code>:var</code> 这种符号类型没有关系。</li><li>MTG 节点的 <strong>scale（尺度）</strong> 是传递给 Node 构造器的一个整数，用于描述树图对象的描述层级。它与 symbol（或 PlantSimEngine 的尺度）通常不是一一对应的，但二者是类似的概念。</li></ul><p><img src="../www/Grassy_plant_scales.svg" alt="MTG 上的三级尺度，与 PlantSimEngine 中尺度概念不同"/></p><p>你可以在 <a href="https://vezy.github.io/MultiScaleTreeGraph.jl/stable/the_mtg/mtg_concept/#Node-MTG-and-attributes">这里</a> 找到对 MTG 概念的简要介绍。</p><p>另外，某些词在不同语境下也常被复用且含义不同：比如 tree/leaf/root 在谈论计算机科学数据结构（如图、依赖图、树结构）时意义与生物学不同。</p><div class="admonition is-info" id="Note-c974bd60a89793e3"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-c974bd60a89793e3" title="Permalink"></a></header><div class="admonition-body"><p>在绝大多数情况下，你可以假定带有 “tree（树）” 的术语指的是生物学意义上的树，&quot;organ（器官）&quot; 指的是植物器官，而 “single-scale（单尺度）”、“multi-scale（多尺度）” 以及 “scale（尺度）” 则指的是 PlantSimEngine 中 <a href="key_concepts.html#器官-/-尺度（Organ/Scale）">器官 / 尺度（Organ/Scale）</a> 章节介绍的尺度概念。MTG 对象一般以每个节点（指图中的节点，不是生物学器官节点）为操作单元进行处理。仅当模型涉及 MTG 遍历相关函数时，才通常会用到计算机科学里数据结构的术语。</p></div></div><h4 id="TLDR"><a class="docs-heading-anchor" href="#TLDR">TLDR</a><a id="TLDR-1"></a><a class="docs-heading-anchor-permalink" href="#TLDR" title="Permalink"></a></h4><p>总结如下：</p><ul><li>在 PlantSimEngine 中，&quot;尺度&quot; 指的是用名称（<code>String</code>）定义的描述层级；而在 MTG 中，&quot;尺度&quot; 是一个表示节点描述层级的整数，&quot;符号（symbol）&quot; 是该节点的名称。因此，MTG 中的 symbol 通常等价于 PlantSimEngine 中的 scale；</li><li>“节点（node）”一词总是指多尺度树图（MTG）中的节点，而不是植物学意义上的“节”。</li></ul><h3 id="状态机"><a class="docs-heading-anchor" href="#状态机">状态机</a><a id="状态机-1"></a><a class="docs-heading-anchor-permalink" href="#状态机" title="Permalink"></a></h3><p>状态机是建模各种机制和装置的经典计算模型，这一点对于你的模拟也许有参考价值。</p><p><img src="../www/Turnstile_state_machine_colored.svg.png" alt="State machine image"/> 一个简单的状态机。更多示例可参见 <a href="https://en.wikipedia.org/wiki/Finite-state_machine">维基百科页面</a>。</p><p>状态机可以用于描述器官的状态：在 <a href="https://github.com/PalmStudio/XPalm.jl">XPalm.jl</a>（一个基于 PlantSimEngine 建模油棕榈的包）中，部分器官有一个类似状态机的 <code>state</code> 变量，用于表示该器官是否为成熟、已修剪、开花等状态。</p><p>你可以在 XPalm 油棕 FSPM 的<a href="https://github.com/PalmStudio/XPalm.jl/blob/main/src/plant/phytomer/phytomer/state.jl">此处</a>找到一个根据器官年龄和积温对 <code>state</code> 变量进行改变的模型示例（以及其他类似模型）。</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="installing_plantsimengine.html">« PlantSimEngine 的安装与运行</a><a class="docs-footer-nextpage" href="julia_basics.html">Julia 语言基础 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Saturday 10 January 2026 19:42">Saturday 10 January 2026</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
