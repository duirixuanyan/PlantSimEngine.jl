var documenterSearchIndex = {"docs":
[{"location":"multiscale/single_to_multiscale.html#将单尺度模拟转换为多尺度模拟","page":"单尺度模型转换为多尺度","title":"将单尺度模拟转换为多尺度模拟","text":"只需提供一个简单的多尺度树图（multi-scale tree graph），并声明一个将所有模型关联到唯一尺度层级的映射，就可以把单尺度模拟“伪”转变为多尺度模拟。\n\n本页将演示如何完成该转换，并在此基础上添加一个新的尺度上的模型，从而使模拟真正实现多尺度。\n\n完整的示例脚本可在 examples 文件夹找到，点击此处查看\n\nPages = [\"single_to_multiscale.md\"]\nDepth = 3","category":"section"},{"location":"multiscale/single_to_multiscale.html#将-ModelList-转换为多尺度映射","page":"单尺度模型转换为多尺度","title":"将 ModelList 转换为多尺度映射","text":"例如，让我们回到模型切换小节中提到的 ModelList，该模型组合了光截获模型、叶面积指数模型和碳生物量增长模型：\n\nusing PlantMeteo\nusing PlantSimEngine\nusing PlantSimEngine.Examples\nusing CSV\n\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n\nmodels_singlescale = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    ToyRUEGrowthModel(0.2),\n    status=(TT_cu=cumsum(meteo_day.TT),),\n)\n\noutputs_singlescale = run!(models_singlescale, meteo_day)\n\n这些模型都作用于单个植株的简化模型，没有任何器官级的局部信息。因此我们可以认为它们都工作在“整株植物”这个尺度上。其变量同样都在 “Plant” 这一尺度下运行，因此不需要映射到其他尺度。\n\n因此，我们可以将其转换为如下的映射关系：\n\nmapping = Dict(\n\"Plant\" => (\n   ToyLAIModel(),\n    Beer(0.5),\n    ToyRUEGrowthModel(0.2),\n    Status(TT_cu=cumsum(meteo_day.TT),)\n    ),\n)\n\n注意，这里 Status 的写法与之前略有不同。这是出于实现上的原因（请见谅）。","category":"section"},{"location":"multiscale/single_to_multiscale.html#为植物图形引入新的包","page":"单尺度模型转换为多尺度","title":"为植物图形引入新的包","text":"上述模型同样没有在多尺度树图（multi-scale tree graph, MTG）上运行，也不存在器官的创建或生长的概念。但要进行多尺度模拟，我们还是必须为模型提供一个多尺度树图。因此，我们可以暂时声明一个非常简单的 MTG，仅包含一个节点：\n\nusing MultiScaleTreeGraph\n\nmtg = MultiScaleTreeGraph.Node(MultiScaleTreeGraph.NodeMTG(\"/\", \"Plant\", 0, 0),)\n\nnote: Note\n你需要将 MultiScaleTreeGraph 包添加到你的环境中。如果你对 Julia 还不熟悉或需要复习，请参见PlantSimEngine 的安装与运行。","category":"section"},{"location":"multiscale/single_to_multiscale.html#运行多尺度模拟？","page":"单尺度模型转换为多尺度","title":"运行多尺度模拟？","text":"到目前为止，我们已经准备好了进行多尺度模拟所需的几乎所有条件。\n\n这一步的转换可以作为更复杂多尺度模拟的起点。\n\n多尺度下 run! 函数的签名与 ModelList 版本略有不同：\n\nout_multiscale = run!(mtg, mapping, meteo_day)\n\n（一些可选参数的用法也会有所不同）\n\n但需要注意的是，目前在多尺度模式下通过 Status 字段传递向量依然可以实现，但需要对映射关系进行更深入的操作。这种机制实际上是动态生成了一个自定义模型，其实现还是实验性的，使用体验也不够友好。\n\n如果你仍然希望了解这种方式，可参考这里的详细示例，但不推荐初学者这么做。\n\n我们更推荐的做法，是编写你自己的模型，在每个时间步将积温（thermal time）作为变量输入，而不是用 Status 直接传递一个整体向量。\n\n这样，我们“伪多尺度”的初始方案就将转变为真正的多尺度模拟。","category":"section"},{"location":"multiscale/single_to_multiscale.html#添加第二个尺度","page":"单尺度模型转换为多尺度","title":"添加第二个尺度","text":"接下来，我们希望让一个模型为叶面积指数模型（Leaf Area Index Model）动态提供积温（Cumulated Thermal Time），而不是像之前那样通过 Status 直接初始化。\n\n因此，我们将实现自己的 ToyTT_cuModel 模型。","category":"section"},{"location":"multiscale/single_to_multiscale.html#TT_cu-模型的实现","page":"单尺度模型转换为多尺度","title":"TT_cu 模型的实现","text":"这个模型不需要任何外部数据或输入变量，它只依赖气象数据来输出我们期望的 TT_cu（积温）。其实现十分直接，也不需要复杂的模型耦合。\n\nPlantSimEngine.@process \"tt_cu\" verbose = false\n\nstruct ToyTt_CuModel <: AbstractTt_CuModel\nend\n\nfunction PlantSimEngine.run!(::ToyTt_CuModel, models, status, meteo, constants, extra=nothing)\n    status.TT_cu +=\n        meteo.TT\nend\n\nfunction PlantSimEngine.inputs_(::ToyTt_CuModel)\n    NamedTuple() # 没有任何输入变量\nend\n\nfunction PlantSimEngine.outputs_(::ToyTt_CuModel)\n    (TT_cu=0.0,)\nend\n\nnote: Note\n通过 status，在 run! 函数内部能够访问到的变量仅限于本层级（如 \"Scene\" 尺度）下定义的变量。这一点初看并不明显，但在开发模型或者将其用于不同尺度时非常重要。如果你需要访问其它尺度的变量，则必须通过 MultiScaleModel 进行变量映射，或者采用更复杂的耦合方式。","category":"section"},{"location":"multiscale/single_to_multiscale.html#将新的-TT_cu-模型关联到映射中的某个尺度","page":"单尺度模型转换为多尺度","title":"将新的 TT_cu 模型关联到映射中的某个尺度","text":"我们实现了自己的模型，接下来要在变量映射中将它加入。\n\n这个新模型其实与植物的任何特定器官都没有直接关联。实际上，它描述的并非植物的生理过程，而是影响其生理状态的环境驱动力。因此，我们可以让它运行在与植物结构无关的另一层级，这里我们称为“Scene”（场景）层级。这也是常见的做法。\n\n注意：我们现在需要在多尺度树图（MTG）中新增一个 \"Scene\" 节点，否则我们的模型不会被调用——因为没有其它模型会主动调用它，而 \"Plant\" 层级节点只会运行 \"Plant\" 层级下的模型。关于更多细节，参见 多尺度模拟中的空状态向量。\n\nmtg_multiscale = MultiScaleTreeGraph.Node(MultiScaleTreeGraph.NodeMTG(\"/\", \"Scene\", 0, 0),)\n    plant = MultiScaleTreeGraph.Node(mtg_multiscale, MultiScaleTreeGraph.NodeMTG(\"+\", \"Plant\", 1, 1))","category":"section"},{"location":"multiscale/single_to_multiscale.html#尺度间的变量映射：MultiScaleModel-包装器","page":"单尺度模型转换为多尺度","title":"尺度间的变量映射：MultiScaleModel 包装器","text":"先前我们是将积温（:TT_cu）作为一个模拟参数直接提供给 LAI 模型，但现在我们需要将其从“Scene”尺度映射过来。\n\n这实现的方法是将我们的 ToyLAIModel 包装在 MultiScaleModel 结构体中。 MultiScaleModel 需要两个关键字参数：model ，指明我们要映射变量的模型本体；mapped_variables ，用于指定变量与尺度之间的映射关系，以及变量的重命名（如有需要）。\n\n变量的映射方式有多种语法形式，但在本例中，我们只是将一个单变量（TT_cu 的单一数值）从 \"Scene\" 尺度传递到 \"Plant\" 尺度。\n\n因此，我们为 LAI 模型用 MultiScaleModel 包装的声明如下：\n\nMultiScaleModel(\n    model=ToyLAIModel(),\n    mapped_variables=[\n        :TT_cu => \"Scene\",\n    ],\n)\n\n而包含两个尺度的新变量映射如下：\n\nmapping_multiscale = Dict(\n    \"Scene\" => ToyTt_CuModel(),\n    \"Plant\" => (\n        MultiScaleModel(\n            model=ToyLAIModel(),\n            mapped_variables=[\n                :TT_cu => \"Scene\",\n            ],\n        ),\n        Beer(0.5),\n        ToyRUEGrowthModel(0.2),\n    ),\n)","category":"section"},{"location":"multiscale/single_to_multiscale.html#运行多尺度模拟","page":"单尺度模型转换为多尺度","title":"运行多尺度模拟","text":"在构建好拥有两个节点的 MTG 后，我们就可以运行多尺度模拟了：\n\noutputs_multiscale = run!(mtg_multiscale, mapping_multiscale, meteo_day)","category":"section"},{"location":"multiscale/single_to_multiscale.html#单尺度与多尺度输出的对比","page":"单尺度模型转换为多尺度","title":"单尺度与多尺度输出的对比","text":"输出的数据结构略有不同：多尺度输出是按照尺度进行索引的，并且每个变量对其所在尺度的每个节点都有一个对应的数值（例如，对于每一片叶子都会有一个 \"leaf_surface\" 的值），这些值以数组形式存储。\n\n在我们这个简单的例子中，只有一个 MTG 场景节点和一个植株节点，因此每个变量在多尺度输出中的数组都只包含一个数值。\n\n我们可以通过索引多尺度输出，访问 \"Scene\" 尺度下的输出变量：\n\noutputs_multiscale[\"Scene\"]\n\n这里得到的是一个 Vector{NamedTuple} 结构。而对应的单尺度输出则是一个 Vector{T}：\n\noutputs_singlescale.TT_cu\n\n让我们提取多尺度的 :TT_cu：\n\ncomputed_TT_cu_multiscale = [outputs_multiscale[\"Scene\"][i].TT_cu for i in 1:length(outputs_multiscale[\"Scene\"])]\n\n现在我们可以一一对比它们的值，并做近似相等的判断：\n\nfor i in 1:length(computed_TT_cu_multiscale)\n    if !(computed_TT_cu_multiscale[i] ≈ outputs_singlescale.TT_cu[i])\n        println(i)\n    end\nend\n\n或者，也可以用广播操作实现同样的比较：\n\nis_approx_equal = length(unique(computed_TT_cu_multiscale .≈ outputs_singlescale.TT_cu)) == 1\n\nnote: Note\n你可能会疑惑为什么我们要用近似相等判断而不是严格相等。原因是浮点数累积误差造成的，这一问题在浮点数注意事项中有更详细的讨论。","category":"section"},{"location":"multiscale/single_to_multiscale.html#ToyDegreeDaysCumulModel","page":"单尺度模型转换为多尺度","title":"ToyDegreeDaysCumulModel","text":"有一个模型 ToyDegreeDaysCumulModel 可以根据气温数据生成积温，该模型可以在 examples 文件夹中找到。\n\n本例中我们没有使用它，是为了教学的简单性。此外，该模型用默认参数计算得到的积温，与本例天气数据中给出的积温并不一致，因此如果不调整参数，计算结果也会不同。","category":"section"},{"location":"troubleshooting_and_testing/downstream_tests.html#自动化测试：下游依赖检查","page":"自动化测试","title":"自动化测试：下游依赖检查","text":"PlantSimEngine 是在 Github 上开源的，其它相关配套包也同样开源，如 PlantGeom.jl、PlantMeteo.jl、PlantBioPhysics.jl、MultiScaleTreeGraph.jl 和 XPalm。\n\n这些包都实现了很方便的 CI（持续集成）功能：自动化集成与下游测试。当某一个包发生更改时，系统会自动测试所有已知的下游依赖包，以确保没有引入破坏性的更改。\n\n例如，PlantBioPhysics 依赖于 PlantSimEngine，因此集成测试会在 PlantSimEngine 发布新版本后，自动检测 PlantBioPhysics 的测试是否会意外失败。同时，下游测试中还包括基准性能测试，详情可见：[https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/main/test/downstream/test-plantbiophysics.jl]\n\n如果您希望基于 PlantSimEngine 进行开发，也可以利用这一功能。只需告知我们您的包名（或在 Pull Request 中将其加入 CI 的 yml 文件），我们即可将其加入下游测试列表中，并在有破坏性更改时自动生成相关 PR 通知您。","category":"section"},{"location":"working_with_data/inputs.html#输入类型","page":"输入类型","title":"输入类型","text":"run! 通常需要两个输入：一个 ModelList 和气象数据。气象数据一般可以使用 Atmosphere 表示单个时间步，也可以用 TimeStepTable{Atmosphere} 表示多个时间步的数据。ModelList 也可以用单个元素、向量或字典的形式传递。\n\nrun! 能够根据 PlantSimEngine.DataFormat trait 处理这些数据格式（想了解 trait 的更多信息请参见这篇博客）。例如，我们可以通过实现如下 trait 告诉 PlantSimEngine，TimeStepTable 应被当作表格处理：\n\nDataFormat(::Type{<:PlantMeteo.TimeStepTable}) = TableAlike()\n\n如果你有其他格式的气象输入数据，可以为它实现新的 trait。例如，如果你有一个类似表格的数据格式，可以这样实现：\n\nDataFormat(::Type{<:MyTableFormat}) = TableAlike()\n\n还有另外两种 trait 可供选择：SingletonAlike 适用于仅代表单个时间步的数据格式，TreeAlike 适用于树状结构，目前用于 MultiScaleTreeGraphs 的节点（目前不是通用型）。","category":"section"},{"location":"working_with_data/inputs.html#新输入类型的特殊注意事项","page":"输入类型","title":"新输入类型的特殊注意事项","text":"如果你希望自定义输入数据格式，需要根据自身用例确保实现了相关的方法。\n\n例如，如果你的模型需要从不同时间步获取数据（例如 需要获取前一天的温度），则必须确保可以从当前时间步访问其他时间步的数据。\n\n为此，你需要为定义行的结构体实现以下方法：\n\nBase.parent：返回该行所属的父表，例如完整的 DataFrame\nPlantMeteo.rownumber：返回该行在父表中的行号，例如在 DataFrame 中的行号\n（可选）PlantMeteo.row_from_parent(row, i)：从父表返回第 i 行，例如在 DataFrame 中的第 i 行。如果你追求高性能才需要实现，默认会调用 Tables.rows(parent(row))[i]。\n\ncompat: Compat\nPlantMeteo.rownumber 是临时方案。未来会被 DataAPI.rownumber 替代，后者也会被 DataFrames.jl 等包采用。详见 这个 Pull Request。","category":"section"},{"location":"working_with_data/inputs.html#使用气象数据","page":"输入类型","title":"使用气象数据","text":"下面是一个展示如何导出示例气象数据到自定义文件的简单例子：\n\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\nPlantMeteo.write_weather(\"examples/meteo_day.csv\", meteo_day, duration = Dates.Day)\n\n如果你希望过滤、重塑、调整或写出天气数据，可以参考 PlantMeteo 的 API 文档，内有更多示例。","category":"section"},{"location":"troubleshooting_and_testing/tips_and_workarounds.html#提示与变通方法","page":"技巧与常见问题","title":"提示与变通方法","text":"","category":"section"},{"location":"troubleshooting_and_testing/tips_and_workarounds.html#PlantSimEngine-正在积极开发中","page":"技巧与常见问题","title":"PlantSimEngine 正在积极开发中","text":"尽管 PlantSimEngine 的代码库略显抽象，且目标是在模拟上具备一定通用性，但其设计基础依然贴近实际应用。我们确实希望能够适应多种类型的模拟，并尽量不对用户作过多限制。不过，大多数功能都是根据实际需求逐步开发的，其中不少是出于对油棕模型 XPalm 这一日益复杂、细致实现的需要。\n\n由于油棕模型仍在持续开发中，并且部分功能尚未在 PlantSimEngine 中实现，或者需要大规模重写（而我们不确定这样做是否值得，尤其是如果结果反而限制了代码库或用户的可操作性），因此偶尔会通过一些变通方法或者取巧手段来规避限制造成的问题。\n\n此外，还有一些功能是为了方便快速原型开发，临时实现的“小黑客”方案，并非面向生产环境。\n\n我们会在这里列出一些相关实例，未来也可能补充列出包的内在限制或隐性的设计预期。\n\nPages = [\"tips_and_workarounds.md\"]\nDepth = 2","category":"section"},{"location":"troubleshooting_and_testing/tips_and_workarounds.html#多尺度模拟中利用历史状态的方法","page":"技巧与常见问题","title":"多尺度模拟中利用历史状态的方法","text":"在多尺度模拟中，可以通过映射 API（mapping API）中的 PreviousTimeStep 机制，获取变量在上一个仿真步（timestep）的值（事实上，正如其他部分所提，这也是打破模型耦合时出现环形依赖的默认方法，参见：避免循环依赖）。\n\n但通过映射 API，目前无法获取距离当前时刻更早的历史时刻。例如，像 PreviousTimeStep(PreviousTimeStep(PreviousTimeStep(:carbon_biomass))) 这样的写法是不被支持的，请勿这样做。\n\n如果确实需要访问更早的状态，可以写一个自定义模型，将所需的历史值存入数组或其他自定义变量中，每个时间步进行更新，并提供给其他需要用到这些历史信息的模型使用。","category":"section"},{"location":"troubleshooting_and_testing/tips_and_workarounds.html#模型中变量不能同时作为输入和输出","page":"技巧与常见问题","title":"模型中变量不能同时作为输入和输出","text":"PlantSimEngine 的一个现有限制是：不支持在同一个模型中，同时将某个变量作为输入和输出使用。\n\n（相关说明：在同一尺度下，也无法存在两个同名变量，它们会被判定为同一个变量。）\n\n原因在于，对于这种情况下模型间的依赖关系，系统无法自动判断依赖耦合如何处理。如果允许这样做，用户就必须显式声明多个模型之间的模拟顺序，而实现该功能也需要不少编程工作来扩展 PlantSimEngine 的 API。\n\n我们目前还没有找到一种在代码简单性和 API 便利性之间都令人满意的解法。尤其在快速原型开发和不断添加新模型时，这种约束往往意味着需要针对相关变量重新指定模拟顺序，比较繁琐。\n\n目前有两种变通方法：\n\n一种可能略显笨拙的方式是：将其中一个变量重命名。这样虽然不能直接“开箱即用”某些预设模型，但避免了以上限制和复杂性。\n在许多情形下，可以灵活使用 PlantSimEngine 已有的功能安排。\n\n比如，XPalm.jl 中有一个叶片修剪（leaf pruning）相关模型，会影响生物量。在理想情况下，可以将 leaf_biomass 变量同时作为输入和输出。而实际采用的方案，则是输出一个 leaf_biomass_pruning_loss 变量，在下一个时间步再以此作为输入来计算新的叶生物量。\n\n又比如，Toy Plant 教程 第 3 部分 中，碳库变量 carbon_stock 用于表示可用于根和节间生长的碳，但在模型编排中，并不是直接更新和传递该变量，而是让根生长决策模型先计算 carbon_stock_updated_after_roots，然后供节间增长模型使用。\n\n这种设计改进既避免了模型间顺序的不确定性，也提高了代码的可读性，并充分体现了 PlantSimEngine 的的设计哲学。","category":"section"},{"location":"troubleshooting_and_testing/tips_and_workarounds.html#multiscale_vector","page":"技巧与常见问题","title":"多尺度：在指定层级的 mapping status 中传递向量","text":"note: Note\n本节内容较为高级，不推荐初学者使用\n\n你可能已经注意到，在文档示例中，有时会将一个向量（一维数组）变量直接传递给 ModelList 的 status 组件（比如在累计温度的例子中：模型切换）。\n\n这种做法适用于简单模拟或快速原型开发，可以避免为了此类参数专门编写模型。每次迭代时，相关模型会获得一个对应当前时间步的元素。\n\n在多尺度模拟中，也支持这一特性，尽管不是主 API 的一部分。由于输出与状态变量的工作方式有所不同，这个小便利特性并不那么直接可以使用。\n\n此功能较为脆弱，依赖不推荐的 Julia 元编程方式（如 eval()），对全局变量有操作，并且可能无法在 REPL 之外的环境中稳定工作，也没有针对复杂交互进行测试。因此在涉及不同尺度变量映射、奇特依赖结构的情况下可能出现问题。\n\n由于实现细节上的原因，正确用法如下：\n\n你需要调用 replace_mapping_status_vectors_with_generated_models(mapping_with_vectors_in_status, timestep_model_organ_level, nsteps) 这个函数，并作用在你的 mapping 上。\n\n它会分析 mapping，生成自定义模型，在每个时间步存储并传递向量的值，并返回可用于模拟的新 mapping。此外，会自动插入两个内部模型用于向这些模型提供时间步索引（这意味着在 mapping 中会声明 :current_timestep 和 :next_timestep 这两个符号）。你可以通过 timestep_model_organ_level 参数指定这些模型所在的尺度/器官层级。参数 nsteps 作为校验，会要求你提供模拟的时间步数。\n\nwarning: Warning\n只有 AbstractVector 的子类会被此机制处理。有时气象数据的向量需要类型转换。例如：meteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\nstatus(TT_cu=cumsum(meteo_day.TT),)```\n\ncumsum(meteo_day.TT) actually returns a CSV.SentinelArray.ChainedVectors{T, Vector{T}}, which is not a subtype of AbstractVector. \nReplacing it with Vector(cumsum(meteo_day.TT)) will provide an adequate type.\n\n下面是一个用法示例，修正了 将单尺度模拟转换为多尺度模拟 的初步尝试：\n\nusing PlantSimEngine\nusing PlantSimEngine.Examples\nusing PlantMeteo, CSV, DataFrames\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n\n# 单尺度模拟的直接翻译\nmapping_pseudo_multiscale = Dict(\n\"Plant\" => (\n   ToyLAIModel(),\n    Beer(0.5),\n    ToyRUEGrowthModel(0.2),\n    Status(TT_cu=cumsum(meteo_day.TT),)\n    ),\n)\n\nmtg = MultiScaleTreeGraph.Node(MultiScaleTreeGraph.NodeMTG(\"/\", \"Plant\", 1, 0),)\n\n# 在多尺度模拟中，直接将向量传递到 Status 会报错\n#out_pseudo_multiscale_error = run!(mtg, mapping_pseudo_multiscale, meteo_day)\n\nmapping_pseudo_multiscale_adjusted = PlantSimEngine.replace_mapping_status_vectors_with_generated_models(mapping_pseudo_multiscale, \"Plant\", PlantSimEngine.get_nsteps(meteo_day))\n\nout_pseudo_multiscale_successful = run!(mtg, mapping_pseudo_multiscale_adjusted, meteo_day)\n\n\n该功能在涉及未来计划引入的新特性（如多时间步模型混用等）的模拟中很可能失效，并且无法保证能及时修复。再次提醒，这主要是多尺度模拟原型开发时的便利捷径，使用时请注意风险。","category":"section"},{"location":"troubleshooting_and_testing/tips_and_workarounds.html#单尺度仿真中的循环依赖问题","page":"技巧与常见问题","title":"单尺度仿真中的循环依赖问题","text":"在单尺度仿真中有可能出现循环依赖的情况，但目前尚未支持 PreviousTimestep 功能。可以通过引入硬依赖进行处理，或者构建一个实际仅包含单一尺度的多尺度仿真作为替代方案。","category":"section"},{"location":"step_by_step/implement_a_process.html#实现一个新过程","page":"实现一个过程","title":"实现一个新过程","text":"","category":"section"},{"location":"step_by_step/implement_a_process.html#引言","page":"实现一个过程","title":"引言","text":"在本软件包中，\"过程\"用于定义某种生物或物理现象。你可以将过程理解为系统中发生的任何现象，比如光拦截、光合作用、水分、碳和能量通量、生长、产量，甚至太阳能电池板产生的电力等。\n\nPlantSimEngine.jl 的设计使得新过程和模型的实现变得简单而迅速。下一节将通过一个简单示例（生长模型的实现）展示如何实现一个新的过程。","category":"section"},{"location":"step_by_step/implement_a_process.html#实现一个过程","page":"实现一个过程","title":"实现一个过程","text":"过程需要先“声明”，也就是说我们需要先定义一个过程，然后才能为其实现相应的模型。声明过程会自动为该过程的仿真生成一些样板代码：\n\n一个用于该过程的抽象类型\n一个内部使用的 process 函数方法\n\n这个抽象过程类型会作为所有与该过程相关的模型实现的超类型，其命名方式为 Abstract<process_name>Process，例如：AbstractLight_InterceptionModel。\n\n幸运的是，PlantSimEngine 提供了一个宏 @process，可以一次性自动生成上述内容。这个宏只需要一个参数：过程名称。\n\n例如，在 PlantBiophysics.jl 中，光合作用过程的声明只需这样一句代码：\n\n@process \"photosynthesis\"\n\n如果我们想模拟植物的生长，可以添加一个名为 growth 的新过程：\n\n@process \"growth\"\n\n就是这样！注意，该函数还会引导你在创建过程后可以进行的后续步骤。","category":"section"},{"location":"step_by_step/implement_a_process.html#为过程实现一个新模型","page":"实现一个过程","title":"为过程实现一个新模型","text":"在实现过程之后，你可以为该过程编写相应的模型实现。展示光拦截模型实现的教程页面可以在这里找到。\n\n本过程的完整模型实现可参见示例脚本 ToyAssimGrowthModel.jl。","category":"section"},{"location":"step_by_step/implement_a_process.html#under_the_hood","page":"实现一个过程","title":"幕后原理","text":"@process 宏实际上只是用来减少样板代码的快捷方式。\n\n你也可以不使用宏，手动定义一个过程：只需定义一个继承自 AbstractModel 的抽象类型：\n\nabstract type AbstractGrowthModel <: PlantSimEngine.AbstractModel end\n\n然后为 process_ 函数增加一个方法，使其返回过程的名称：\n\nPlantSimEngine.process_(::Type{AbstractGrowthModel}) = :growth\n\n因此，在前面的例子中，我们创建了一个名为 growth 的新过程。这会自动定义一个名为 AbstractGrowthModel 的抽象结构体，它作为所有相关模型的超类型。抽象类型的命名规则是：把过程名称转换为首字母大写（使用 titlecase()），前面加 Abstract，后面加 Model 作为后缀。","category":"section"},{"location":"multiscale/multiscale_example_2.html#扩展多尺度模拟","page":"拓展植株模拟","title":"扩展多尺度模拟","text":"让我们在前一个示例的基础上，增加一些新的器官生长，并在两者之间引入非常轻微的耦合。\n\n本节完整模拟脚本可在 examples 文件夹下的 ToyMultiScalePlantModel 子目录中找到。\n\nPages = [\"multiscale_example_2.md\"]\nDepth = 3","category":"section"},{"location":"multiscale/multiscale_example_2.html#初始化设置","page":"拓展植株模拟","title":"初始化设置","text":"同样，确保已正确设置好 Julia 环境：\n\nusing PlantSimEngine\nusing PlantSimEngine.Examples\nusing PlantMeteo\nusing MultiScaleTreeGraph\nusing CSV, DataFrames\n\nPlantSimEngine.@process \"leaf_carbon_capture\" verbose = false\n\nstruct ToyLeafCarbonCaptureModel<: AbstractLeaf_Carbon_CaptureModel end\n\nfunction PlantSimEngine.inputs_(::ToyLeafCarbonCaptureModel)\n    NamedTuple() # 无需输入\nend\n\nfunction PlantSimEngine.outputs_(::ToyLeafCarbonCaptureModel)\n    (carbon_captured=0.0,)\nend\n\nfunction PlantSimEngine.run!(::ToyLeafCarbonCaptureModel, models, status, meteo, constants, extra)   \n    status.carbon_captured = 40\nend\n\nfunction get_n_leaves(node::MultiScaleTreeGraph.Node)\n    root = MultiScaleTreeGraph.get_root(node)\n    nleaves = length(MultiScaleTreeGraph.traverse(root, x->1, symbol=\"Leaf\"))\n    return nleaves\nend","category":"section"},{"location":"multiscale/multiscale_example_2.html#给植物添加根","page":"拓展植株模拟","title":"给植物添加根","text":"我们将为植物添加一个根，该根能够吸收水分并将其加入到水分库中。由于初始水分存量较低，因此会优先进行根的生长，之后植物像之前一样同时生长叶片和新的节间。根的生长有最大长度限制，且不会分枝。\n\n这导致我们需要在映射中加入一个新的尺度 \"Root\"，并新增两个模型：一个用于水分吸收，一个用于根生长。同时，为了考虑水分，其他的一些模型也需要进行相应的更新。碳捕获模型保持不变，get_n_leaves 这个辅助函数同样无需修改。","category":"section"},{"location":"multiscale/multiscale_example_2.html#根系相关的模型","page":"拓展植株模拟","title":"根系相关的模型","text":"","category":"section"},{"location":"multiscale/multiscale_example_2.html#水分吸收","page":"拓展植株模拟","title":"水分吸收","text":"让我们实现一个非常简化的根系水分吸收模型。该模型通过天气数据中的降水量，并乘以某个吸收系数，计算根系吸收的水分量。\n\nPlantSimEngine.@process \"water_absorption\" verbose = false\n\nstruct ToyWaterAbsorptionModel <: AbstractWater_AbsorptionModel\nend\n\nPlantSimEngine.inputs_(::ToyWaterAbsorptionModel) = (root_water_assimilation=1.0,)\nPlantSimEngine.outputs_(::ToyWaterAbsorptionModel) = (water_absorbed=0.0,)\n\nfunction PlantSimEngine.run!(m::ToyWaterAbsorptionModel, models, status, meteo, constants=nothing, extra=nothing)\n    status.water_absorbed = meteo.Precipitations * status.root_water_assimilation\nend","category":"section"},{"location":"multiscale/multiscale_example_2.html#根生长","page":"拓展植株模拟","title":"根生长","text":"根生长模型与节间生长模型类似：它会检查水分是否低于阈值，并确保碳存量足够。当根的总长度尚未达到最大值时，会在MTG中添加一个新的器官。\n\n同时，也会用到两个辅助函数：分别用于寻找根的末端，并计算根的长度：\n\nfunction get_root_end_node(node::MultiScaleTreeGraph.Node)\n    root = MultiScaleTreeGraph.get_root(node)\n    return MultiScaleTreeGraph.traverse(root, x->x, symbol=\"Root\", filter_fun = MultiScaleTreeGraph.isleaf)\nend\n\nfunction get_roots_count(node::MultiScaleTreeGraph.Node)\n    root = MultiScaleTreeGraph.get_root(node)\n    return length(MultiScaleTreeGraph.traverse(root, x->x, symbol=\"Root\"))\nend\n\nPlantSimEngine.@process \"root_growth\" verbose = false\n\nstruct ToyRootGrowthModel{T} <: AbstractRoot_GrowthModel\n    water_threshold::T\n    carbon_root_creation_cost::T\n    root_max_len::Int\nend\n\nPlantSimEngine.inputs_(::ToyRootGrowthModel) = (water_stock=0.0,carbon_stock=0.0,)\nPlantSimEngine.outputs_(::ToyRootGrowthModel) = (carbon_root_creation_consumed=0.0,)\n\nfunction PlantSimEngine.run!(m::ToyRootGrowthModel, models, status, meteo, constants=nothing, extra=nothing)\n    if status.water_stock < m.water_threshold && status.carbon_stock > m.carbon_root_creation_cost\n        \n        root_end = get_root_end_node(status.node)\n        \n        if length(root_end) != 1 \n            throw(AssertionError(\"未能找到符号为\\\"Root\\\"的MTG叶节点\"))\n        end\n        root_len = get_roots_count(root_end[1])\n        if root_len < m.root_max_len\n            st = add_organ!(root_end[1], extra, \"<\", \"Root\", 2, index=1)\n            status.carbon_root_creation_consumed = m.carbon_root_creation_cost\n        end\n    else\n        status.carbon_root_creation_consumed = 0.0\n    end\nend","category":"section"},{"location":"multiscale/multiscale_example_2.html#更新其他模型以考虑水分","page":"拓展植株模拟","title":"更新其他模型以考虑水分","text":"","category":"section"},{"location":"multiscale/multiscale_example_2.html#资源存储","page":"拓展植株模拟","title":"资源存储","text":"吸收的水分现在需要被累积，并且还需考虑根系碳创建的消耗。\n\nPlantSimEngine.@process \"resource_stock_computation\" verbose = false\n\nstruct ToyStockComputationModel <: AbstractResource_Stock_ComputationModel\nend\n\nPlantSimEngine.inputs_(::ToyStockComputationModel) = \n(water_absorbed=0.0, carbon_captured=0.0, carbon_organ_creation_consumed=0.0, carbon_root_creation_consumed=0.0)\n\nPlantSimEngine.outputs_(::ToyStockComputationModel) = (water_stock=-Inf, carbon_stock=-Inf)\n\nfunction PlantSimEngine.run!(m::ToyStockComputationModel, models, status, meteo, constants=nothing, extra=nothing)\n    status.water_stock += sum(status.water_absorbed)\n    status.carbon_stock += sum(status.carbon_captured) - sum(status.carbon_organ_creation_consumed) - sum(status.carbon_root_creation_consumed)\nend","category":"section"},{"location":"multiscale/multiscale_example_2.html#节间生长","page":"拓展植株模拟","title":"节间生长","text":"这里的小改动是：新器官的创建现在只有在水分库存高于给定阈值时才会发生。\n\nstruct ToyCustomInternodeEmergence{T} <: AbstractOrgan_EmergenceModel\n    TT_emergence::T\n    carbon_internode_creation_cost::T\n    leaf_surface_area::T\n    leaves_max_surface_area::T\n    water_leaf_threshold::T\nend\n\nToyCustomInternodeEmergence(;TT_emergence=300.0, carbon_internode_creation_cost=200.0, leaf_surface_area=3.0,leaves_max_surface_area=100.0,\nwater_leaf_threshold=30.0) = ToyCustomInternodeEmergence(TT_emergence, carbon_internode_creation_cost, leaf_surface_area, leaves_max_surface_area, water_leaf_threshold)\n\nPlantSimEngine.inputs_(m::ToyCustomInternodeEmergence) = (TT_cu=0.0,water_stock=0.0, carbon_stock=0.0)\nPlantSimEngine.outputs_(m::ToyCustomInternodeEmergence) = (TT_cu_emergence=0.0, carbon_organ_creation_consumed=0.0)\n\nfunction PlantSimEngine.run!(m::ToyCustomInternodeEmergence, models, status, meteo, constants=nothing, sim_object=nothing)\n\n    leaves_surface_area = m.leaf_surface_area * get_n_leaves(status.node)\n    status.carbon_organ_creation_consumed = 0.0\n\n    if leaves_surface_area > m.leaves_max_surface_area\n        return nothing\n    end\n    \n    # 如果水分库存不足，则优先生长根系，节间和叶不会发生\n    if status.water_stock < m.water_leaf_threshold\n        return nothing\n    end\n\n    # 如果碳库存不足，不发生新器官生成\n    if status.carbon_stock < m.carbon_internode_creation_cost\n        return nothing\n    end\n  \n    if length(MultiScaleTreeGraph.children(status.node)) == 2 && \n        status.TT_cu - status.TT_cu_emergence >= m.TT_emergence            \n        status_new_internode = add_organ!(status.node, sim_object, \"<\", \"Internode\", 2, index=1)\n        add_organ!(status_new_internode.node, sim_object, \"+\", \"Leaf\", 2, index=1)\n        add_organ!(status_new_internode.node, sim_object, \"+\", \"Leaf\", 2, index=1)\n\n        status_new_internode.TT_cu_emergence = m.TT_emergence - status.TT_cu\n        status.carbon_organ_creation_consumed = m.carbon_internode_creation_cost\n    end\n\n    return nothing\nend","category":"section"},{"location":"multiscale/multiscale_example_2.html#更新映射关系","page":"拓展植株模拟","title":"更新映射关系","text":"资源储存和节间生成模型现在需要额外几个与水分相关的映射变量。 “根（Root）”器官被加入到映射中，并配有其专属模型。同时需要初始化一些新的参数。\n\nmapping = Dict(\n\"Scene\" => ToyDegreeDaysCumulModel(),\n\"Plant\" => (\n    MultiScaleModel(\n        model=ToyStockComputationModel(),          \n        mapped_variables=[\n            :carbon_captured=>[\"Leaf\"],\n            :water_absorbed=>[\"Root\"],\n            :carbon_root_creation_consumed=>[\"Root\"],\n            :carbon_organ_creation_consumed=>[\"Internode\"]\n\n        ],\n        ),\n        Status(water_stock = 0.0, carbon_stock = 0.0)\n    ),\n\"Internode\" => (        \n        MultiScaleModel(\n        model=ToyCustomInternodeEmergence(), # TT_emergence=20.0\n        mapped_variables=[\n            :TT_cu => \"Scene\",\n            PreviousTimeStep(:water_stock)=>\"Plant\",\n            PreviousTimeStep(:carbon_stock)=>\"Plant\"\n        ],\n        ),        \n        Status(carbon_organ_creation_consumed=0.0),\n    ),\n\"Root\" => (\n        MultiScaleModel(\n        model=ToyRootGrowthModel(10.0, 50.0, 10),\n        mapped_variables=[\n            PreviousTimeStep(:carbon_stock)=>\"Plant\",\n            PreviousTimeStep(:water_stock)=>\"Plant\"\n        ],\n        ),       \n        ToyWaterAbsorptionModel(),\n        Status(carbon_root_creation_consumed=0.0, root_water_assimilation=1.0),\n    ),\n\"Leaf\" => ( ToyLeafCarbonCaptureModel(),),\n)","category":"section"},{"location":"multiscale/multiscale_example_2.html#运行模拟","page":"拓展植株模拟","title":"运行模拟","text":"运行这个新的模拟过程和之前几乎一样。气象数据没有变化，但是在MTG中新增了一个“Root（根）”节点。\n\nmtg = MultiScaleTreeGraph.Node(MultiScaleTreeGraph.NodeMTG(\"/\", \"Scene\", 1, 0))   \n    plant = MultiScaleTreeGraph.Node(mtg, MultiScaleTreeGraph.NodeMTG(\"+\", \"Plant\", 1, 1))\n    \n    internode1 = MultiScaleTreeGraph.Node(plant, MultiScaleTreeGraph.NodeMTG(\"/\", \"Internode\", 1, 2))\n    MultiScaleTreeGraph.Node(internode1, MultiScaleTreeGraph.NodeMTG(\"+\", \"Leaf\", 1, 2))\n    MultiScaleTreeGraph.Node(internode1, MultiScaleTreeGraph.NodeMTG(\"+\", \"Leaf\", 1, 2))\n\n    internode2 = MultiScaleTreeGraph.Node(internode1, MultiScaleTreeGraph.NodeMTG(\"<\", \"Internode\", 1, 2))\n    MultiScaleTreeGraph.Node(internode2, MultiScaleTreeGraph.NodeMTG(\"+\", \"Leaf\", 1, 2))\n    MultiScaleTreeGraph.Node(internode2, MultiScaleTreeGraph.NodeMTG(\"+\", \"Leaf\", 1, 2))\n\n    plant_root_start = MultiScaleTreeGraph.Node(\n        plant, \n        MultiScaleTreeGraph.NodeMTG(\"+\", \"Root\", 1, 3), \n    )\n\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n    \nouts = run!(mtg, mapping, meteo_day)\nmtg\n\n就这样了吗！\n\n……真的如此吗？\n\n如果你仔细检查代码和输出结果，会发现模拟的运行方式存在一些明显的问题……有些地方似乎不太对劲。如果你想了解更多内容，请阅读下一章：修复植物模拟中的Bug","category":"section"},{"location":"API/API_public.html#公共-API","page":"公共 API","title":"公共 API","text":"","category":"section"},{"location":"API/API_public.html#索引","page":"公共 API","title":"索引","text":"Pages = [\"API_public.md\"]","category":"section"},{"location":"API/API_public.html#API-文档","page":"公共 API","title":"API 文档","text":"","category":"section"},{"location":"API/API_public.html#PlantMeteo.TimeStepTable-Union{Tuple{DataFrame}, Tuple{Status}, Tuple{DataFrame, Any}} where Status","page":"公共 API","title":"PlantMeteo.TimeStepTable","text":"TimeStepTable{Status}(df::DataFrame)\n\n方法：从 DataFrame 构建 TimeStepTable（来自 PlantMeteo.jl），但每一行都是 Status。\n\n注意\n\nModelList 默认使用 TimeStepTable{Status}（见下面的示例）。\n\n示例\n\nusing PlantSimEngine, DataFrames\n\n# 从 DataFrame 创建一个 TimeStepTable：\ndf = DataFrame(\n    Tₗ=[25.0, 26.0],\n    aPPFD=[1000.0, 1200.0],\n    Cₛ=[400.0, 400.0],\n    Dₗ=[1.0, 1.2],\n)\nTimeStepTable{Status}(df)\n\n# 只要其中一个变量有多个值，叶片会自动用带时间步的 TimeStepTable{Status}：\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=(var1=15.0, var2=0.3)\n)\n\n# 叶片的 status 是一个 TimeStepTable：\nstatus(models)\n\n# 当然也可以手动用 Status 创建 TimeStepTable：\nTimeStepTable(\n    [\n        Status(Tₗ=25.0, aPPFD=1000.0, Cₛ=400.0, Dₗ=1.0),\n        Status(Tₗ=26.0, aPPFD=1200.0, Cₛ=400.0, Dₗ=1.2),\n    ]\n)\n\n\n\n\n\n","category":"method"},{"location":"API/API_public.html#PlantSimEngine.AbstractModel","page":"公共 API","title":"PlantSimEngine.AbstractModel","text":"抽象模型类型。所有模型都是此类型的子类型。\n\n\n\n\n\n","category":"type"},{"location":"API/API_public.html#PlantSimEngine.ModelList","page":"公共 API","title":"PlantSimEngine.ModelList","text":"ModelList(models::M, status::S)\nModelList(;\n    status=nothing,\n    type_promotion=nothing,\n    variables_check=true,\n    kwargs...\n)\n\n列举用于模拟的一组模型 (models)，并自动完成变量初始化、类型提升、时间步长处理等样板工作。\n\nnote: Note\nstatus 字段取决于输入的模型。你可以通过已实例化模型上的 variables 方法获取模型所需变量，也可以使用 inputs 和 outputs。\n\n参数说明\n\nmodels: 一个模型的列表。通常采用 NamedTuple，但也可以是实现了 getproperty 的其他结构。\nstatus: 包含模型变量初始化的结构体。作为关键字参数时通常为 NamedTuple，或为实现了 Tables.jl 接口的任何结构体（如 DataFrame，详见下文）。\ntype_promotion: 可选，用于默认值变量的类型转换。默认为 nothing（即不转换）。注意，用户以 kwargs 提供的变量不会自动转换（需要手动转换）。需提供以当前类型为键、新类型为值的 Dict。\nvariables_check=true: 检查用户是否初始化了所有必需变量。\nkwargs: 各过程名称对应的模型。\n\n细节\n\n如果你需要自定义 status 的类型，并希望用户能够只初始化部分字段，则必须为 add_model_vars! 实现一个方法，以在类型未完全初始化时添加模型变量。默认方法兼容任何实现了 Tables.jl 接口的类型（如 DataFrame），以及 NamedTuples。\n\n注意，如果输入 status 未涵盖所有变量，ModelList 会对其进行复制。\n\n示例\n\n以下示例采用包中 examples/dummy.jl 的示例模型。其实现了三个虚拟过程：Process1Model、Process2Model 和 Process3Model，且每个过程有一个模型实现。\n\njulia> using PlantSimEngine;\n\n包含示例过程和模型：\n\njulia> using PlantSimEngine.Examples;\n\njulia> models = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model());\n[ Info: Some variables must be initialized before simulation: (process1 = (:var1, :var2), process2 = (:var1,)) (see `to_initialize()`)\n\njulia> typeof(models)\nModelList{@NamedTuple{process1::Process1Model, process2::Process2Model, process3::Process3Model}, Status{(:var5, :var4, :var6, :var1, :var3, :var2), NTuple{6, Base.RefValue{Float64}}}}\n\n未以关键字参数提供变量，意味着 ModelList 的 status 尚未设置，所有变量将按 inputs 和 outputs 中的默认值初始化（通常是 typemin(Type)，比如浮点数则为 -Inf）。此时组件尚不可模拟。\n\n模拟前需初始化哪些变量，可通过 to_initialize 方法查询：\n\njulia> to_initialize(models)\n(process1 = (:var1, :var2), process2 = (:var1,))\n\n我们现在可以在 status 字段中为这些变量赋值，并对 ModelList 进行模拟。例如针对 process3（与 process1 和 process2 耦合）：\n\njulia> models = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model(), status=(var1=15.0, var2=0.3));\n\njulia> meteo = Atmosphere(T = 22.0, Wind = 0.8333, P = 101.325, Rh = 0.4490995);\n\njulia> outputs_sim = run!(models,meteo)\nTimeStepTable{Status{(:var5, :var4, :var6, ...}(1 x 6):\n╭─────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────╮\n│ Row │    var5 │    var4 │    var6 │    var1 │    var3 │    var2 │\n│     │ Float64 │ Float64 │ Float64 │ Float64 │ Float64 │ Float64 │\n├─────┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────┤\n│   1 │ 36.0139 │    22.0 │ 58.0139 │    15.0 │     5.5 │     0.3 │\n╰─────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────╯\n\njulia> outputs_sim[:var6]\n1-element Vector{Float64}:\n 58.0138985\n\n如需对变量使用特殊类型，可使用 type_promotion 参数：\n\njulia> models = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model(), status=(var1=15.0, var2=0.3), type_promotion = Dict(Float64 => Float32));\n\n我们使用 type_promotion 将 status 强制转换为 Float32：\n\njulia> [typeof(models[i][1]) for i in keys(status(models))]\n6-element Vector{DataType}:\n Float32\n Float32\n Float32\n Float64\n Float64\n Float32\n\n可以看到，只有默认变量（未在 status 参数中给定的变量）被转换为 Float32，其余两个用户提供的变量未被转换。这样做是为了让用户可以为 status 中赋值的变量指定任意类型。如需全部变量都转为 Float32，可直接以 Float32 赋值：\n\njulia> models = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model(), status=(var1=15.0f0, var2=0.3f0), type_promotion = Dict(Float64 => Float32));\n\n我们使用 type_promotion 将 status 强制转换为 Float32：\n\njulia> [typeof(models[i][1]) for i in keys(status(models))]\n6-element Vector{DataType}:\n Float32\n Float32\n Float32\n Float32\n Float32\n Float32\n\n\n\n\n\n","category":"type"},{"location":"API/API_public.html#PlantSimEngine.MultiScaleModel","page":"公共 API","title":"PlantSimEngine.MultiScaleModel","text":"MultiScaleModel(model, mapped_variables)\n\n一个用于实现多尺度模型的结构体。它定义了模型变量与节点标记之间的映射，变量值将从这些节点获取。\n\n参数\n\nmodel<:AbstractModel：待多尺度化的模型\nmapped_variables<:Vector{Pair{Symbol,Union{AbstractString,Vector{AbstractString}}}}：由符号和字符串（或字符串向量）组成的配对向量\n\nmapped_variables 参数可以有以下形式：\n\n[:variable_name => \"Plant\"]：从 Plant 节点获取单个值\n[:variable_name => [\"Leaf\"]]：从所有 Leaf 节点获取一个值向量\n[:variable_name => [\"Leaf\", \"Internode\"]]：从 Leaf 和 Internode 节点获取一个值向量\n[:variable_name => \"Plant\" => :variable_name_in_plant_scale]：从 Plant 节点以指定变量名获取值\n[:variable_name => [\"Leaf\" => :variable_name_1, \"Internode\" => :variable_name_2]]：从 Leaf 和 Internode 节点分别以不同变量名获取值，返回一个向量\n[PreviousTimeStep(:variable_name) => ...]：标记变量用前一时间步的值初始化，该变量不参与依赖图的构建\n[:variable_name => :variable_name_from_another_model]：从相同尺度的其它模型变量获取数据，并重命名\n[PreviousTimeStep(:variable_name),]：纯粹标记为 PreviousTimeStep，不参与依赖图构建\n\n不同形式的详细说明：\n\n模型的 variable_name 变量将从 Plant 节点获取，假设只有一个节点是 Plant。此时 status 里该值是标量，因此用户需确保 MTG 中只有一个 Plant 类型节点。\n模型的 variable_name 变量将从所有 Leaf 节点获取。注意此处为向量，模型需能处理值向量。即使只有一个 Leaf 节点，取到的依然是只有一个元素的向量。\n模型的 variable_name 变量将从所有 Leaf 和 Internode 节点获取。即取所有这两类节点的值向量。\n模型的 variable_name 变量将从 Plant 节点中的 variable_name_in_plant_scale 变量获取。当模型变量名与节点变量名不同时可用。\n模型的 variable_name 变量将分别从 Leaf 节点的 variable_name_1 及 Internode 节点的 variable_name_2 取得。\n模型的 variable_name 变量使用上一步计算结果，不用于构建当前步依赖图。可用于变量依赖自身时避免循环依赖。需要时可在 Status 初始化其值。\n模型的 variable_name 变量从同一尺度但不同变量名的其它模型获取。\n模型的 variable_name 变量仅作 PreviousTimeStep 标记，不参与依赖图的构建。\n\n请注意，该映射不会复制变量值，仅引用。当某一节点的 status 被更新，其他节点引用的值也随之改变。\n\n示例\n\njulia> using PlantSimEngine;\n\n包含示例过程和模型：\n\njulia> using PlantSimEngine.Examples;\n\n取一个模型示例：\n\njulia> model = ToyCAllocationModel()\nToyCAllocationModel()\n\n我们通过定义模型变量和节点标记之间的映射，将其转为多尺度模型。\n\n例如，假设 carbon_allocation 来源于 Leaf 和 Internode 节点，可以定义映射如下：\n\njulia> mapped_variables=[:carbon_allocation => [\"Leaf\", \"Internode\"]]\n1-element Vector{Pair{Symbol, Vector{String}}}:\n :carbon_allocation => [\"Leaf\", \"Internode\"]\n\nmappedvariables 参数是符号和字符串（或字符串向量）的配对向量。以上例只有一对，表示将 `carbonallocation变量与Leaf和Internode` 关联。\n\n现在将模型及变量映射传递给 MultiScaleModel 构造函数，实现多尺度模型：\n\njulia> multiscale_model = PlantSimEngine.MultiScaleModel(model, mapped_variables)\nMultiScaleModel{ToyCAllocationModel, Vector{Pair{Union{Symbol, PreviousTimeStep}, Union{Pair{String, Symbol}, Vector{Pair{String, Symbol}}}}}}(ToyCAllocationModel(), Pair{Union{Symbol, PreviousTimeStep}, Union{Pair{String, Symbol}, Vector{Pair{String, Symbol}}}}[:carbon_allocation => [\"Leaf\" => :carbon_allocation, \"Internode\" => :carbon_allocation]])\n\n可访问映射变量和模型：\n\njulia> PlantSimEngine.mapped_variables_(multiscale_model)\n1-element Vector{Pair{Union{Symbol, PreviousTimeStep}, Union{Pair{String, Symbol}, Vector{Pair{String, Symbol}}}}}:\n :carbon_allocation => [\"Leaf\" => :carbon_allocation, \"Internode\" => :carbon_allocation]\n\njulia> PlantSimEngine.model_(multiscale_model)\nToyCAllocationModel()\n\n\n\n\n\n","category":"type"},{"location":"API/API_public.html#PlantSimEngine.PreviousTimeStep","page":"公共 API","title":"PlantSimEngine.PreviousTimeStep","text":"PreviousTimeStep(variable)\n\n用于手动标记模型中某变量以采用上一个时间步中计算的值的结构体。 这意味着该变量不会被用于构建依赖关系图，因为依赖关系图仅适用于当前时间步。 当变量依赖于自身时，为了避免循环依赖，可以使用该方法。 如有需要，其值可以在 Status 中初始化。\n\n当构建 MultiScaleModel 时会添加该过程，以避免不同进程之间具有相同变量名时的冲突。 例如，一个进程可以将变量 :carbon_biomass 定义为 PreviousTimeStep，而另一个进程则将该变量作为当前时间步的依赖项使用（这样是允许的，因为它们不会出现循环依赖的问题）。\n\n\n\n\n\n","category":"type"},{"location":"API/API_public.html#PlantSimEngine.Status","page":"公共 API","title":"PlantSimEngine.Status","text":"Status(vars)\n\nStatus类型用于在模拟过程中存储变量的值。主要用作TimeStepTable的TimeStepRow中用于保存变量的结构体（参见PlantMeteo.jl 文档），也用于ModelList。\n\n大部分代码来自 MasonProtter/MutableNamedTuples.jl，因此Status本质上是一个经过少量修改的MutableNamedTuples， 也就是一个用来存储对变量值的引用的NamedTuple结构体，使其为可变类型。\n\n示例\n\n所有变量只有一个值的叶片将得到一个只有一个时间步长的状态对象：\n\njulia> using PlantSimEngine\n\njulia> st = PlantSimEngine.Status(Ra_SW_f=13.747, sky_fraction=1.0, d=0.03, aPPFD=1500.0);\n\n以下索引方法均可用：\n\njulia> st[:Ra_SW_f]\n13.747\n\njulia> st.Ra_SW_f\n13.747\n\njulia> st[1]\n13.747\n\n设置 Status 变量也很简单：\n\njulia> st[:Ra_SW_f] = 20.0\n20.0\n\njulia> st.Ra_SW_f = 21.0\n21.0\n\njulia> st[1] = 22.0\n22.0\n\n\n\n\n\n","category":"type"},{"location":"API/API_public.html#PlantSimEngine.EF-Tuple{Any, Any}","page":"公共 API","title":"PlantSimEngine.EF","text":"EF(obs,sim)\n\n使用NSE（Nash-Sutcliffe效率）模型，返回观测值 obs 和模拟值 sim 之间的效率系数（Efficiency Factor）。 更多信息见 https://en.wikipedia.org/wiki/Nash%E2%80%93Sutcliffemodelefficiency_coefficient 。\n\n值越接近1越好。\n\n示例\n\nusing PlantSimEngine\n\nobs = [1.0, 2.0, 3.0]\nsim = [1.1, 2.1, 3.1]\n\nEF(obs, sim)\n\n\n\n\n\n","category":"method"},{"location":"API/API_public.html#PlantSimEngine.NRMSE-Tuple{Any, Any}","page":"公共 API","title":"PlantSimEngine.NRMSE","text":"NRMSE(obs,sim)\n\n返回观测值 obs 和模拟值 sim 之间的归一化均方根误差（Normalized Root Mean Squared Error）。 归一化方法是除以观测值的范围（最大值-最小值）。\n\n示例\n\nusing PlantSimEngine\n\nobs = [1.0, 2.0, 3.0]\nsim = [1.1, 2.1, 3.1]\n\nNRMSE(obs, sim)\n\n\n\n\n\n","category":"method"},{"location":"API/API_public.html#PlantSimEngine.RMSE-Tuple{Any, Any}","page":"公共 API","title":"PlantSimEngine.RMSE","text":"RMSE(obs,sim)\n\n返回观测值 obs 和模拟值 sim 之间的均方根误差（Root Mean Squared Error）。\n\n值越接近0越好。\n\n示例\n\nusing PlantSimEngine\n\nobs = [1.0, 2.0, 3.0]\nsim = [1.1, 2.1, 3.1]\n\nRMSE(obs, sim)\n\n\n\n\n\n","category":"method"},{"location":"API/API_public.html#PlantSimEngine.add_organ!-Tuple{MultiScaleTreeGraph.Node, Vararg{Any, 4}}","page":"公共 API","title":"PlantSimEngine.add_organ!","text":"add_organ!(node::MultiScaleTreeGraph.Node, sim_object, link, symbol, scale; index=0, id=MultiScaleTreeGraph.new_id(MultiScaleTreeGraph.get_root(node)), attributes=Dict{Symbol,Any}(), check=true)\n\n向图中添加一个器官，并自动初始化该器官的（多尺度）变量状态。\n\n此函数应从实现器官出现的模型中调用，例如基于热时间的函数。\n\n参数说明\n\nnode：要向其添加器官的节点（新器官的父节点）\nsim_object：模拟对象，例如模型的extra参数中的 GraphSimulation 对象。\nlink：新节点与器官之间的连接类型：\n\"<\"：新节点在父器官之后\n\"+\"：新节点从父器官分枝\n\"/\"：新节点分解父器官，即更改尺度\nsymbol：器官的符号，例如 \"Leaf\"\nscale：器官的尺度，例如 2。\nindex：器官的序号，例如 1。index 可用于方便地标识分枝顺序，或轴上的生长单元序号。它不同于唯一的节点 id。\nid：新节点的唯一编号。如果未提供，则自动生成新编号。\nattributes：新节点的属性。如果未提供，则使用空字典。\ncheck：布尔值，表示是否检查变量初始化。会传递给 init_node_status!。\n\n返回值\n\nstatus：新节点的状态\n\n示例\n\n具体用法请参考 Examples 模块中的 ToyInternodeEmergence 示例模型（也可在 examples 文件夹找到），或 test-mtg-dynamic.jl 测试文件。\n\n\n\n\n\n","category":"method"},{"location":"API/API_public.html#PlantSimEngine.dep","page":"公共 API","title":"PlantSimEngine.dep","text":"dep(m::ModelList)\ndep(mapping::Dict{String,T}; verbose=true)\ndep!(m::ModelList, nsteps=1)\n\n给定 ModelList 或多尺度模型映射，获取模型的依赖图。如果返回一个图，则所有模型耦合在一起；如果返回多个图，则每个图内的模型相互耦合，不同图中的模型不耦合。 nsteps 是依赖图将被使用的步数，用于决定每个软依赖在图中的 simulation_id 参数长度。对于多尺度映射，该值为 1。\n\n细节\n\n依赖图通过在每个过程的输入中查找其本层或其他层输出构建。针对每个模型（一个模型模拟一个过程）有五种情况：\n\n过程无输入。它是完全独立的，作为依赖图的根节点之一。\n过程需要同层模型输入。被放置为另一个过程的子节点。\n过程需要来自另一层的输入。被设置为另一个层过程的子节点。\n过程需要本层和另一层的输入。分别作为两个过程的子节点。\n过程作为另一个过程的硬依赖（仅可能在同层）。此时该过程被设为另一个过程的硬依赖，仿真由该过程直接控制。\n\n第四种情况，过程有两个父过程。这样处理没有问题，因为仿真时会检查两个父节点是否都已运行，仅当均已运行后再运行当前过程。\n\n第五种情况，依然需要检查变量是否来自另一层。此时父节点作为另一层过程的子节点。需注意，可能存在多层硬依赖图，因此此过程是递归完成的。\n\n如何实现以上功能？首先识别硬依赖，然后将硬依赖根节点的输入输出与其它层连接（如有必要）。随后将所有这些节点转为软依赖，放入一个 Dict（Scale => Dict(process => SoftDependencyNode)）中。 遍历所有节点，将需要其它节点输出作为输入的节点，设置为子/父节点关系。 如某节点无任何依赖，则设置为根节点并推入新 Dict（independantprocessroot）。此 Dict 就是返回的依赖图，根节点为各子图的独立起点，这些子图即为被耦合在一起的模型。此后可分别遍历每个子图进行仿真。\n\n备注\n\ndep(m::ModelList) 与 dep!(m::ModelList, nsteps) 的区别在于，前者返回模型列表中的依赖图，后者返回指定步数的依赖图，并对每个节点的 simulationid 进行修正（`simulationid=fill(0, nsteps)`）。\n\n示例\n\nusing PlantSimEngine\n\n# 包含示例过程与模型：\nusing PlantSimEngine.Examples;\n\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=(var1=15.0, var2=0.3)\n)\n\ndep(models)\n\n# 或直接用过程：\nmodels = (\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    process4=Process4Model(),\n    process5=Process5Model(),\n    process6=Process6Model(),\n    process7=Process7Model(),\n)\n\ndep(;models...)\n\n\n\n\n\n","category":"function"},{"location":"API/API_public.html#PlantSimEngine.dr-Tuple{Any, Any}","page":"公共 API","title":"PlantSimEngine.dr","text":"dr(obs,sim)\n\n返回Willmott提出的改进一致性指数dᵣ。 参考：Willmot et al. 2011. A refined index of model performance. https://rmets.onlinelibrary.wiley.com/doi/10.1002/joc.2419\n\n值越接近1越好。\n\n示例\n\nusing PlantSimEngine\n\nobs = [1.0, 2.0, 3.0]\nsim = [1.1, 2.1, 3.1]\n\ndr(obs, sim)\n\n\n\n\n\n","category":"method"},{"location":"API/API_public.html#PlantSimEngine.fit","page":"公共 API","title":"PlantSimEngine.fit","text":"fit()\n\n利用观测值（以及可能的初始化值）优化模型参数。\n\n建模者应为其模型实现一个 fit 方法，建议采用以下设计模式：\n\n函数调用应将模型类型作为第一个参数（T::Type{<:AbstractModel}）， 数据作为第二个参数（支持 Table.jl 的类型，如 DataFrame），并将参数初始化作为关键字参数传递（必要时可设默认值）。\n\n例如，拟合示例脚本中的 Beer 模型的方法（参考 src/examples/Beer.jl）如下：\n\nfunction PlantSimEngine.fit(::Type{Beer}, df; J_to_umol=PlantMeteo.Constants().J_to_umol)\n    k = Statistics.mean(log.(df.Ri_PAR_f ./ (df.aPPFD ./ J_to_umol)) ./ df.LAI)\n    return (k=k,)\nend\n\n该函数应返回以 NamedTuple 形式包含优化参数的元组，如 (parameter_name=parameter_value,)。\n\n以下是使用 Beer 模型的一个示例，其中通过\"aPPFD\"、\"LAI\" 和 \"RiPARf\" 的观测值拟合参数 k。\n\n# 引入示例过程与模型：\nusing PlantSimEngine.Examples;\n\nm = ModelList(Beer(0.6), status=(LAI=2.0,))\nmeteo = Atmosphere(T=20.0, Wind=1.0, P=101.3, Rh=0.65, Ri_PAR_f=300.0)\nrun!(m, meteo)\ndf = DataFrame(aPPFD=m[:aPPFD][1], LAI=m.status.LAI[1], Ri_PAR_f=meteo.Ri_PAR_f[1])\nfit(Beer, df)\n\n注意，这是一个用于演示拟合方法有效性的虚拟示例。在该例中，通过设置 k=0.6 用 Beer-Lambert 定律模拟 aPPFD，并再次利用模拟得到的 aPPFD 来拟合 k，最终得到与模拟时一致的参数值。\n\n\n\n\n\n","category":"function"},{"location":"API/API_public.html#PlantSimEngine.init_status!-Tuple{Dict{String, ModelList}}","page":"公共 API","title":"PlantSimEngine.init_status!","text":"init_status!(object::Dict{String,ModelList};vars...)\ninit_status!(component::ModelList;vars...)\n\n为组件赋予用户输入的初值。\n\n示例\n\nusing PlantSimEngine\n\n# 加载包中的示例虚拟模型：\nusing PlantSimEngine.Examples\n\nmodels = Dict(\n    \"Leaf\" => ModelList(\n        process1=Process1Model(1.0),\n        process2=Process2Model(),\n        process3=Process3Model()\n    ),\n    \"InterNode\" => ModelList(\n        process1=Process1Model(1.0),\n    )\n)\n\ninit_status!(models, var1=1.0 , var2=2.0)\nstatus(models[\"Leaf\"])\n\n\n\n\n\n","category":"method"},{"location":"API/API_public.html#PlantSimEngine.init_variables-Tuple{T} where T<:AbstractModel","page":"公共 API","title":"PlantSimEngine.init_variables","text":"init_variables(models...)\n\n用模型的默认值初始化变量。这些变量取自模型的输入和输出。\n\n示例\n\nusing PlantSimEngine\n\n# 加载包中的示例虚拟模型：\nusing PlantSimEngine.Examples\n\ninit_variables(Process1Model(2.0))\ninit_variables(process1=Process1Model(2.0), process2=Process2Model())\n\n\n\n\n\n","category":"method"},{"location":"API/API_public.html#PlantSimEngine.inputs-Tuple{T} where T<:AbstractModel","page":"公共 API","title":"PlantSimEngine.inputs","text":"inputs(model::AbstractModel)\ninputs(...)\n\n获取一个或多个模型的输入变量。\n\n对于 AbstractModel（无输入变量）或 Missing 类型的模型，默认返回空元组。\n\n示例\n\nusing PlantSimEngine;\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples;\n\ninputs(Process1Model(1.0))\n\n# output\n(:var1, :var2)\n\n\n\n\n\n","category":"method"},{"location":"API/API_public.html#PlantSimEngine.inputs-Union{Tuple{Dict{String, T}}, Tuple{T}} where T","page":"公共 API","title":"PlantSimEngine.inputs","text":"inputs(mapping::Dict{String,T})\n\n获取映射中每个过程和器官类型的模型输入变量。\n\n\n\n\n\n","category":"method"},{"location":"API/API_public.html#PlantSimEngine.is_initialized-Tuple{T} where T<:ModelList","page":"公共 API","title":"PlantSimEngine.is_initialized","text":"is_initialized(m::T) where T <: ModelList\nis_initialized(m::T, models...) where T <: ModelList\n\n检查必须初始化的变量是否已经被初始化。如果已初始化全部变量，返回 true，否则返回 false 并给出信息提示。\n\n注意\n\n无法预先知道用户将仿真哪些过程，因此，如果一个组件为每个过程都定义了模型，则需要初始化的变量始终是所有变量中最小的那个子集，即认为用户将仿真其它模型所需的变量。\n\n示例\n\nusing PlantSimEngine\n\n# 加载包中的示例虚拟模型：\nusing PlantSimEngine.Examples\n\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model()\n)\n\nis_initialized(models)\n\n\n\n\n\n","category":"method"},{"location":"API/API_public.html#PlantSimEngine.outputs-Tuple{T} where T<:AbstractModel","page":"公共 API","title":"PlantSimEngine.outputs","text":"outputs(model::AbstractModel)\noutputs(...)\n\n获取一个或多个模型的输出变量。\n\n对于 AbstractModel（无输出变量）或 Missing 类型的模型，默认返回空元组。\n\n示例\n\nusing PlantSimEngine;\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples;\n\noutputs(Process1Model(1.0))\n\n# output\n(:var3,)\n\n\n\n\n\n","category":"method"},{"location":"API/API_public.html#PlantSimEngine.outputs-Union{Tuple{Dict{String, T}}, Tuple{T}} where T","page":"公共 API","title":"PlantSimEngine.outputs","text":"outputs(mapping::Dict{String,T})\n\n获取映射中每个过程和器官类型的模型输出变量。\n\n\n\n\n\n","category":"method"},{"location":"API/API_public.html#PlantSimEngine.run!","page":"公共 API","title":"PlantSimEngine.run!","text":"run!(object, meteo, constants, extra=nothing; check=true, executor=Floops.ThreadedEx())\nrun!(object, mapping, meteo, constants, extra; nsteps, outputs, check, executor)\n\n运行仿真，对模型列表中的每个模型按照正确顺序（即按照依赖关系图）执行。\n\n如果给定多个时间步，模型将在每个时间步顺序运行。\n\n参数说明\n\nobject：一个 ModelList、ModelList 的数组或字典，或者一个植物图（MTG）。\nmeteo：一个 PlantMeteo.TimeStepTable，其元素为 PlantMeteo.Atmosphere，或单一 PlantMeteo.Atmosphere。\nconstants：一个 PlantMeteo.Constants 对象，或由常量键和值组成的 NamedTuple。\nextra：额外参数。在仿真植物图（MTG）时不可用（仿真对象通过此参数传递）。\ncheck：若为 true，在运行仿真前检查模型列表合法性（会花费少量时间），且在运行过程中返回更多信息。\nexecutor：用于运行仿真的 Floops 执行器，可以顺序执行（executor=SequentialEx()）、多线程并行（executor=ThreadedEx()，默认）、分布式并行（executor=DistributedEx()）。\nmapping：MTG 与模型列表之间的映射关系。\nnsteps：需要运行的时间步数，仅在未给定 meteo 时需要（否则会自动从 meteo 推断）。\noutputs：对于 MTG 的每个节点类型，需动态获得的输出变量。\n\n返回值\n\n在原地修改对象的 status。用户可通过 status 函数（参见示例）从对象获取结果。\n\n细节\n\n模型执行\n\n模型按照依赖图顺序运行。如果一个模型对另一个模型有软依赖（即输入由另一模型计算），会优先运行被依赖模型。若有多个软依赖，则会优先计算所有父模型（软依赖）。\n\n并行执行\n\n用户可以通过为 executor 参数提供兼容执行器实现并行。软件包会自动检查是否允许并行。如果不允许而用户指定了并行，将会发出警告，并转为顺序执行。 我们使用 Floops 包实现并行仿真，意味着你可将任何相容的执行器传入 executor 参数。 可参考 FoldsThreads.jl（线程执行器）、FoldsDagger.jl（Dagger 框架并行 fold）、以及即将发布的 FoldsCUDA.jl（GPU 计算，详见 本议题）和 FoldsKernelAbstractions.jl。也可以通过 ParallelMagics.jl 检查是否可自动并行。\n\n示例\n\n导入相关包：\n\njulia> using PlantSimEngine, PlantMeteo;\n\n加载 Examples 子模块中给出的示例模型：\n\njulia> using PlantSimEngine.Examples;\n\n创建模型列表：\n\njulia> models = ModelList(Process1Model(1.0), Process2Model(), Process3Model(), status = (var1=1.0, var2=2.0));\n\n创建气象数据：\n\njulia> meteo = Atmosphere(T=20.0, Wind=1.0, P=101.3, Rh=0.65, Ri_PAR_f=300.0);\n\n运行仿真：\n\njulia> outputs_sim = run!(models, meteo);\n\n获取仿真输出：\n\njulia> (outputs_sim[:var4],outputs_sim[:var6])\n([12.0], [41.95])\n\n\n\n\n\n","category":"function"},{"location":"API/API_public.html#PlantSimEngine.status-Tuple{Any}","page":"公共 API","title":"PlantSimEngine.status","text":"status(m)\nstatus(m::AbstractArray{<:ModelList})\nstatus(m::AbstractDict{T,<:ModelList})\n\n获取 ModelList 的状态，即输入（和输出）变量的状态。\n\n另见 is_initialized 和 to_initialize\n\n示例\n\nusing PlantSimEngine\n\n# Including example models and processes:\nusing PlantSimEngine.Examples;\n\n# Create a ModelList\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status = (var1=[15.0, 16.0], var2=0.3)\n);\n\nstatus(models)\n\n# Or just one variable:\nstatus(models,:var1)\n\n\n# Or the status at the ith time-step:\nstatus(models, 2)\n\n# Or even more simply:\nmodels[:var1]\n# output\n2-element Vector{Float64}:\n 15.0\n 16.0\n\n\n\n\n\n","category":"method"},{"location":"API/API_public.html#PlantSimEngine.to_initialize-Tuple{ModelList}","page":"公共 API","title":"PlantSimEngine.to_initialize","text":"to_initialize(; verbose=true, vars...)\nto_initialize(m::T)  where T <: ModelList\nto_initialize(m::DependencyGraph)\nto_initialize(mapping::Dict{String,T}, graph=nothing)\n\n返回必须初始化的变量，提供一组模型与过程。 该函数考虑模型耦合，仅返回必需的变量，即只返回那些由于部分模型的输出变量被其他模型作为输入变量而需要的变量。\n\n参数\n\nverbose: 如果为true，打印信息消息。\nvars...: 要考虑的模型和过程。\nm::T: 一个ModelList。\nm::DependencyGraph: 一个 DependencyGraph。\nmapping::Dict{String,T}: 一个模型与器官的映射。\ngraph: 表示植物或场景的图（如多尺度树图）。该图被用于检测未初始化变量是否在图节点属性中已存在。\n\n示例\n\nusing PlantSimEngine\n\n# 加载包中的示例虚拟模型：\nusing PlantSimEngine.Examples\n\nto_initialize(process1=Process1Model(1.0), process2=Process2Model())\n\n# 或直接使用组件：\nmodels = ModelList(process1=Process1Model(1.0), process2=Process2Model())\nto_initialize(models)\n\nm = ModelList(\n    (\n        process1=Process1Model(1.0),\n        process2=Process2Model()\n    ),\n    Status(var1 = 5.0, var2 = -Inf, var3 = -Inf, var4 = -Inf, var5 = -Inf)\n)\n\nto_initialize(m)\n\n或者带有映射：\n\nusing PlantSimEngine\n\n# 加载包中的示例虚拟模型：\nusing PlantSimEngine.Examples\n\nmapping = Dict(\n    \"Leaf\" => ModelList(\n        process1=Process1Model(1.0),\n        process2=Process2Model(),\n        process3=Process3Model()\n    ),\n    \"Internode\" => ModelList(\n        process1=Process1Model(1.0),\n    )\n)\n\nto_initialize(mapping)\n\n\n\n\n\n","category":"method"},{"location":"API/API_public.html#PlantSimEngine.variables-Tuple{Module}","page":"公共 API","title":"PlantSimEngine.variables","text":"variables(pkg::Module)\n\n返回某个依赖 PlantSimEngine 的包中所有变量、变量描述及单位的数据表（需包作者实现）。\n\n开发者注意事项\n\n依赖 PlantSimEngine 的包开发者应将变量信息写入 \"data/variables.csv\" 文件， 该函数会返回此文件的内容。\n\n示例\n\n以下为 PlantBiophysics 包的示例：\n\n#] add PlantBiophysics\nusing PlantBiophysics\nvariables(PlantBiophysics)\n\n\n\n\n\n","category":"method"},{"location":"API/API_public.html#PlantSimEngine.variables-Union{Tuple{Dict{String, T}}, Tuple{T}} where T","page":"公共 API","title":"PlantSimEngine.variables","text":"variables(mapping::Dict{String,T})\n\n获取映射中每个过程和器官类型模型的变量（输入与输出）。\n\n\n\n\n\n","category":"method"},{"location":"API/API_public.html#PlantSimEngine.variables-Union{Tuple{T}, Tuple{T, Vararg{Any}}} where T<:Union{Missing, AbstractModel}","page":"公共 API","title":"PlantSimEngine.variables","text":"variables(model)\nvariables(model, models...)\n\n返回模型所需变量的名称元组，或多个模型变量名的并集。\n\n注意\n\n每个模型都可以（且应该）为此函数定义一个方法。\n\n\nusing PlantSimEngine;\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples;\n\nvariables(Process1Model(1.0))\n\nvariables(Process1Model(1.0), Process2Model())\n\n# output\n\n(var1 = -Inf, var2 = -Inf, var3 = -Inf, var4 = -Inf, var5 = -Inf)\n\n参见\n\ninputs, outputs and variables_typed\n\n\n\n\n\n","category":"method"},{"location":"API/API_public.html#PlantSimEngine.@process-Tuple{Any, Vararg{Any}}","page":"公共 API","title":"PlantSimEngine.@process","text":"@process(process::String, doc::String=\"\"; verbose::Bool=true)\n\n该宏用于生成某一过程的抽象类型及部分仿真的样板代码，并自动生成相关文档。如果verbose=true，还会输出简短的模型实现教程。\n\n该抽象过程类型会作为所有该过程模型实现的父类型，其名称形式为 \"Abstract<ProcessName>Model\"，例如对于过程名 \"growth\"，其父类型为 AbstractGrowthModel。\n\n@process 的第一个参数为新过程名称，第二个参数为附加到 Abstract<ProcessName>Model 类型上的额外文档内容，第三个参数决定是否打印简短教程。\n\n建议新用户使用该宏，因为它会详细说明后续的操作流程。更有经验的用户可直接定义 abstract type 并指定为 AbstractModel 的子类，而不输出教程：\n\nabstract type MyNewProcess <: AbstractModel end\n\n例子\n\n@process \"dummy_process\" \"This is a dummy process that shall not be used\"\n\n\n\n\n\n","category":"macro"},{"location":"documentation_improvement.html#帮助我们改进文档！","page":"改进文档","title":"帮助我们改进文档！","text":"PlantSimEngine 的目标之一，就是让更多的人比以往任何框架更容易进行生态生理假设的测试或植物模拟的构建。\n\n为此，完善的文档至关重要。\n\n如果你觉得文档中有任何不清楚的地方，非常欢迎你通过 PR、邮件，或者发送消息（可以在 Github 或 FSPM Discourse 上联系我们），这样我们才能不断改进文档。","category":"section"},{"location":"multiscale/multiscale_cyclic.html#避免循环依赖","page":"循环依赖的处理","title":"避免循环依赖","text":"在定义模型与尺度之间的映射时，重要的一点是避免出现循环依赖。所谓循环依赖，指的是当一个尺度上的模型依赖于另一个尺度上的模型，并且后者又反过来依赖前者时，就构成了一个循环依赖。循环依赖是不好的，因为它会导致模拟中出现无限循环（依赖关系图会无休止地循环下去）。\n\nPlantSimEngine 会检测循环依赖，并在发现时抛出错误。该错误信息会指出参与循环的模型，并以红色高亮显示导致循环的模型。\n\n例如，下面的映射就会触发一个循环依赖错误：\n\ndetails: Details\n<summary>示例映射</summary>mapping_cyclic = Dict(\n    \"Plant\" => (\n        MultiScaleModel(\n            model=ToyCAllocationModel(),\n            mapped_variables=[\n                :carbon_demand => [\"Leaf\", \"Internode\"],\n                :carbon_allocation => [\"Leaf\", \"Internode\"]\n            ],\n        ),\n        MultiScaleModel(\n            model=ToyPlantRmModel(),\n            mapped_variables=[:Rm_organs => [\"Leaf\" => :Rm, \"Internode\" => :Rm],],\n        ),\n        Status(total_surface=0.001, aPPFD=1300.0, soil_water_content=0.6),\n    ),\n    \"Internode\" => (\n        ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0),\n        ToyMaintenanceRespirationModel(1.5, 0.06, 25.0, 0.6, 0.004),\n        Status(TT=10.0, carbon_biomass=1.0),\n    ),\n    \"Leaf\" => (\n        ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0),\n        ToyMaintenanceRespirationModel(2.1, 0.06, 25.0, 1.0, 0.025),\n        ToyCBiomassModel(1.2),\n        Status(TT=10.0),\n    )\n)\n\n让我们来看看使用这个映射在构建依赖关系图时会发生什么：\n\njulia> dep(mapping_cyclic)\nERROR: Cyclic dependency detected in the graph. Cycle:\n Plant: ToyPlantRmModel\n └ Leaf: ToyMaintenanceRespirationModel\n  └ Leaf: ToyCBiomassModel\n   └ Plant: ToyCAllocationModel\n    └ Plant: ToyPlantRmModel\n\n You can break the cycle using the `PreviousTimeStep` variable in the mapping.\n\n我们如何理解这条信息？这里列出了五个参与循环的模型。第一个模型是导致循环的起始点，剩下的模型依次相互依赖。在这个例子中，ToyPlantRmModel 是循环的发起者，其余的模型则存在相互依赖关系。具体解释如下：\n\nToyPlantRmModel 依赖于 ToyMaintenanceRespirationModel，即植株尺度的呼吸模型需要累加所有器官的呼吸量；\nToyMaintenanceRespirationModel 依赖于 ToyCBiomassModel，即器官的维持呼吸与器官的碳生物量相关；\nToyCBiomassModel 依赖于 ToyCAllocationModel，即器官的碳生物量取决于器官获得的碳分配量；\n最后，ToyCAllocationModel 又依赖于 ToyPlantRmModel，因此导致循环——碳分配又依赖于植株尺度的呼吸。\n\n这些模型之间无法找到一个能满足所有依赖关系的顺序，因此循环无法自动被打破。为了解决这个问题，我们需要重新思考模型之间的映射方式，将环路打破。\n\n打破循环依赖的方法有几种：\n\n合并模型：如果两个模型相互依赖，例如需要递归计算，可以将它们合并到第三个模型中，由该模型统一完成计算，并把原有两个模型设为“强依赖”。强依赖指的是被显式调用、不会参与依赖图自动推导的模型。\n更换模型：当然，也可以通过更换或调整模型来规避循环依赖，但这更像是权宜之计，而不是根本性的方案。\nPreviousTimeStep（前一时步变量）：通过将某些变量声明为取自前一时刻，可以打破依赖图中的循环。一个众所周知的例子是植株对光截获的计算，这通常依赖叶面积，而叶面积本身又可能是依赖光截获的模型计算出来的。通常，通过在截获模型中使用前一时刻的叶面积来实现近似，从而打破循环依赖，这在大多数情况下是一个足够好的近似。\n\n在我们的例子中，可以通过让器官呼吸模型使用前一时刻的碳生物量来计算，从而修正原有的映射关系。下面给出具体如何在映射中打破循环依赖（注意叶片和节间两个尺度的处理）：\n\ndetails: Details\nmapping_nocyclic = Dict(\n        \"Plant\" => (\n            MultiScaleModel(\n                model=ToyCAllocationModel(),\n                mapping=[\n                    :carbon_demand => [\"Leaf\", \"Internode\"],\n                    :carbon_allocation => [\"Leaf\", \"Internode\"]\n                ],\n            ),\n            MultiScaleModel(\n                model=ToyPlantRmModel(),\n                mapped_variables=[:Rm_organs => [\"Leaf\" => :Rm, \"Internode\" => :Rm],],\n            ),\n            Status(total_surface=0.001, aPPFD=1300.0, soil_water_content=0.6, carbon_assimilation=5.0),\n        ),\n        \"Internode\" => (\n            ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0),\n            MultiScaleModel(\n                model=ToyMaintenanceRespirationModel(1.5, 0.06, 25.0, 0.6, 0.004),\n                mapped_variables=[PreviousTimeStep(:carbon_biomass),], #! 这里通过使用前一时刻的碳生物量打破了循环依赖（第一次打破）\n            ),\n            Status(TT=10.0, carbon_biomass=1.0),\n        ),\n        \"Leaf\" => (\n            ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0),\n            MultiScaleModel(\n                model=ToyMaintenanceRespirationModel(2.1, 0.06, 25.0, 1.0, 0.025),\n                mapped_variables=[PreviousTimeStep(:carbon_biomass),], #! 这里通过使用前一时刻的碳生物量打破了循环依赖（第二次打破）\n            ),\n            ToyCBiomassModel(1.2),\n            Status(TT=10.0),\n        )\n    );\nnothing # hide\n\nToyMaintenanceRespirationModel 现在被定义为 MultiScaleModel，而 carbon_biomass 变量被包裹在 PreviousTimeStep 结构中。PreviousTimeStep 结构告诉 PlantSimEngine 从前一时刻获取该变量的数值，从而打破循环依赖关系。\n\nnote: Note\nPreviousTimeStep 指示 PlantSimEngine 获取所包裹变量在上一时刻的数值；如果当前是第一次迭代，则取初始化时的数值。初始化数值默认为模型输入里设定的，但通常可以通过 Status 结构进行覆盖。 PreviousTimeStep 用于包裹模型的输入变量，可以有跨尺度映射，也可以没有，例如：PreviousTimeStep(:carbon_biomass) => \"Leaf\"。","category":"section"},{"location":"step_by_step/model_switching.html#模型切换","page":"模型切换","title":"模型切换","text":"PlantSimEngine 的主要目标之一是允许用户在无需修改 PlantSimEngine 代码库本身的情况下，切换某一过程的模型实现。\n\n整个包的设计理念正是围绕这一思想展开的——让容易的更容易，让变化快速高效。只需在ModelList中切换具体模型，然后再次调用 run! 函数即可。如果没有引入新的变量，不需要进行任何其他更改。","category":"section"},{"location":"step_by_step/model_switching.html#第一次模拟：作为起点","page":"模型切换","title":"第一次模拟：作为起点","text":"有了可用的运行环境后，让我们从examples文件夹中的示例脚本，创建一个包含多个模型的ModelList。\n\n从脚本导入模型：\n\nusing PlantSimEngine\n# 导入 `Examples` 子模块中的示例\nusing PlantSimEngine.Examples\n\n将各个模型组合到一个ModelList里进行耦合：\n\nmodels = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    ToyRUEGrowthModel(0.2),\n    status=(TT_cu=cumsum(meteo_day.TT),),\n)\n\nnothing # hide\n\n我们可以通过气象数据和调用run!函数来进行模拟。这里用的是一个示例数据集：\n\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\nnothing # hide\n\n现在我们可以运行模拟了：\n\noutput_initial = run!(models, meteo_day)","category":"section"},{"location":"step_by_step/model_switching.html#在模拟中切换单个模型","page":"模型切换","title":"在模拟中切换单个模型","text":"那如果我们想要更换用于计算生长的模型呢？其实这很简单，只需要在ModelList中替换对应的模型，PlantSimEngine 会自动更新依赖图，并适应新的模型进行模拟。\n\n让我们将原本的 ToyRUEGrowthModel 替换为 ToyAssimGrowthModel：\n\nmodels2 = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    ToyAssimGrowthModel(), # 这里之前是 `ToyRUEGrowthModel(0.2)`\n    status=(TT_cu=cumsum(meteo_day.TT),),\n)\n\nnothing # hide\n\nToyAssimGrowthModel 比ToyRUEGrowthModel](@ref)稍微复杂一些，因为它同时计算了植物的维持呼吸和生长呼吸，因此参数也更多（这里我们采用默认参数）。\n\n我们可以重新运行一次模拟，并看到新的模拟输出会和之前不一样：\n\noutput_updated = run!(models2, meteo_day)\n\n就是这么简单！我们无需更改其他代码，也不用手动重新计算依赖关系，就能切换所用的模型。这是 PlantSimEngine 的一大强大功能！💪\n\nnote: Note\n这里演示的是非常标准且直接的例子。有时候某些模型的替换会需要你向ModelList中额外添加新的模型。例如，ToyAssimGrowthModel 可能需要一个专门的维持呼吸模型，这时 PlantSimEngine 会自动提示你需要哪些额外模型来保证模拟顺利进行。\n\nnote: Note\n在我们的例子里，我们替换的是一种软依赖耦合，但同样的原则也适用于硬依赖。硬依赖和软依赖是模型耦合相关的两个重要概念，相关内容可以在标准模型耦合以及耦合更复杂的模型部分中查阅了解。","category":"section"},{"location":"step_by_step/advanced_coupling.html#耦合更复杂的模型","page":"高级耦合与硬依赖","title":"耦合更复杂的模型","text":"当两个或多个模型之间存在双向依赖关系（即变量不仅仅是单向从一个模型流向下一个模型，而是存在相互依赖时），我们称之为硬依赖。\n\n这种依赖关系要求用户/建模者进行一些额外的设置，才能让 PlantSimEngine 自动生成正确的依赖图。","category":"section"},{"location":"step_by_step/advanced_coupling.html#声明硬依赖关系","page":"高级耦合与硬依赖","title":"声明硬依赖关系","text":"一个模型如果在其run!函数中显式直接调用了其他过程的run!函数，则它属于硬依赖关系（或称为硬耦合模型）。\n\n让我们通过examples/dummy.jl脚本中提供的示例过程和模型进行说明。\n\n在这个脚本中，我们声明了七个过程和七个模型，每个过程对应一个模型。这些过程分别被称为“process1”、“process2”等，其模型实现分别为Process1Model、Process2Model等。\n\n在执行时，Process2Model会显式调用其他过程的run!函数，因此必须将该过程定义为Process2Model的硬依赖。例如：\n\nfunction PlantSimEngine.run!(::Process2Model, models, status, meteo, constants, extra)\n    # 通过 process1 计算 var3：\n    run!(models.process1, models, status, meteo, constants)\n    # 计算 var4 和 var5：\n    status.var4 = status.var3 * 2.0\n    status.var5 = status.var4 + 1.0 * meteo.T + 2.0 * meteo.Wind + 3.0 * meteo.Rh\nend\n\nProcess2Model与另一个过程（process1）耦合，并且调用了其模型的run!函数。被调用的run!函数参数与调用它的模型的run!参数完全相同，只是第一个参数需要传入希望模拟的过程对应的模型。\n\nnote: Note\n对于process1过程，模型类型是灵活的，并不强制为某一特定实现。这就是为何我们可以通过在ModelList中切换模型，实现对同一过程选择不同模型实现的原因。\n\n必须始终在PlantSimEngine中声明硬依赖关系。具体做法是在实现模型时，为dep函数添加一个方法。例如，将process1对Process2Model的硬依赖声明如下：\n\nPlantSimEngine.dep(::Process2Model) = (process1=AbstractProcess1Model,)\n\n这样PlantSimEngine就知道，Process2Model在仿真process1过程时，需要一个适用于该过程的模型。为了避免只能耦合某个特定模型，实现上只要求依赖的模型是AbstractProcess1Model的子类型，从而不限定只能用Process1Model，如果你有另一个模型同样可以计算该过程所需变量，也能被替换而无需更改耦合关系。\n\n虽然不推荐，但如果确有需要强制只与某一具体模型耦合，可以将依赖声明为只接受该模型。例如，如果只允许用Process1Model来模拟process1过程，可以这样声明：\n\nPlantSimEngine.dep(::Process2Model) = (process1=Process1Model,)","category":"section"},{"location":"step_by_step/advanced_coupling.html#真实案例举例","page":"高级耦合与硬依赖","title":"真实案例举例","text":"在配套包PlantBioPhysics.jl中可见一个典型例子。其中的能量平衡模型Monteith model需要在其run!函数中多次迭代调用光合模型。","category":"section"},{"location":"prerequisites/key_concepts.html#关键概念","page":"关键概念","title":"关键概念","text":"本页简要介绍了与 PlantSimEngine 相关及在使用过程中涉及到的一些主要概念和术语。\n\nPages = [\"key_concepts.md\"]\nDepth = 4","category":"section"},{"location":"prerequisites/key_concepts.html#作物模型","page":"关键概念","title":"作物模型","text":"","category":"section"},{"location":"prerequisites/key_concepts.html#FSPM（功能-结构植物模型）","page":"关键概念","title":"FSPM（功能-结构植物模型）","text":"","category":"section"},{"location":"prerequisites/key_concepts.html#PlantSimEngine-术语","page":"关键概念","title":"PlantSimEngine 术语","text":"本页对 PlantSimEngine 中用到的核心概念和术语进行了总体说明。如果你需要更贴近实现的详细设计与术语释义，请参见简单模拟流程详解。\n\n!!! 注意     某些术语在不同语境下可能含义不同，尤以“器官”、“尺度”（scale）和“符号”（symbol）为甚：这些词在多尺度树图中与 PlantSimEngine 其他部分的含义略有区别（见下文尺度 / 符号（symbol）术语的混淆小节）。遇到相关疑问时，请务必参阅对应子章节及相关示例。","category":"section"},{"location":"prerequisites/key_concepts.html#过程（Processes）","page":"关键概念","title":"过程（Processes）","text":"在本包中，“过程”指一个生物或物理现象。你可以将其理解为系统中发生的任何过程，如光拦截、光合作用、水分、碳和能量通量、生长、产量，甚至太阳能电池产生的电力等。\n\n如需了解如何声明一个新过程，可参见实现一个新过程。","category":"section"},{"location":"prerequisites/key_concepts.html#模型（Models）","page":"关键概念","title":"模型（Models）","text":"在 PlantSimEngine 中，“模型”指的是针对某一过程进行仿真的具体实现。\n\n对于同一个过程，可能存在多种不同的模型选择。例如，针对光合作用有多种建模假说和粒度、精度不同的模型。一种简单光合模型可能只是对总叶面积用一个简明公式进行计算，而更复杂的模型则会模拟光拦截和光衰减等过程。\n\n!!! 注意     配套包 PlantBiophysics.jl 提供了用于实现光衰减 Beer-Lambert 定律的 Beer 结构体。本包也为 light_interception 过程和 Beer 模型提供了示例脚本，见 examples/Beer.jl。\n\n模型不仅仅用于文献定义的生理过程，也可以用于各种临时计算或非标准功能。在 PlantSimEngine 中，一切皆为模型。在许多场景下，自定义模型非常实用，比如汇总计算或处理特定信息。例如油棕模型 XPalm 就有多个模型用于管理不同器官的状态，还有专门进行叶片修剪的模型，其实现见 leaf_pruning.jl。\n\n要准备一次模拟，你需声明一个 ModelList，包含你所需的全部模型，并初始化各自的参数。具体用法请参见逐步操作详解。\n\n对于多尺度模拟，模型在使用时应当与特定尺度（scale）绑定。具体细节见下文的多尺度建模内容，或参见多尺度建模的注意事项页面获取更完整的描述。","category":"section"},{"location":"prerequisites/key_concepts.html#变量、输入、输出与模型耦合","page":"关键概念","title":"变量、输入、输出与模型耦合","text":"在模拟过程中，模型需要某些输入数据和参数，并计算输出其它数据，这些输出可供其它模型使用。根据组合的模型不同，同一个变量可能是某些模型的输入、另一些模型的输出，也可能只是中间计算步骤，或者是整个模拟的用户输入。\n\n下面给出一个模型耦合的概念示意图：每个“节点”代表一个不同的 PlantSimEngine 模型，图中的 compute() 等价于模型的 \"run!\" 函数：\n\n(Image: 模型耦合示例) (图源: Autodesk)","category":"section"},{"location":"prerequisites/key_concepts.html#依赖图（Dependency-graphs）","page":"关键概念","title":"依赖图（Dependency graphs）","text":"通过上述方式将模型耦合起来，会形成所谓的有向无环图（Directed Acyclic Graph, DAG），它是一类常见的依赖图。模型的执行顺序由这个依赖图决定。\n\n(Image: 有向无环图（DAG）示例) 一个简单的有向无环图，注意其中不允许出现环（循环）。图源: Astronomer（注：\"Not Acyclic\" 即为环状图）\n\nPlantSimEngine 会自动根据变量和模型关系生成这样的有向无环依赖图。用户只需要声明模型，无需手动编写模型之间的连接代码，只要模型间的耦合不存在循环依赖，剩下的连接、调度都会自动完成。","category":"section"},{"location":"prerequisites/key_concepts.html#hard_dependency_def","page":"关键概念","title":"“硬依赖”和“软依赖”","text":"通过将一个模型的输出变量设为另一个模型的输入变量，可以处理大多数常见的模型耦合（多尺度模型和变量带来更多复杂情况）。但如果两个模型之间互相依赖，需要相互迭代、多次交换数据，该怎么办？\n\n你可以在配套包 PlantBioPhysics.jl 中找到一个典型案例。例如，能量平衡模型 Monteith 模型需要在其 run! 函数中多次迭代调用光合模型。\n\n下图展示了这种模型互为依赖的方式：\n\n(Image: 存在环的耦合示意图)\n\n存在环的耦合示例。图片来源：PlantBioPhysics.jl\n\n这类模型耦合会导致模拟步骤出现“双向流动”，从而破坏依赖图中的“无环”假设。\n\nPlantSimEngine 对这种情况的处理是：不把这些“高度耦合”的模型（下称 硬依赖）纳入主依赖图中。相反，开发者需要在一个模型内部手动调用这些硬依赖模型。这样，被调用的模型就作为父/祖先模型的内部子节点处理，不再与依赖图里的其他节点发生（外部）连接。这样得到的高级依赖图只保留没有双向依赖的模型之间的链接，依然是有向图，可以保证仿真的有序执行。上层依赖图中较简单的“外部”耦合我们称为“软依赖”。\n\n(Image: PlantSimEngine 中的硬依赖耦合可视化)\n\n如上图所示，PlantSimEngine 对此类耦合的处理方式： 红色的模型（“硬依赖”）不会暴露在最终的依赖图中，最终依赖图只包含蓝色的“软依赖”关系，无任何环路。\n\n这种方法对联动互依类模型的开发有如下影响：硬依赖模型必须被显式声明，并且其父模型需要在自己的 run! 函数中显式调用该硬依赖模型的 run! 方法。每个硬依赖模型只能对应一个父模型。\n\n依赖其他过程使得此类模型的开发和验证稍显复杂，但这种方式依然保留了实现的灵活性，因为任何实现了该“硬依赖”过程的模型都可由用户传入。\n\n请注意，硬依赖模型自身也可以继续嵌套更深一层的硬依赖，因此也可能出现更为复杂的多重耦合情形。","category":"section"},{"location":"prerequisites/key_concepts.html#天气数据","page":"关键概念","title":"天气数据","text":"要运行一次模拟，通常需要获取靠近目标或部件的气候/气象条件数据。\n\n强烈建议用户使用 PlantMeteo.jl —— 这是一个配套包，用于高效管理气象数据，内置了一些默认的预处理及高效计算相关的数据结构。本文档将始终使用 PlantMeteo.jl，也推荐大家一同使用。\n\n该包中最基础的数据结构是 Atmosphere 类型，代表稳态的大气条件，即假设环境处于平衡状态。若需存储多个连续时步的气象数据，则可使用 TimeStepTable。\n\n创建 Atmosphere 对象时必须提供以下变量：T（空气温度，单位为 °C）、Rh（相对湿度，取值范围为 0-1）以及 Wind（风速，单位为 m s⁻¹）。\n\n如下例所示，还可以额外传入（可选项）光合有效辐射通量（Ri_PAR_f, 单位：W m⁻²）。我们可以这样声明条件：\n\nusing PlantMeteo\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, Rh = 0.65, Ri_PAR_f = 500.0)\n\n详细信息可参考该包文档。如果你不打算使用 PlantMeteo.jl，也可以自行提供气象数据，只要遵循 Tables.jl 接口（例如直接用 DataFrame）即可。\n\n如果你希望使用更精细的逐时或逐步气象数据，那么往往需要自己扩展模型并操作 MTG 结构，模拟流程也会更复杂。","category":"section"},{"location":"prerequisites/key_concepts.html#器官-/-尺度（Organ/Scale）","page":"关键概念","title":"器官 / 尺度（Organ/Scale）","text":"植物拥有不同的器官，每种器官具有不同的生理特性与过程。当对植物生长进行更细致的模拟时，许多模型会绑定到植物的某个特定器官。例如，处理开花状态或根系吸水的模型即属于此类。其他模型（如碳分配与碳需求）则可以以稍微不同的方式被复用于同一植物的多个器官。\n\n在 PlantSimEngine 的文档中，通常“器官”（organ）与“尺度”（scale）这两个术语可以互换使用。实际上，“尺度”更为通用且准确，因为有些模型并不在特定器官方向运行，例如可以作用于整个场景(Scene)层级。因此，MTG 结构及用户所提供的数据中可能会出现“Scene”这一尺度。\n\n处理多尺度数据时，往往需要明确指定尺度以进行变量映射，或指明模型所处的尺度层级。你会看到类似如下的代码：\n\n\"Root\" => (RootGrowthModel(), OrganAgeModel()),\n\"Leaf\" => (LightInterceptionModel(), OrganAgeModel()),\n\"Plant\" => (TotalBiomassModel(),),\n\n这个示例将具体的模型绑定到了具体的尺度。注意其中一个模型被复用于两个不同的尺度；注意 \"Plant\" 其实并不是具体的器官，因此推荐更常用“尺度”这个词。","category":"section"},{"location":"prerequisites/key_concepts.html#多尺度建模","page":"关键概念","title":"多尺度建模","text":"多尺度建模指的是同时在多个细致层次下对系统进行模拟。有些模型可能在器官尺度运行，另一些模型可能在地块（plot）尺度运行。每个模型可以（如有需要）访问其本尺度以及其他尺度的变量，从而得到对系统更全面的表现。这种方法还可以帮助识别在单一层次下难以发现的新兴特征。\n\n例如，可以在叶尺度下采用光合模型，与在植株尺度下的碳分配模型结合，以模拟植物的生长与发育。又如，模拟森林的能量平衡时，既需要针对植物的每一种器官类型的模型，也需要土壤层面的模型，最后还需有一个整合所有模型的地块（plot）尺度模型。\n\n当进行多尺度模拟（即包含在植物不同器官层级上运行的模型）时，用户需要额外提供信息，以指明模型运行所需的尺度。由于有些模型在不同器官层级间复用，因此有必要说明每个模型所作用的器官（尺度）是什么。\n\n这正是多尺度模拟会用到“映射（mapping）”结构的原因：单尺度示例中的 ModelList 没有办法将模型绑定到具体的植物器官，而那些更灵活的模型可以在多处被用到。用户还需要说明模型间如何跨尺度交互，比如输入变量若来自其他尺度，则必须指明其映射自哪个尺度。\n\n你可以在这里了解作为用户针对单尺度与多尺度模拟的实际差异：多尺度建模的注意事项。\n\nnote: Note\n当你遇到“单尺度模拟”（Single-scale simulations）或“ModelList 模拟”这样的术语时，它们均指“不具备多尺度映射的模拟”。多尺度模拟使用了器官/尺度之间的映射；而单尺度模拟则没有这种映射，仅使用更简单的 ModelList 接口。当然，你完全可以实现一个仅包含单一尺度层级的映射，这可称为“单尺度的多尺度模拟”。但除非特别说明，单尺度以及所有关于单尺度模拟的章节默认均指的是 ModelList 对象及无映射结构的模拟。","category":"section"},{"location":"prerequisites/key_concepts.html#多尺度树图（MTG,-Multi-scale-Tree-Graphs）","page":"关键概念","title":"多尺度树图（MTG, Multi-scale Tree Graphs）","text":"(Image: 禾本科植物及其等价 MTG)\n\n一个禾本科植物与对应的 MTG\n\n多尺度树图（Multi-scale Tree Graphs，简称 MTG）是一种用于表示植物结构的数据结构。有关 MTG 格式与属性的详细介绍，请参考 MultiScaleTreeGraph.jl 软件包文档。\n\n多尺度模拟可以直接在 MTG 对象上操作；随着植物生长、产生新器官，将会向 MTG 添加对应的新节点。\n\n你可以在 REPL 中直接输入 MTG 的变量名，获得其基本的信息展示：\n\n(Image: 在 PlantSimEngine 中 MTG 展示的例子)\n\nnote: Note\n另一个配套包 PlantGeom.jl 也可以通过 .opf 文件（对应 Open Plant Format，用于计算机上描述植物的另一种格式）来创建 MTG 对象。","category":"section"},{"location":"prerequisites/key_concepts.html#尺度-/-符号（symbol）术语的混淆","page":"关键概念","title":"尺度 / 符号（symbol）术语的混淆","text":"多尺度树图（MTG）中的一些术语与 PlantSimEngine 不完全相同（参见 器官 / 尺度（Organ/Scale））：\n\nMTG 节点的 symbol（符号） 指代像 \"Plant\"、\"Root\"、\"Scene\" 或 \"Leaf\" 这样的实体。它对应 PlantSimEngine 中的 尺度，与 Julia 语言中 :var 这种符号类型没有关系。\nMTG 节点的 scale（尺度） 是传递给 Node 构造器的一个整数，用于描述树图对象的描述层级。它与 symbol（或 PlantSimEngine 的尺度）通常不是一一对应的，但二者是类似的概念。\n\n(Image: MTG 上的三级尺度，与 PlantSimEngine 中尺度概念不同)\n\n你可以在 这里 找到对 MTG 概念的简要介绍。\n\n另外，某些词在不同语境下也常被复用且含义不同：比如 tree/leaf/root 在谈论计算机科学数据结构（如图、依赖图、树结构）时意义与生物学不同。\n\nnote: Note\n在绝大多数情况下，你可以假定带有 “tree（树）” 的术语指的是生物学意义上的树，\"organ（器官）\" 指的是植物器官，而 “single-scale（单尺度）”、“multi-scale（多尺度）” 以及 “scale（尺度）” 则指的是 PlantSimEngine 中 器官 / 尺度（Organ/Scale） 章节介绍的尺度概念。MTG 对象一般以每个节点（指图中的节点，不是生物学器官节点）为操作单元进行处理。仅当模型涉及 MTG 遍历相关函数时，才通常会用到计算机科学里数据结构的术语。","category":"section"},{"location":"prerequisites/key_concepts.html#TLDR","page":"关键概念","title":"TLDR","text":"总结如下：\n\n在 PlantSimEngine 中，\"尺度\" 指的是用名称（String）定义的描述层级；而在 MTG 中，\"尺度\" 是一个表示节点描述层级的整数，\"符号（symbol）\" 是该节点的名称。因此，MTG 中的 symbol 通常等价于 PlantSimEngine 中的 scale；\n“节点（node）”一词总是指多尺度树图（MTG）中的节点，而不是植物学意义上的“节”。","category":"section"},{"location":"prerequisites/key_concepts.html#状态机","page":"关键概念","title":"状态机","text":"状态机是建模各种机制和装置的经典计算模型，这一点对于你的模拟也许有参考价值。\n\n(Image: State machine image) 一个简单的状态机。更多示例可参见 维基百科页面。\n\n状态机可以用于描述器官的状态：在 XPalm.jl（一个基于 PlantSimEngine 建模油棕榈的包）中，部分器官有一个类似状态机的 state 变量，用于表示该器官是否为成熟、已修剪、开花等状态。\n\n你可以在 XPalm 油棕 FSPM 的此处找到一个根据器官年龄和积温对 state 变量进行改变的模型示例（以及其他类似模型）。","category":"section"},{"location":"multiscale/multiscale_example_4.html#使用-PlantGeom-可视化植物","page":"用 PlantGeom 可视化玩具植株","title":"使用 PlantGeom 可视化植物","text":"我们已经创建了我们的玩具植物，其中一个有趣的部分就是实际将其可视化！\n\n让我们来看看如何用 PlantGeom 辅助包实现这一点。\n\n我们将重复使用植物教程第 3 部分生成的 mtg：修复植物模拟中的Bug。因此，你需要先运行那部分的模拟，或者将相应的脚本文件包含进当前的代码（这里我们选择包含脚本文件）：\n\nusing PlantSimEngine\nusing MultiScaleTreeGraph\nusing PlantSimEngine.Examples\nusing Pkg\nPkg.add(\"CSV\")\nusing CSV\ninclude(\"ToyPlantSimulation3.jl\")\n\n你需要在环境中添加 PlantGeom 以及一个兼容的可视化包。这里我们使用 Plots：\n\nusing Plots\nusing PlantGeom\n\n仅需这些步骤，就能比在控制台打印 MTG 有更好的显示效果。你只需输入下方一行代码即可：\n\nRecipesBase.plot(mtg)\n\n效果如下图所示： (Image: MTG Plots visualization)\n\n就这样！\n\n我们可以看到根朝一个方向扩展，而节间和它们的叶片则朝另一个方向生长。\n\n当然，这样已经挺好了，但我们还可以更进一步。\n\nPlantGeom 能够根据 MTG 中的信息渲染几何体。如果树图中的某个节点有一个带有网格和变换的 :geometry 属性，它就能利用这些信息来构建植物结构。这个网格可以是每个节点独有的，也可以是基于一个参考网格，对每个节点进行复制和变换得到。\n\nnote: Note\n本页面只是用于演示 PlantGeom 的功能，并没有追求非常真实或美观的可视化效果。一些随机性可以让植物看起来更有生机，但这样做也会让代码更难理解和维护，因此这里没有采用。\n\n我们的 MTG 目前还没有这样的属性，所以我们需要遍历每个节点，给它们分配网格并计算合适的变换方式。对于相关的三个尺度：节间、根和叶片，我们将分别用一个参考网格。\n\n我们会用到 Meshes 包中的一些基础几何体和变换函数，还需要用到 TransformsBase 和 Rotations 包中的一些辅助函数。对于叶片，我们将用 PlyIO 包读取一个 .ply 文件，这里面存有一个非常简化的叶片+叶柄网格。\n\n另外，我们还将让植物呈现对生十字排列（opposite decussate）：每对叶片成对出现，且每对之间沿茎轴旋转 90 度。\n\n用于给节点添加几何体属性的函数如下：\n\nPlantGeom.Geometry(; ref_mesh<:RefMesh, transformation=Identity(), dUp=1.0, dDwn=1.0, mesh::Union{SimpleMesh,Nothing}=nothing)\n\n对于本例，我们只需要关心前两个参数。对于每一个单一的节间和根节点，可以直接使用简单的圆柱作为网格。\n\nusing PlantGeom.Meshes\n\n# 节间和根将使用圆柱体作为网格\n\ncylinder() = Meshes.CylinderSurface(1.0) |> Meshes.discretize |> Meshes.simplexify\n\nrefmesh_internode = PlantGeom.RefMesh(\"Internode\", cylinder())\nrefmesh_root = PlantGeom.RefMesh(\"Root\", cylinder())\n\n一个用于从 .ply 文件读取叶片顶点和面信息的简单函数：\n\nPkg.add(\"PlyIO\")\nusing PlyIO\nfunction read_ply(fname)\n    ply = PlyIO.load_ply(fname)\n    x = ply[\"vertex\"][\"x\"]\n    y = ply[\"vertex\"][\"y\"]\n    z = ply[\"vertex\"][\"z\"]  \n    points = Meshes.Point.(x, y, z)\n    connec = [Meshes.connect(Tuple(c .+ 1)) for c in ply[\"face\"][\"vertex_indices\"]]\n    Meshes.SimpleMesh(points, connec)\nend\n\nleaf_ply = read_ply(\"examples/leaf_with_petiole.ply\")\nrefmesh_leaf = PlantGeom.RefMesh(\"Leaf\", leaf_ply)\n\nPkg.add(\"TransformsBase\")\nPkg.add(\"Rotations\")\nimport TransformsBase: →\nimport Rotations: RotY, RotZ, RotX\n\nnote: Note\n我们将使用 X、Y、Z 作为标准的笛卡尔坐标轴，其中 Z 轴朝上。\n\n接下来可以编写一个函数，为我们的 MTG 添加几何信息。\n\n该函数从基部节点开始遍历 MTG，并为每个遇到的节点添加变换信息。\n\n下面的代码仅针对节间（为便于理解）：\n\n# 给MTG添加几何信息，并进行变换\nfunction add_geometry!(mtg, refmesh_internode) \n    \n    # 节间的累加偏移高度\n    internode_height = 0.0\n\n    # 基础网格的相对缩放比例（基准圆柱半径为1）\n    internode_width = 0.5\n\n    # 基础网格的长度\n    internode_length = 1.0\n\n    traverse!(mtg) do node\n        if symbol(node) == \"Internode\"\n            # 先缩放，再根据累计高度进行平移\n            mesh_transformation = Meshes.Scale(internode_width, internode_width, internode_length) → Meshes.Translate(0.0, 0.0, internode_height)\n            node.geometry = PlantGeom.Geometry(ref_mesh=refmesh_internode, transformation=mesh_transformation)\n            \n            internode_height += node_length\n        end\n    end\nend\n\n我们只需要为茎干选择一个宽度，并在遍历时逐步递增高度，将下一个节间放置到正确的位置。\n\n注意 Meshes.jl 提供的默认圆柱体朝上，因此无需旋转。根的处理也类似，只需向下平移，并且需要从原点下方开始。\n\n我们可以使用 GLMakie 渲染后端可视化这个简单的茎结构：\n\nadd_geometry!(mtg, refmesh_internode)\n\n# 可视化网格\nusing GLMakie\nviz(mtg)\n\n(Image: 玩具植物——仅有茎)\n\n另一方面，叶片的网格需要进行旋转，但它本身已经沿 X 轴对齐，因此不需要像圆柱一样做初始的重新定向。叶柄起点在原点，所以除了把它们平移到叶片的高度之外，还需要根据节间半径在 Z 轴方向之外进行平移。由于叶子网格本身长度只有 0.1 单位，而我们的节间宽度有 0.5，因此还需要进行缩放。\n\n我们还可以将叶片稍微上抬，使其略微朝上。\n\n如果你使用了其他网格，请注意它们的初始平移、朝向和缩放，通常需要多次试验和调整比例及变换参数才能得到理想效果。\n\n下面给出用于为玩具植物所有器官添加几何体的完整代码：\n\n# 为MTG添加各器官的几何信息及变换\nfunction add_geometry!(mtg, refmesh_internode, refmesh_root, refmesh_leaf) \n    \n    # 节间的累加高度，根的累加深度\n    internode_height = 0.0\n    root_depth = 0.0\n\n    # 基础网格的相对缩放比例（基础圆柱高度为1，半径为1）\n    internode_width = 0.5\n    root_width = 0.2\n\n    # 基础网格的长度\n    internode_length = 1.0\n    root_length = 1.0\n\n    # 用于调整叶片网格到场景比例的经验系数\n    leaf_mesh_scale = 25\n\n    leaf_scale_width = 0.4 * leaf_mesh_scale\n    leaf_scale_height = 0.4 * leaf_mesh_scale\n    \n    # 用于实现叶片对生轮换的辅助参数\n    leaf_rotation = MathConstants.pi / 2.0\n    i = 0\n\n    traverse!(mtg) do node\n        if symbol(node) == \"Internode\"\n            # 先缩放，再按累计高度平移\n            mesh_transformation = Meshes.Scale(internode_width, internode_width, internode_length) → Meshes.Translate(0.0, 0.0, internode_height)\n            node.geometry = PlantGeom.Geometry(ref_mesh=refmesh_internode, transformation=mesh_transformation)\n            \n            internode_height += internode_length\n\n            # 叶片相对于母节间，在节间长度的一半处放置\n            for chnode in children(node)               \n                if symbol(chnode) == \"Leaf\" \n                    mesh_transformation = Meshes.Scale(leaf_scale_width, leaf_scale_width, leaf_scale_height) → Meshes.Rotate(RotX(-MathConstants.pi / 6.0)) → Meshes.Translate(0.0, -internode_width, internode_height - internode_length / 2.0) → Meshes.Rotate(RotZ(leaf_rotation))\n                    chnode.geometry = PlantGeom.Geometry(ref_mesh=refmesh_leaf, transformation=mesh_transformation)\n                    # 为实现叶片对生，第二片叶子比第一片多旋转180°\n                    leaf_rotation += MathConstants.pi\n                end                \n            end\n\n            # 对生轮换，每对之间轮换90°\n            i += 1\n            if i % 2 == 0\n                leaf_rotation = MathConstants.pi / 2.0\n            else\n                leaf_rotation = MathConstants.pi\n            end\n\n        elseif symbol(node) == \"Root\"\n            mesh_transformation = Meshes.Scale(root_width, root_width, root_length) → Meshes.Translate(0.0, 0.0, root_depth) → Meshes.Rotate(RotZ(MathConstants.pi))\n            node.geometry = PlantGeom.Geometry(ref_mesh=refmesh_root, transformation=mesh_transformation)\n            root_depth -= root_length\n        end\n    end\nend\n\n现在，让我们来可视化这株完全生长、具备全部特性的植物吧：\n\n# 可视化网格\nusing GLMakie\nviz(mtg)    \n\n你将会得到如下的图像场景：\n\n(Image: 带根和叶片的玩具植物)\n\n欢迎尝试让这棵植物变得更漂亮、更有色彩，或更具物理真实感——你可以在 PlantSimEngine 侧使用更真实的模型，或者在 Plantgeom 端设计更精细的几何结构。","category":"section"},{"location":"prerequisites/julia_basics.html#Julia-入门指南","page":"Julia 语言基础","title":"Julia 入门指南","text":"PlantSimEngine（以及其相关的包）是用 Julia 语言编写的。关于为何选择 Julia 的原因，这里有简要讨论：为什么选择使用 Julia。\n\nJulia 是一门正在快速发展的编程语言，但在科研和数据科学领域还不是最广泛使用的。\n\n如果你有 R、Python 或 Matlab 的编程背景，很多元素会让你感到熟悉，但 Julia 也有一些值得注意的差异。如果你是第一次接触这门语言，可能需要克服一些障碍，才能熟练使用它。\n\n本页面着重列出与 PlantSimEngine 使用相关、最重要的 Julia 内容，并指向能够帮助你掌握这些基础知识的资源。","category":"section"},{"location":"prerequisites/julia_basics.html#编程新手","page":"Julia 语言基础","title":"编程新手","text":"本页面并非完整的 Julia 入门教程。如果你对编程完全不了解，建议先参考其它入门资源，例如 这里。视频课程 Julia Programming for Nervous Beginners（紧张新手的 Julia 编程） 也非常适合没有编程经验的人。","category":"section"},{"location":"prerequisites/julia_basics.html#安装包与环境配置","page":"Julia 语言基础","title":"安装包与环境配置","text":"关于 PlantSimEngine，你可以查阅我们文档中的相关页面:   PlantSimEngine 的安装与运行","category":"section"},{"location":"prerequisites/julia_basics.html#速查表（Cheatsheets）","page":"Julia 语言基础","title":"速查表（Cheatsheets）","text":"你还可以在 这里 找到一些速查表，以及一个简短的入门笔记本和其安装指南。","category":"section"},{"location":"prerequisites/julia_basics.html#故障排查","page":"Julia 语言基础","title":"故障排查","text":"我们有一个文档页面，列举了使用 PlantSimEngine 时常见的一些错误，若你遇到问题可以参考：错误信息排查指南。\n\n如有更多关于 Julia 学习相关的问题，可以在 Discourse 论坛获得快速答复：https://discourse.julialang.org。","category":"section"},{"location":"prerequisites/julia_basics.html#与其他语言的显著区别：","page":"Julia 语言基础","title":"与其他语言的显著区别：","text":"如果你希望将 Julia 与某一种特定语言比较，显著区别部分 可以为你提供简要概览。\n\n（例如，Julia 的数组索引从 1 开始）","category":"section"},{"location":"prerequisites/julia_basics.html#使用-PlantSimEngine-需掌握的-Julia-基本概念","page":"Julia 语言基础","title":"使用 PlantSimEngine 需掌握的 Julia 基本概念","text":"以下是理解和高效使用 PlantSimEngine（除包管理之外）所需的 Julia 语言关键要点列表：\n\n基本概念和构造：\n\n变量、数组、函数、函数参数等基本概念\n类型系统及自定义类型\n字典（Dict）和 NamedTuple（具名元组）对象，这两者在代码中被广泛使用\n\n与部分入门简介相比，Julia 官方手册对这些主题有更深入的解释，因此更适合作为参考工具，而不是初学入口。你也可以参考其他教程或课程，比如 https://julia.quantecon.org/intro.html 的第一章、Learn Julia the Hard Way 草稿的第 0-4,7 章，或交互式的 Mathigon 课程。\n\n还需关注的重要内容：\n\n许多 API 函数使用了关键字参数（kwargs）\n类型提升（Type promotion）、参数展开（splatting）、广播（broadcasting）、以及推导式（comprehensions） 也是很有用的语法（但不是上手必需）\n\n上述知识点在 Julia Data Science 指南 中也有简要介绍，该资源同时关注 DataFrames.jl 的使用。\n\n在使用 Julia 包时，进一步了解方法（methods）、参数化类型与类型系统也是十分值得的。","category":"section"},{"location":"step_by_step/implement_a_model.html#model_implementation_page","page":"实现一个模型","title":"实现一个模型","text":"在你自己的模拟中，你可能会希望在某个阶段不仅仅是使用现有的模型，而是实现你自己的模型。本页将介绍编写新模型所需的步骤。后面有针对编程不太熟悉者的详细版本。","category":"section"},{"location":"step_by_step/implement_a_model.html#快速指南","page":"实现一个模型","title":"快速指南","text":"声明一个新的过程：\n\n@process \"light_interception\" verbose = false\n\n声明你的模型结构体及其参数：\n\nstruct Beer{T} <: AbstractLight_InterceptionModel\n    k::T\nend\n\n为该模型声明 inputs_ 和 outputs_ 方法（注意下划线，这些方法与 inputs 和 outputs 不同）：\n\nfunction PlantSimEngine.inputs_(::Beer)\n    (LAI=-Inf,)\nend\n\nfunction PlantSimEngine.outputs_(::Beer)\n    (aPPFD=-Inf,)\nend\n\n编写针对单步运行的 run! 函数：\n\nfunction run!(::Beer, models, status, meteo, constants, extras)\n    status.PPFD =\n        meteo.Ri_PAR_f *\n        exp(-models.light_interception.k * status.LAI) *\n        constants.J_to_umol\nend\n\n判断是否可以并行化，以及需要声明哪些特征：\n\nPlantSimEngine.ObjectDependencyTrait(::Type{<:Beer}) = PlantSimEngine.IsObjectIndependent()\nPlantSimEngine.TimeStepDependencyTrait(::Type{<:Beer}) = PlantSimEngine.IsTimeStepIndependent()\n\n对于这个包含单个参数且没有依赖关系的示例，以上这些就足够了。\n\n@process 宏会自动实现一些样板代码，详见这里。\n\n你还可以实现一些额外的工具函数来方便用户使用，详情参见模型实现补充说明页面。 如果你的自定义模型需要处理比本例更复杂的输入输出耦合，请参阅耦合更复杂的模型页面。","category":"section"},{"location":"step_by_step/implement_a_model.html#详细版本","page":"实现一个模型","title":"详细版本","text":"PlantSimEngine.jl 的设计初衷是让新的模型实现变得非常简单。让我们通过一个简单的示例来学习如何实现你自己的模型：实现一个新的光截获（light interception）模型。\n\n我们要（重新）实现的模型已经作为示例模型包含在 Examples 子模块中。你可以从这里获取该脚本：examples/Beer.jl。这个模型也可以在 PlantBioPhysics.jl 包中找到。\n\n你可以通过 using 命令将该模型和 PlantSimEngine 的其他示例模型导入你的环境中：\n\n# 导入 `Examples` 子模块中定义的示例模型:\nusing PlantSimEngine.Examples","category":"section"},{"location":"step_by_step/implement_a_model.html#其他示例","page":"实现一个模型","title":"其他示例","text":"PlantSimEngine 的其他简单模型可以在 examples 文件夹 中找到。\n\n更多示例模型可以参考 PlantBiophysics.jl 的代码。例如，你可以在那里找到一个光合作用模型（FvCB），实现代码在 src/photosynthesis/FvCB.jl；还有一个能量平衡模型，其 Monteith 实现在 src/energy/Monteith.jl；或者气孔导度模型在 src/conductances/stomatal/medlyn.jl。","category":"section"},{"location":"step_by_step/implement_a_model.html#基本需求","page":"实现一个模型","title":"基本需求","text":"如果你查看这些示例模型，你会发现要实现一个新的模型，你需要实现如下内容：\n\n一个结构体：用于存储参数值并实现方法多分派\n实际的模型本体：作为“过程”对应的方法来实现\n一些辅助函数：供包内和/或用户调用","category":"section"},{"location":"step_by_step/implement_a_model.html#示例：比尔-朗伯（Beer-Lambert）模型","page":"实现一个模型","title":"示例：比尔-朗伯（Beer-Lambert）模型","text":"","category":"section"},{"location":"step_by_step/implement_a_model.html#过程定义","page":"实现一个模型","title":"过程定义","text":"我们首先使用 @process 宏在第 7 行声明光截获过程：\n\n@process \"light_interception\" verbose = false\n\n关于其工作原理及用法的详细说明，请参见 实现一个新过程 页面。","category":"section"},{"location":"step_by_step/implement_a_model.html#结构体定义","page":"实现一个模型","title":"结构体定义","text":"要实现一个模型，首先要定义一个结构体。这个结构体有两个主要作用：\n\n存储参数值\n派发到对应的 run! 方法\n\n模型结构体（或类型）的定义如下：\n\nstruct Beer{T} <: AbstractLight_InterceptionModel\n    k::T\nend\n\n第一行定义了模型的名称（Beer）。按照惯例，模型名建议采用驼峰命名法，即每个单词首字母大写且不带分隔符，如 LikeThis。\n\nBeer 结构体被定义为 AbstractLight_InterceptionModel 的子类型，表明该模型模拟的是哪一种过程。在定义 \"lightinterception\" 过程时，`AbstractLightInterceptionModel` 类型会被自动创建。\n\n我们可以从模型声明推断出，Beer 是用于模拟光截获过程的模型。\n\n接下来是参数名及其类型的说明。","category":"section"},{"location":"step_by_step/implement_a_model.html#用户自定义类型与参数化类型","page":"实现一个模型","title":"用户自定义类型与参数化类型","text":"这里有一些 Julia 语言的特性，可以让用户在模拟中传递自己定义的类型。\n\nBeer 是一个参数化（泛型）的 struct，这通过 {T} 注解体现。\n结构体中的参数 k 的类型由 ::T 指定，这里的 T 就是类型参数。\n\nT 只是一个任意的字母。如果你的参数有多个、可能属于不同的类型，可以为每个参数指定不同的类型，也可以为其分别参数化，比如再引入一个字母，例如：\n\nstruct CustomModel{T,S} <: AbstractLight_InterceptionModel\n    k::T\n    x::T\n    y::T\n    z::S\nend\n\n参数化类型非常实用，因为它们让用户可以自由选择参数的类型，甚至可以在运行时随需改变。例如，用户可以来自 MonteCarloMeasurements.jl 的 Particles 类型，实现模拟过程中自动的不确定性传播。关于参数化类型的更多信息，推荐查阅模型实现补充说明页面的参数化类型小节。","category":"section"},{"location":"step_by_step/implement_a_model.html#输入与输出","page":"实现一个模型","title":"输入与输出","text":"在实现一个新模型时，必须声明该模型所需的变量，包括作为输入变量（输入到模型中）和每个时间步计算产生的输出变量。输入变量可以由用户在 Status 对象中初始化，也可以由其他模型提供。输出变量可以作为整体模拟的输出，或被其他模型使用。\n\n以本例的 Beer 光截获模型为例，它有一个输入变量和一个输出变量：\n\n输入：:LAI，叶面积指数（单位：m² m⁻²）\n输出：:aPPFD，光合有效光子通量密度（单位：μmol m⁻² s⁻¹）\n\n我们通过给 inputs 和 outputs 函数添加方法来声明这些输入/输出。这些函数以模型类型作为参数，返回一个 NamedTuple，变量名称为键，默认值为值：\n\nfunction PlantSimEngine.inputs_(::Beer)\n    (LAI=-Inf,)\nend\n\nfunction PlantSimEngine.outputs_(::Beer)\n    (aPPFD=-Inf,)\nend\n\n这些函数是内部函数，以下划线“_”结尾。用户实际使用 inputs 和 outputs 来查询模型变量。","category":"section"},{"location":"step_by_step/implement_a_model.html#run!-方法","page":"实现一个模型","title":"run! 方法","text":"当使用 run! 运行模拟时，每一步的每个模型会按模型列表（ModelList）和当前状态（Status）所确定的顺序依次运行。每个模型都实现了 run! 方法，用于在每个时间步更新模拟状态。该函数有六个参数：\n\nfunction run!(::Beer, models, status, meteo, constants, extras)\n\n模型的类型\nmodels：一个 ModelList 对象，包含了模拟中的所有模型\nstatus：一个 Status 对象，包含当前时间步变量的值（即状态），例如此时刻植物的 LAI\nmeteo：（通常）一个 Atmosphere 对象，或气象数据的一行，包含当前时间步的气象变量值（如该时间步的 PAR）\nconstants：一个 Constants 对象或 NamedTuple，包含模拟中用到的常数（如斯特藩-玻尔兹曼常数，单位转换常数等）\nextras：可传递给模型的其他任何对象，主要用于高级应用，这里不做介绍\n\n因此，典型的 run! 函数可以利用模拟常量、通过 Status 对象访问的输入/输出变量，或气象数据。\n\n以下是基于 ModelList 组件模型的光截获 run! 方法实现。注意输入输出变量通过 status 参数访问：\n\nfunction run!(::Beer, models, status, meteo, constants, extras)\n    status.PPFD =\n        meteo.Ri_PAR_f *\n        exp(-models.light_interception.k * status.LAI) *\n        constants.J_to_umol\nend","category":"section"},{"location":"step_by_step/implement_a_model.html#补充说明","page":"实现一个模型","title":"补充说明","text":"要使用此模型，用户需要确保该模型涉及的变量已经在 Status 对象、气象数据和 Constants 对象中定义。\n\n!!! 注意     Status 对象包含了模拟当前时间步的全部状态。默认情况下，无法直接访问早期时间步的变量，除非你编写了自定义模型以实现这一目标。\n\n模型的参数可以通过 ModelList 并利用传入的 models 参数获得。可通过进程名称以及参数名称索引。例如，Beer 模型的 k 参数可以通过 models.light_interception.k 获取。\n\n!!! 警告     你需要导入所有要扩展的方法，这样 Julia 才会识别你是在为 PlantSimEngine 的函数添加方法，而不是在定义一个新的同名函数。为此，可以在函数前加上包名前缀，或者提前手动导入，例如：import PlantSimEngine: inputs_, outputs_。查看排错子章节 实现新模型时：忘记导入函数或加上模块前缀 可以看到忘记加前缀时可能导致的输出报错。","category":"section"},{"location":"step_by_step/implement_a_model.html#并行化特性","page":"实现一个模型","title":"并行化特性","text":"PlantSimEngine 提供了 traits（特性）机制，用以告知模型的更多信息。目前，实现了两种并行特性：模型是否可以在空间维度（如不同对象）或时间维度（如不同时间步）并行运行。\n\n默认情况下，为保证安全，所有模型都不假定可在对象或时间步上并行。如果你的模型可以并行计算，建议为其添加相应的特性。\n\n例如，如果我们要为 Beer 模型添加“对象无依赖”的并行特性，可以这样写：\n\nPlantSimEngine.ObjectDependencyTrait(::Type{<:Beer}) = PlantSimEngine.IsObjectIndependent()\n\n如果我们要为 Beer 模型添加“时间步无依赖”的并行特性，可以这样写：\n\nPlantSimEngine.TimeStepDependencyTrait(::Type{<:Beer}) = PlantSimEngine.IsTimeStepIndependent()\n\n!!! 注意     当一个模型的计算代码内部未直接调用其他模型时，说明它可以在对象间并行；同样，未直接调用其他时间步的变量时，说明它可以在时间步间并行。实际上，大多数模型总能以某种方式并行，但出于安全，默认假定它们不可并行。\n\n好了！到此为止，针对光截获过程，我们已经实现了一个完整的新模型！其他模型或许会有更复杂的计算逻辑或耦合方式，但实现思路是一致的。","category":"section"},{"location":"step_by_step/implement_a_model.html#依赖关系","page":"实现一个模型","title":"依赖关系","text":"如果你的模型在实现时显式调用了其它模型，则需要明确告知 PlantSimEngine。这称为“硬依赖”关系，与之相对的“软依赖”是指模型仅使用另一模型输出的变量，但没有直接调用对方。\n\n要声明这样的依赖关系，需要为 dep 函数添加一个方法，告诉 PlantSimEngine 该模型运行时依赖于哪些过程（及其模型类型）。\n\n本例中的模型没有直接调用其他模型，因此无需实现该方法。但我们可以参考 PlantBiophysics.jl 中 [Fvcb] 的实现：\n\nPlantSimEngine.dep(::Fvcb) = (stomatal_conductance=AbstractStomatal_ConductanceModel,)\n\n这里，我们告诉 PlantSimEngine，在气孔导度（stomatalconductance）过程中需要一个 `AbstractStomatalConductanceModel类型的模型，以供Fvcb` 模型运行时调用。\n\n关于硬依赖的更多内容，可以参考耦合更复杂的模型。","category":"section"},{"location":"step_by_step/parallelization.html#并行执行","page":"并行化","title":"并行执行","text":"note: Note\n本页内容可能会变动且随着时间变得不再适用。目前，并行执行只适用于单尺度模拟（多尺度模拟因MTG结构随步骤变动及额外复杂性，目前尚不支持直接并行化）","category":"section"},{"location":"step_by_step/parallelization.html#FLoops","page":"并行化","title":"FLoops","text":"PlantSimEngine.jl 使用 FLoops 包以顺序、并行（多线程）或分布式（多进程）方式对对象、时间步、独立进程进行计算和模拟。\n\n这意味着你可以向run!的executor参数提供任何兼容的执行器。默认情况下，run! 使用 ThreadedEx 执行器（多线程执行器）。你也可以使用 SequentialEx 顺序执行（非并行），或使用 DistributedEx 实现分布式计算。","category":"section"},{"location":"step_by_step/parallelization.html#并行特性（trait）","page":"并行化","title":"并行特性（trait）","text":"PlantSimEngine.jl 通过 Holy traits机制定义某个模型是否可以并行运行。\n\nnote: Note\n如果模型在不同时间步之间没有读取或设置其他时间步的值，则可以在时间步上并行；如果模型在对象之间没有读取或设置其他对象的值，则可以在对象上并行。\n\n你可以通过为时间步和对象定义特性（trait），声明模型可并行执行。例如，examples 文件夹中的 ToyLAIModel 模型可以在时间步和对象维度并行运行，因此它定义如下特性：\n\nPlantSimEngine.TimeStepDependencyTrait(::Type{<:ToyLAIModel}) = PlantSimEngine.IsTimeStepIndependent()\nPlantSimEngine.ObjectDependencyTrait(::Type{<:ToyLAIModel}) = PlantSimEngine.IsObjectIndependent()\n\n默认情况下，所有模型都被认为不可并行执行，这是最安全的选择以避免难以察觉的bug。因此，只有需要并行执行的模型才需主动定义这些特性。\n\ntip: Tip\n被声明为可并行执行的模型实际上未必会并行。首先，用户需要将并行执行器（如 ThreadedEx）传递给run!。其次，如果该模型与其他不可并行执行的模型耦合，PlantSimEngine 将以顺序方式运行所有模型。","category":"section"},{"location":"step_by_step/parallelization.html#其他执行器","page":"并行化","title":"其他执行器","text":"你还可以了解 FoldsThreads.jl（更多基于线程的执行器）、FoldsDagger.jl（基于 Dagger.jl 框架、兼容 Transducers.jl 的并行归约）、即将发布的 FoldsCUDA.jl（用于GPU计算，见相关 issue）、及 FoldsKernelAbstractions.jl。你还可以查阅 ParallelMagics.jl，判断是否能自动并行化。\n\n最后，你可以查阅 Transducers.jl 的文档获取更多信息。如果你不清楚什么是\"executor\"，可参见本说明。","category":"section"},{"location":"API/API_examples.html#示例模型","page":"示例模型","title":"示例模型","text":"PlantSimEngine为用户提供了一些示例过程和模型。这些示例包含在子模块Examples中。要在与PlantSimEngine配套的工作环境中访问这些模型，只需使用如下子模块：\n\nusing PlantSimEngine.Examples","category":"section"},{"location":"API/API_examples.html#列表","page":"示例模型","title":"列表","text":"Pages = [\"API_examples.md\"]","category":"section"},{"location":"API/API_examples.html#详情","page":"示例模型","title":"详情","text":"","category":"section"},{"location":"API/API_examples.html#PlantSimEngine.Examples","page":"示例模型","title":"PlantSimEngine.Examples","text":"一个包含示例模型的子模块。\n\n这些示例用于多尺度模型集的文档。 相关模型可在包的 examples 文件夹中找到，具体存储在以下文件：\n\nToyAssimModel.jl\nToyCDemandModel.jl\nToyCAllocationModel.jl\nToySoilModel.jl\n\n示例\n\nusing PlantSimEngine\nusing PlantSimEngine.Examples\nToyAssimModel()\n\n\n\n\n\n","category":"module"},{"location":"API/API_examples.html#PlantSimEngine.Examples.AbstractCarbon_AllocationModel","page":"示例模型","title":"PlantSimEngine.Examples.AbstractCarbon_AllocationModel","text":"carbon_allocation 过程的抽象模型类型。\n\n所有模拟 carbon_allocation 过程的模型都必须为此类型的子类型，例如:  struct MyCarbon_AllocationModel <: AbstractCarbon_AllocationModel end。\n\n可通过 subtypes 查看实现该过程的所有模型：\n\n例子\n\nsubtypes(AbstractCarbon_AllocationModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.AbstractCarbon_AssimilationModel","page":"示例模型","title":"PlantSimEngine.Examples.AbstractCarbon_AssimilationModel","text":"carbon_assimilation 过程的抽象模型类型。\n\n所有模拟 carbon_assimilation 过程的模型都必须为此类型的子类型，例如:  struct MyCarbon_AssimilationModel <: AbstractCarbon_AssimilationModel end。\n\n可通过 subtypes 查看实现该过程的所有模型：\n\n例子\n\nsubtypes(AbstractCarbon_AssimilationModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.AbstractCarbon_BiomassModel","page":"示例模型","title":"PlantSimEngine.Examples.AbstractCarbon_BiomassModel","text":"carbon_biomass 过程的抽象模型类型。\n\n所有模拟 carbon_biomass 过程的模型都必须为此类型的子类型，例如:  struct MyCarbon_BiomassModel <: AbstractCarbon_BiomassModel end。\n\n可通过 subtypes 查看实现该过程的所有模型：\n\n例子\n\nsubtypes(AbstractCarbon_BiomassModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.AbstractCarbon_DemandModel","page":"示例模型","title":"PlantSimEngine.Examples.AbstractCarbon_DemandModel","text":"carbon_demand 过程的抽象模型类型。\n\n所有模拟 carbon_demand 过程的模型都必须为此类型的子类型，例如:  struct MyCarbon_DemandModel <: AbstractCarbon_DemandModel end。\n\n可通过 subtypes 查看实现该过程的所有模型：\n\n例子\n\nsubtypes(AbstractCarbon_DemandModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.AbstractDegreedaysModel","page":"示例模型","title":"PlantSimEngine.Examples.AbstractDegreedaysModel","text":"Degreedays 过程的抽象模型类型。\n\n所有模拟 Degreedays 过程的模型都必须为此类型的子类型，例如:  struct MyDegreedaysModel <: AbstractDegreedaysModel end。\n\n可通过 subtypes 查看实现该过程的所有模型：\n\n例子\n\nsubtypes(AbstractDegreedaysModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.AbstractGrowthModel","page":"示例模型","title":"PlantSimEngine.Examples.AbstractGrowthModel","text":"growth 过程的抽象模型类型。\n\n所有模拟 growth 过程的模型都必须为此类型的子类型，例如:  struct MyGrowthModel <: AbstractGrowthModel end。\n\n可通过 subtypes 查看实现该过程的所有模型：\n\n例子\n\nsubtypes(AbstractGrowthModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.AbstractLai_DynamicModel","page":"示例模型","title":"PlantSimEngine.Examples.AbstractLai_DynamicModel","text":"LAI_Dynamic 过程的抽象模型类型。\n\n所有模拟 LAI_Dynamic 过程的模型都必须为此类型的子类型，例如:  struct MyLai_DynamicModel <: AbstractLai_DynamicModel end。\n\n可通过 subtypes 查看实现该过程的所有模型：\n\n例子\n\nsubtypes(AbstractLai_DynamicModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.AbstractLeaf_SurfaceModel","page":"示例模型","title":"PlantSimEngine.Examples.AbstractLeaf_SurfaceModel","text":"leaf_surface 过程的抽象模型类型。\n\n所有模拟 leaf_surface 过程的模型都必须为此类型的子类型，例如:  struct MyLeaf_SurfaceModel <: AbstractLeaf_SurfaceModel end。\n\n可通过 subtypes 查看实现该过程的所有模型：\n\n例子\n\nsubtypes(AbstractLeaf_SurfaceModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.AbstractLight_InterceptionModel","page":"示例模型","title":"PlantSimEngine.Examples.AbstractLight_InterceptionModel","text":"light_interception 过程的抽象模型类型。\n\n所有模拟 light_interception 过程的模型都必须为此类型的子类型，例如:  struct MyLight_InterceptionModel <: AbstractLight_InterceptionModel end。\n\n可通过 subtypes 查看实现该过程的所有模型：\n\n例子\n\nsubtypes(AbstractLight_InterceptionModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.AbstractLight_PartitioningModel","page":"示例模型","title":"PlantSimEngine.Examples.AbstractLight_PartitioningModel","text":"light_partitioning 过程的抽象模型类型。\n\n所有模拟 light_partitioning 过程的模型都必须为此类型的子类型，例如:  struct MyLight_PartitioningModel <: AbstractLight_PartitioningModel end。\n\n可通过 subtypes 查看实现该过程的所有模型：\n\n例子\n\nsubtypes(AbstractLight_PartitioningModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.AbstractMaintenance_RespirationModel","page":"示例模型","title":"PlantSimEngine.Examples.AbstractMaintenance_RespirationModel","text":"maintenance_respiration 过程的抽象模型类型。\n\n所有模拟 maintenance_respiration 过程的模型都必须为此类型的子类型，例如:  struct MyMaintenance_RespirationModel <: AbstractMaintenance_RespirationModel end。\n\n可通过 subtypes 查看实现该过程的所有模型：\n\n例子\n\nsubtypes(AbstractMaintenance_RespirationModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.AbstractOrgan_EmergenceModel","page":"示例模型","title":"PlantSimEngine.Examples.AbstractOrgan_EmergenceModel","text":"organ_emergence 过程的抽象模型类型。\n\n所有模拟 organ_emergence 过程的模型都必须为此类型的子类型，例如:  struct MyOrgan_EmergenceModel <: AbstractOrgan_EmergenceModel end。\n\n可通过 subtypes 查看实现该过程的所有模型：\n\n例子\n\nsubtypes(AbstractOrgan_EmergenceModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.AbstractProcess1Model","page":"示例模型","title":"PlantSimEngine.Examples.AbstractProcess1Model","text":"process1 过程的抽象模型类型。\n\n所有模拟 process1 过程的模型都必须为此类型的子类型，例如:  struct MyProcess1Model <: AbstractProcess1Model end。\n\n可通过 subtypes 查看实现该过程的所有模型：\n\n例子\n\nsubtypes(AbstractProcess1Model)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.AbstractProcess2Model","page":"示例模型","title":"PlantSimEngine.Examples.AbstractProcess2Model","text":"process2 过程的抽象模型类型。\n\n所有模拟 process2 过程的模型都必须为此类型的子类型，例如:  struct MyProcess2Model <: AbstractProcess2Model end。\n\n可通过 subtypes 查看实现该过程的所有模型：\n\n例子\n\nsubtypes(AbstractProcess2Model)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.AbstractProcess3Model","page":"示例模型","title":"PlantSimEngine.Examples.AbstractProcess3Model","text":"process3 过程的抽象模型类型。\n\n所有模拟 process3 过程的模型都必须为此类型的子类型，例如:  struct MyProcess3Model <: AbstractProcess3Model end。\n\n可通过 subtypes 查看实现该过程的所有模型：\n\n例子\n\nsubtypes(AbstractProcess3Model)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.AbstractProcess4Model","page":"示例模型","title":"PlantSimEngine.Examples.AbstractProcess4Model","text":"process4 过程的抽象模型类型。\n\n所有模拟 process4 过程的模型都必须为此类型的子类型，例如:  struct MyProcess4Model <: AbstractProcess4Model end。\n\n可通过 subtypes 查看实现该过程的所有模型：\n\n例子\n\nsubtypes(AbstractProcess4Model)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.AbstractProcess5Model","page":"示例模型","title":"PlantSimEngine.Examples.AbstractProcess5Model","text":"process5 过程的抽象模型类型。\n\n所有模拟 process5 过程的模型都必须为此类型的子类型，例如:  struct MyProcess5Model <: AbstractProcess5Model end。\n\n可通过 subtypes 查看实现该过程的所有模型：\n\n例子\n\nsubtypes(AbstractProcess5Model)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.AbstractProcess6Model","page":"示例模型","title":"PlantSimEngine.Examples.AbstractProcess6Model","text":"process6 过程的抽象模型类型。\n\n所有模拟 process6 过程的模型都必须为此类型的子类型，例如:  struct MyProcess6Model <: AbstractProcess6Model end。\n\n可通过 subtypes 查看实现该过程的所有模型：\n\n例子\n\nsubtypes(AbstractProcess6Model)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.AbstractProcess7Model","page":"示例模型","title":"PlantSimEngine.Examples.AbstractProcess7Model","text":"process7 过程的抽象模型类型。\n\n所有模拟 process7 过程的模型都必须为此类型的子类型，例如:  struct MyProcess7Model <: AbstractProcess7Model end。\n\n可通过 subtypes 查看实现该过程的所有模型：\n\n例子\n\nsubtypes(AbstractProcess7Model)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.AbstractSoil_WaterModel","page":"示例模型","title":"PlantSimEngine.Examples.AbstractSoil_WaterModel","text":"soil_water 过程的抽象模型类型。\n\n所有模拟 soil_water 过程的模型都必须为此类型的子类型，例如:  struct MySoil_WaterModel <: AbstractSoil_WaterModel end。\n\n可通过 subtypes 查看实现该过程的所有模型：\n\n例子\n\nsubtypes(AbstractSoil_WaterModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.Beer","page":"示例模型","title":"PlantSimEngine.Examples.Beer","text":"Beer(k)\n\nBeer-Lambert law for light interception.\n\nRequired inputs: LAI in m² m⁻². Required meteorology data: Ri_PAR_f, the incident flux of atmospheric radiation in the PAR, in W m[soil]⁻² (== J m[soil]⁻² s⁻¹).\n\nOutput: aPPFD, the absorbed Photosynthetic Photon Flux Density in μmol[PAR] m[leaf]⁻² s⁻¹.\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.Process1Model","page":"示例模型","title":"PlantSimEngine.Examples.Process1Model","text":"Process1Model(a)\n\nA dummy model implementing a \"process1\" process for testing purposes.\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.Process2Model","page":"示例模型","title":"PlantSimEngine.Examples.Process2Model","text":"Process2Model()\n\nA dummy model implementing a \"process2\" process for testing purposes.\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.Process3Model","page":"示例模型","title":"PlantSimEngine.Examples.Process3Model","text":"Process3Model()\n\nA dummy model implementing a \"process3\" process for testing purposes.\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.Process4Model","page":"示例模型","title":"PlantSimEngine.Examples.Process4Model","text":"Process4Model()\n\nA dummy model implementing a \"process4\" process for testing purposes. It computes the inputs needed for the coupled processes 1-2-3.\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.Process5Model","page":"示例模型","title":"PlantSimEngine.Examples.Process5Model","text":"Process5Model()\n\nA dummy model implementing a \"process5\" process for testing purposes. It needs the outputs from the coupled processes 1-2-3.\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.Process6Model","page":"示例模型","title":"PlantSimEngine.Examples.Process6Model","text":"Process6Model()\n\nA dummy model implementing a \"process6\" process for testing purposes. It needs the outputs from the coupled processes 1-2-3, but also from process 7 that is itself independant.\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.Process7Model","page":"示例模型","title":"PlantSimEngine.Examples.Process7Model","text":"Process7Model()\n\nA dummy model implementing a \"process7\" process for testing purposes. It is independent (needs :var0 only as for Process4Model), but its outputs are used by Process6Model, so it is a soft-coupling.\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.ToyAssimGrowthModel","page":"示例模型","title":"PlantSimEngine.Examples.ToyAssimGrowthModel","text":"ToyAssimGrowthModel(Rm_factor, Rg_cost)\nToyAssimGrowthModel(; LUE=0.2, Rm_factor = 0.5, Rg_cost = 1.2)\n\nComputes the biomass growth of a plant.\n\nArguments\n\nLUE=0.2: the light use efficiency, in gC mol[PAR]⁻¹\nRm_factor=0.5: the fraction of assimilation that goes into maintenance respiration\nRg_cost=1.2: the cost of growth maintenance, in gram of carbon biomass per gram of assimilate\n\nInputs\n\naPPFD: the absorbed photosynthetic photon flux density, in mol[PAR] m⁻² time-step⁻¹\n\nOutputs\n\ncarbon_assimilation: the assimilation, in gC m⁻² time-step⁻¹\nRm: the maintenance respiration, in gC m⁻² time-step⁻¹\nRg: the growth respiration, in gC m⁻² time-step⁻¹\nbiomass_increment: the daily biomass increment, in gC m⁻² time-step⁻¹\nbiomass: the plant biomass, in gC m⁻² time-step⁻¹\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.ToyAssimModel","page":"示例模型","title":"PlantSimEngine.Examples.ToyAssimModel","text":"ToyAssimModel(LUE)\n\nComputes the assimilation of a plant (= photosynthesis).\n\nArguments\n\nLUE=0.2: the light use efficiency, in gC mol[PAR]⁻¹\n\nInputs\n\naPPFD: the absorbed photosynthetic photon flux density, in mol[PAR] m⁻² time-step⁻¹\nsoil_water_content: the soil water content, in %\n\nOutputs\n\ncarbon_assimilation: the assimilation or photosynthesis, also sometimes denoted A, in gC m⁻² time-step⁻¹\n\nDetails\n\nThe assimilation is computed as the product of the absorbed photosynthetic photon flux density (aPPFD) and the light use efficiency (LUE), so the units of the assimilation usually are in gC m⁻² time-step⁻¹, but they could be in another spatial or temporal unit depending on the unit of aPPFD, e.g.  if aPPFD is in mol[PAR] plant⁻¹ time-step⁻¹, the assimilation will be in gC plant⁻¹ time-step⁻¹.\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.ToyCAllocationModel","page":"示例模型","title":"PlantSimEngine.Examples.ToyCAllocationModel","text":"ToyCAllocationModel()\n\nComputes the carbon allocation to each organ of a plant based on the plant total carbon offer and individual organ demand. This model should be used at the plant scale, because it first computes the carbon availaible for allocation as the minimum between the total demand  (sum of organs' demand) and total carbon offer (sum of organs' assimilation - total maintenance respiration), and then allocates the carbon relative  to each organ's demand.\n\nInputs\n\ncarbon_assimilation: a vector of the assimilation of all photosynthetic organs, usually in gC m⁻² time-step⁻¹\nRm: the maintenance respiration of the plant, usually in gC m⁻² time-step⁻¹\ncarbon_demand: a vector of the carbon demand of the organs, usually in gC m⁻² time-step⁻¹\n\nOutputs\n\ncarbon_assimilation: the carbon assimilation, usually in gC m⁻² time-step⁻¹\n\nDetails\n\nThe units usually are in gC m⁻² time-step⁻¹, but they could be in another spatial or temporal unit depending on the unit of the inputs, e.g. in gC plant⁻¹ time-step⁻¹.\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.ToyCBiomassModel","page":"示例模型","title":"PlantSimEngine.Examples.ToyCBiomassModel","text":"ToyCBiomassModel(construction_cost)\n\nComputes the carbon biomass of an organ based on the carbon allocation and construction cost.\n\nArguments\n\nconstruction_cost: the construction cost of the organ, usually in gC gC⁻¹. Should be understood as the amount of carbon needed to build 1g of carbon biomass.\n\nInputs\n\ncarbon_allocation: the carbon allocation to the organ for the time-step, usually in gC m⁻² time-step⁻¹\n\nOutputs\n\ncarbon_biomass_increment: the increment of carbon biomass, usually in gC time-step⁻¹\ncarbon_biomass: the carbon biomass, usually in gC\ngrowth_respiration: the growth respiration, usually in gC time-step⁻¹\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.ToyCDemandModel","page":"示例模型","title":"PlantSimEngine.Examples.ToyCDemandModel","text":"ToyCDemandModel(optimal_biomass, development_duration)\nToyCDemandModel(; optimal_biomass, development_duration)\n\nComputes the carbon demand of an organ depending on its biomass under optimal conditions and the duration of its development in degree days. The model assumes that the carbon demand is linear througout the duration of the development.\n\nArguments\n\noptimal_biomass: the biomass of the organ under optimal conditions, in gC\ndevelopment_duration: the duration of the development of the organ, in degree days\n\nInputs\n\nTT: the thermal time, in degree days\n\nOutputs\n\ncarbon_demand: the carbon demand, in gC\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.ToyDegreeDaysCumulModel","page":"示例模型","title":"PlantSimEngine.Examples.ToyDegreeDaysCumulModel","text":"ToyDegreeDaysCumulModel(;init_TT=0.0, T_base=10.0, T_max=43.0)\n\nComputes the thermal time in degree days and cumulated degree-days based on the average daily temperature (T), the initial cumulated degree days, the base temperature below which there is no growth, and the maximum  temperature for growh.\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.ToyInternodeEmergence","page":"示例模型","title":"PlantSimEngine.Examples.ToyInternodeEmergence","text":"ToyInternodeEmergence(;init_TT=0.0, TT_emergence = 300)\n\nComputes the organ emergence based on cumulated thermal time since last event.\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.ToyLAIModel","page":"示例模型","title":"PlantSimEngine.Examples.ToyLAIModel","text":"ToyLAIModel(;max_lai=8.0, dd_incslope=800, inc_slope=110, dd_decslope=1500, dec_slope=20)\n\nComputes the Leaf Area Index (LAI) based on a sigmoid function of thermal time.\n\nArguments\n\nmax_lai: the maximum LAI value\ndd_incslope: the thermal time at which the LAI starts to increase\ninc_slope: the slope of the increase\ndd_decslope: the thermal time at which the LAI starts to decrease\ndec_slope: the slope of the decrease\n\nInputs\n\nTT_cu: the cumulated thermal time since the beginning of the simulation, usually in °C days\n\nOutputs\n\nLAI: the Leaf Area Index, usually in m² m⁻²\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.ToyLAIfromLeafAreaModel","page":"示例模型","title":"PlantSimEngine.Examples.ToyLAIfromLeafAreaModel","text":"ToyLAIfromLeafAreaModel()\n\nComputes the Leaf Area Index (LAI) of the scene based on the plants leaf area.\n\nArguments\n\nscene_area: the area of the scene, usually in m²\n\nInputs\n\nsurface: a vector of plant leaf surfaces, usually in m²\n\nOutputs\n\nLAI: the Leaf Area Index of the scene, usually in m² m⁻²\ntotal_surface: the total surface of the plants, usually in m²\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.ToyLeafSurfaceModel","page":"示例模型","title":"PlantSimEngine.Examples.ToyLeafSurfaceModel","text":"ToyLeafSurfaceModel(SLA)\n\nComputes the individual leaf surface from its biomass using the SLA.\n\nArguments\n\nSLA: the specific leaf area, usually in m² gC⁻¹. Should be understood as the surface area of a leaf per unit of carbon biomass.\n\nValues typically range from 0.002 to 0.027 m² gC⁻¹.\n\nInputs\n\ncarbon_biomass: the carbon biomass of the leaf, usually in gC\n\nOutputs\n\nsurface: the leaf surface, usually in m²\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.ToyLightPartitioningModel","page":"示例模型","title":"PlantSimEngine.Examples.ToyLightPartitioningModel","text":"ToyLightPartitioningModel()\n\nComputes the light partitioning based on relative surface.\n\nInputs\n\naPPFD: the absorbed photosynthetic photon flux density at the larger scale (e.g. scene), in mol[PAR] m⁻² time-step⁻¹ \n\nOutputs\n\naPPFD: the assimilation or photosynthesis, also sometimes denoted A, in gC time-step⁻¹\n\nDetails\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.ToyMaintenanceRespirationModel","page":"示例模型","title":"PlantSimEngine.Examples.ToyMaintenanceRespirationModel","text":"RmQ10FixedN(Q10, Rm_base, T_ref, P_alive, nitrogen_content)\n\nMaintenance respiration based on a Q10 computation with fixed nitrogen values  and proportion of living cells in the organs.\n\nArguments\n\nQ10: Q10 factor (values should usually range between: 1.5 - 2.5, with 2.1 being the most common value)\nRm_base: Base maintenance respiration (gC gDM⁻¹ time-step⁻¹). Should be around 0.06.\nT_ref: Reference temperature at which Q10 was measured (usually around 25.0°C)\nP_alive: proportion of living cells in the organ\nnitrogen_content: nitrogen content of the organ (gN gC⁻¹)\n\nInputs\n\ncarbon_biomass: the carbon biomass of the organ in gC\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.ToyPlantLeafSurfaceModel","page":"示例模型","title":"PlantSimEngine.Examples.ToyPlantLeafSurfaceModel","text":"ToyPlantLeafSurfaceModel()\n\nComputes the leaf surface at plant scale by summing the individual leaf surfaces.\n\nInputs\n\nleaf_surfaces: a vector of leaf surfaces, usually in m²\n\nOutputs\n\nsurface: the leaf surface at plant scale, usually in m²\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.ToyPlantRmModel","page":"示例模型","title":"PlantSimEngine.Examples.ToyPlantRmModel","text":"ToyPlantRmModel()\n\nTotal plant maintenance respiration based on the sum of Rm_organs, the maintenance respiration of the organs.\n\nIntputs\n\nRm_organs: a vector of maintenance respiration from all organs in the plant in gC time-step⁻¹\n\nOutputs\n\nRm: the total plant maintenance respiration in gC time-step⁻¹\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.ToyRUEGrowthModel","page":"示例模型","title":"PlantSimEngine.Examples.ToyRUEGrowthModel","text":"ToyRUEGrowthModel(efficiency)\n\nComputes the carbon biomass increment of a plant based on the radiation use efficiency principle.\n\nArguments\n\nefficiency: the radiation use efficiency, in gC[biomass] mol[PAR]⁻¹\n\nInputs\n\naPPFD: the absorbed photosynthetic photon flux density, in mol[PAR] m⁻² time-step⁻¹\n\nOutputs\n\nbiomass_increment: the daily biomass increment, in gC[biomass] m⁻² time-step⁻¹\nbiomass: the plant biomass, in gC[biomass] m⁻² time-step⁻¹\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.ToySoilWaterModel","page":"示例模型","title":"PlantSimEngine.Examples.ToySoilWaterModel","text":"ToySoilWaterModel(values=[0.5])\n\nA toy model to compute the soil water content. The model simply take a random value in the values range using rand.\n\nOutputs\n\nsoil_water_content: the soil water content (%).\n\nArguments\n\nvalues: a range of soil_water_content values to sample from. Can be a vector of values [0.5,0.6] or a range 0.1:0.1:1.0. Default is [0.5].\n\n\n\n\n\n","category":"type"},{"location":"API/API_examples.html#PlantSimEngine.Examples.import_mtg_example-Tuple{}","page":"示例模型","title":"PlantSimEngine.Examples.import_mtg_example","text":"import_mtg_example()\n\n返回一个带有场景、土壤和一株带有两个节间和两个叶片的植物的多尺度树图（MTG）示例。\n\n示例\n\njulia> using PlantSimEngine.Examples\n\njulia> import_mtg_example()\n/ 1: Scene\n├─ / 2: Soil\n└─ + 3: Plant\n   └─ / 4: Internode\n      ├─ + 5: Leaf\n      └─ < 6: Internode\n         └─ + 7: Leaf\n\n\n\n\n\n","category":"method"},{"location":"API/API_examples.html#PlantSimEngine.fit-Tuple{Type{PlantSimEngine.Examples.Beer}, Any}","page":"示例模型","title":"PlantSimEngine.fit","text":"fit(::Type{Beer}, df; J_to_umol=PlantMeteo.Constants().J_to_umol)\n\nCompute the k parameter of the Beer-Lambert law from measurements.\n\nArguments\n\n::Type{Beer}: the model type\ndf: a DataFrame with the following columns:\naPPFD: the measured absorbed Photosynthetic Photon Flux Density in μmol[PAR] m[leaf]⁻² s⁻¹\nLAI: the measured leaf area index in m² m⁻²\nRi_PAR_f: the measured incident flux of atmospheric radiation in the PAR, in W m[soil]⁻² (== J m[soil]⁻² s⁻¹)\n\nExamples\n\nImport the example models defined in the Examples sub-module:\n\nusing PlantSimEngine\nusing PlantSimEngine.Examples\n\nCreate a model list with a Beer model, and fit it to the data:\n\nm = ModelList(Beer(0.6), status=(LAI=2.0,))\nmeteo = Atmosphere(T=20.0, Wind=1.0, P=101.3, Rh=0.65, Ri_PAR_f=300.0)\nrun!(m, meteo)\ndf = DataFrame(aPPFD=m[:aPPFD][1], LAI=m.status.LAI[1], Ri_PAR_f=meteo.Ri_PAR_f[1])\nfit(Beer, df)\n\n\n\n\n\n","category":"method"},{"location":"API/API_examples.html#PlantSimEngine.run!","page":"示例模型","title":"PlantSimEngine.run!","text":"run!(::Beer, object, meteo, constants=Constants(), extra=nothing)\n\nComputes the photosynthetic photon flux density (aPPFD, µmol m⁻² s⁻¹) absorbed by an  object using the incoming PAR radiation flux (Ri_PAR_f, W m⁻²) and the Beer-Lambert law of light extinction.\n\nArguments\n\n::Beer: a Beer model, from the model list (i.e. m.light_interception)\nmodels: A ModelList struct holding the parameters for the model with\n\ninitialisations for LAI (m² m⁻²): the leaf area index.\n\nstatus: the status of the model, usually the model list status (i.e. m.status)\nmeteo: meteorology structure, see Atmosphere\nconstants = PlantMeteo.Constants(): physical constants. See PlantMeteo.Constants for more details\nextra = nothing: extra arguments, not used here.\n\nExamples\n\nm = ModelList(Beer(0.5), status=(LAI=2.0,))\n\nmeteo = Atmosphere(T=20.0, Wind=1.0, P=101.3, Rh=0.65, Ri_PAR_q=300.0)\n\nrun!(m, meteo)\n\nm[:aPPFD]\n\n\n\n\n\n","category":"function"},{"location":"model_execution.html#模型执行","page":"模型执行","title":"模型执行","text":"","category":"section"},{"location":"model_execution.html#仿真顺序","page":"模型执行","title":"仿真顺序","text":"PlantSimEngine.jl 利用 ModelList 自动计算模型之间的依赖图，并以正确的顺序运行仿真。在使用 run! 运行仿真时，模型的执行遵循以下简单规则：\n\n首先运行独立模型。若某一模型可以独立于其他模型执行，仅依赖初始化（或不依赖任何内容），则称其为独立模型。\n接下来，运行依赖于其他模型的模型。首先运行那些依赖于独立模型的模型，然后依次运行它们的子模型，再进一步运行它们的子模型……如此递归，直到再也没有子模型可运行。子模型（即依赖关系）分为两类：强依赖和弱依赖：\n强依赖总是先于弱依赖被执行。强依赖指的是被其它模型直接调用的模型。其父模型会将其列为 dep，以声明为强依赖。参见此示例，其中 Process2Model 定义了对模拟 process1 的模型的强依赖。\n弱依赖则按顺序依次执行。如果某模型的一个或多个输入由其他模型计算，则它对这些模型属于弱依赖。若一个弱依赖有多个父节点（例如，两个不同模型分别计算了它的两个输入），则该模型只有在所有父节点都已运行后才会被执行。实际操作中，当访问某个节点时，如果它的某个父节点尚未执行，则该分支的访问会被中止。最终该节点会从最后一个已执行的父节点所在分支被访问与执行。","category":"section"},{"location":"developers.html#开发者指南","page":"开发者指南","title":"开发者指南","text":"本页面面向希望为 PlantSimEngine 做出贡献的开发者，说明了在添加新代码时需要注意的各方面内容。","category":"section"},{"location":"developers.html#参与-PlantSimEngine-开发","page":"开发者指南","title":"参与 PlantSimEngine 开发","text":"开发流程与其他 Julia 包没有不同。请使用 git 克隆代码仓库：https://github.com/VirtualPlantLab/PlantSimEngine.jl。\n\n在测试你的更改时，需要在环境中运行类似 Pkg.develop(\"PlantSimEngine\") 的命令，以便使用你修改后的代码。\n\n我们推荐使用 VSCode 作为 Julia 开发的集成开发环境（IDE）。开发过程中主要遵循官方文档的 Julia 代码规范。\n\n在完成必要的代码检查后（详见下方的 PR 提交前检查清单），即可创建 Pull Request；如有添加新内容的需求，也可申请加入贡献者名单。\n\n本开发文档包含 路线图。已知问题与相关讨论可在此处查阅。部分内容已过期，部分为功能讨论，其余为真实缺陷或改进建议。\n\n更多细节问题，欢迎在 Issue 页面中提出，或直接在你的 Pull Request 中说明。","category":"section"},{"location":"developers.html#快速指南","page":"开发者指南","title":"快速指南","text":"","category":"section"},{"location":"developers.html#测试环境","page":"开发者指南","title":"测试环境","text":"PlantSimEngine 提供了多个开发者用的测试环境：\n\n/PlantSimEngine/test：用于检查代码是否存在回归问题。\n/PlantSimEngine/test/downstream：该文件夹包含了一些关于 PlantSimEngine、PlantBioPhysics 和 XPalm 的基准测试。它们会作为 Github Action 运行，以确保你的更改不会导致依赖 PlantSimEngine 的其它包出现性能下降。如果你希望在本地运行这些测试，需要能访问上述依赖包的版本。请注意，这与 Github Action 里进行集成检查、防止意外破坏性更改的步骤是分开的。\n/PlantSimEngine/docs：用于生成文档。文档生成过程会实际运行部分代码，部分 API 函数的文档中也会作为 jldoctest 实例进行测试。","category":"section"},{"location":"developers.html#运行标准测试集","page":"开发者指南","title":"运行标准测试集","text":"只需在测试环境下执行 /PlantSimEngine/test/runtests.jl 即可运行标准测试集。请注意，如果要运行多线程测试，必须以多线程方式启动 Julia。\n\n你还需要安装配套包 PlantMeteo 和 MultiScaleTreeGraph，以及其它 Julia 包，如 DataFrames、CSV、Documenter、Test、Aqua 和 Tables。","category":"section"},{"location":"developers.html#下游测试","page":"开发者指南","title":"下游测试","text":"在已正确添加 XPalm 和 PlantBioPhysics 后，可执行 /PlantSimEngine/test/downstream/test/test-all-benchmarks.jl 运行下游测试。你可能需要为本地运行这个脚本再安装某些包。","category":"section"},{"location":"developers.html#构建文档","page":"开发者指南","title":"构建文档","text":"在 /PlantSimEngine/docs 环境下，运行 /PlantSimEngine/docs/make.jl 来构建文档。这里可能需要用到在其它地方不强制要求的包（Documenter、CairoMakie、PlantGeom）。","category":"section"},{"location":"developers.html#编辑基准测试（benchmarks）","page":"开发者指南","title":"编辑基准测试（benchmarks）","text":"⁃ 如果你希望某个分支在每次提交后都自动运行基准测试，需要在 Github Action 的基准测试 yml 文件中声明该分支：https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/main/.github/workflows/benchmarksanddownstream.yml，并把你的分支名添加到 on: push: 这一段中。 ⁃ 你可以在这里查看基准测试结果：https://virtualplantlab.github.io/PlantSimEngine.jl/dev/bench/index.html。目前这些基准测试还在完善中，还没有经过充分验证。 ⁃ 偶尔你可能需要更新或删除某个基准测试，这时需要手动到 gh-pages 分支下的 dev/bench/index.html 文件中删除对应内容。 ⁃ 实际基准测试的列表是在 test/downstream 文件夹中维护的。","category":"section"},{"location":"developers.html#需要特别关注的事项","page":"开发者指南","title":"需要特别关注的事项","text":"","category":"section"},{"location":"developers.html#检查下游测试","page":"开发者指南","title":"检查下游测试","text":"⁃ 如果你的更改影响到了 API，那么可能会影响到依赖 PlantSimEngine 的其它包。部分基准测试会调用其它包，可以通过它们进行检测；此外有一个专门的 GitHub Action：[https://github.com/VirtualPlantLab/PlantSimEngine.jl/blob/main/.github/workflows/Integration.yml]，会运行其它下游包的测试。如果这个 Action 失败，通常说明引入了尚未在下游包中修正的破坏性更改。如果你本身预计是破坏性更改，且已正确设置了发布标签，则不会导致失败。 ⁃ 请注意，这些测试流程（据我理解）并不会构建文档，因此不会覆盖到文档相关的问题。 ⁃ API 的更改也可能影响下游包的文档和测试……","category":"section"},{"location":"developers.html#哪些文档页面可能会受更改影响","page":"开发者指南","title":"哪些文档页面可能会受更改影响","text":"根据你的实际更改，不同的文档页面可能会受到影响。功能与 API 更改会影响常规对应部分，但有些不那么直观的后果需要留意：\n\n⁃ 改进用户报错时，可能影响 故障排查（Troubleshooting） 页面。 ⁃ 新增功能可能扩充 技巧与绕过方法（Tips and workarounds） 页面，以及“隐式约定”页面。 ⁃ 部分实验性功能如需记录，可以在后续补充到专门的 API 页面。 ⁃ 路线图中的 \"计划中的特性（Planned features）\" 页面需要同步更新。 ⁃ 还有诸如 致谢（Credits）、核心概念（Key Concepts） 等其它页面。如果 API 用到了新的 Julia 语言特性或新语法，也应考虑更新 Julia 入门 页面。 ⁃ 增加的新示例建议以 doctest 的形式补充。","category":"section"},{"location":"developers.html#预览文档","page":"开发者指南","title":"预览文档","text":"你可以通过如下链接预览与本 PR 相关的生成文档（假设能成功构建，通过 #128 举例）：https://virtualplantlab.github.io/PlantSimEngine.jl/previews/PR128/","category":"section"},{"location":"developers.html#PR-提交前检查清单","page":"开发者指南","title":"PR 提交前检查清单","text":"⁃ 确认你的代码能正常运行   ⁃ 确保重要更改有测试覆盖，并为新增特性撰写了文档   ⁃ 在本地运行 PlantSimEngine 测试集，检查是否有报错   ⁃ 在 Github 上检查受影响的 issue，更新或评论相关 issue，或将其关联到 Pull Request   ⁃ 检查文档受影响的页面（roadmap 等，详见上文），并同步进行更新   ⁃ 构建 PSE 文档，并修复任何因更改导致失败的 doctest   ⁃ 提交你的更改，让 Github Actions 自动执行相关流程   ⁃ 查看 ‘CI’ GitHub Action 是否通过，出错请及时修复   ⁃ 检查下游测试和基准测试相关的 GitHub Actions：       - 如基准测试严重下降，请修正代码。在有需要时添加、更新或移除基准测试       - 如果集成测试/下游测试失败，请进一步排查原因       - 如果修改了 API，也需要检查下游包的文档影响  \n\n完成上述检查后，一般就可以安全地提出合并请求了。","category":"section"},{"location":"developers.html#额外建议","page":"开发者指南","title":"额外建议","text":"⁃ 如果有新的已知问题或遗留 TODO，请将其写在 PR 评论或 issue 里，务必留下记录   ⁃ 最后，别忘了更新本页面和上述清单：如有新增文档页面，该页面也应加入需重点关注目录；如实现了内存分配追踪和类型稳定性检查功能，也请在此补充为发布前检查事项等。","category":"section"},{"location":"developers.html#其它补充建议","page":"开发者指南","title":"其它补充建议","text":"⁃ /PlantSimEngine/test 文件夹里包含了一些基础的辅助函数。其中有一个会输出模型列表、气象数据及输出变量向量，供部分测试作为测试库/矩阵，覆盖面较广。如果你编写了新模型、模型组合，或新增了气象数据，建议补充到测试库中。   ⁃ 新的下游包建议补充到集成和下游包注册表。   ⁃ 特殊的边界情况值得为其单独设置单元测试。新修复的 bug 也请尽量单独添加测试，即便修复本身很简单。","category":"section"},{"location":"developers.html#代码库值得注意的方面","page":"开发者指南","title":"代码库值得注意的方面","text":"","category":"section"},{"location":"developers.html#自动模型生成","page":"开发者指南","title":"自动模型生成","text":"有一个特殊功能需要动态生成模型，以支持在多尺度模拟中向 Status 对象传递向量。未来还可能会有更多需要生成模型的功能。\n\n当前的解决方案利用了 Julia 语言中较为脆弱的特性 eval()，此方法存在一些细节和坑点。你可以在这里或这里查看更多关于 world age 问题的讨论。\n\n相关的实现文件为 model_generation_from_status_vectors.jl，其中有更多的注释说明。\n\n需要特别留意的是，如果你调用了用 eval() 生成模型的函数，只有回到顶层作用域，这些更改才会对外可见。你可以参考 tests/helper_functions.jl 里的 test_filtered_output_begin 和 test_filtered_output 两个函数。前者会调用 modellist_to_mapping，该函数会临时生成一些模型，用于在 ModelList 和伪多尺度映射之间转换 status 向量。为了返回到全局作用域，将函数拆成了两段，这样 eval() 所做的更改才能在后续全局可用。后一个函数随后就可以使用这些生成的模型在新的映射上执行仿真并完成测试。\n\n如果因为 eval() 出现相关问题，报错往往非常有指向性：比如报某个带有 UUID 后缀的临时模型在 Main 模块里找不到等。\n\n也许有更好的方式可以避免这些问题，但目前采用的是该方案。调用该文件的函数时务必格外谨慎，注意是否有“函数被拆成两段”的注释。","category":"section"},{"location":"developers.html#天气/步长/状态组合","page":"开发者指南","title":"天气/步长/状态组合","text":"并非所有天气数据结构/天气数据量/状态向量大小的组合都在 PlantSimEngine 主体中被测试。一些更完整的组合被 PlantBioPhysics 和 XPalm 这两个包覆盖。未来建议逐步将这些测试结构纳入 PSE 测试集中，但在目前，调整 API 时强烈建议同时检查这两个下游包的测试情况。","category":"section"},{"location":"developers.html#测试库（test-bank）","page":"开发者指南","title":"测试库（test bank）","text":"本页前面提到过测试库，但现有的测试库在天气数据、模型列表/映射及输出变量组合数量上仍有显著提升空间。\n\n此外，关于内存分配追踪、类型稳定性等方面的测试，也值得进一步完善与记录。","category":"section"},{"location":"multiscale/multiscale_example_3.html#修复植物模拟中的Bug","page":"修复植株模拟中的错误","title":"修复植物模拟中的Bug","text":"在上一章的实现中有两个关键问题，这里我们会分析和解决这两个问题。\n\n本节完整模拟脚本可在示例ToyMultiScalePlantModel子文件夹找到。\n\nPages = [\"multiscale_example_3.md\"]\nDepth = 3","category":"section"},{"location":"multiscale/multiscale_example_3.html#器官创建问题","page":"修复植株模拟中的错误","title":"器官创建问题","text":"你可能注意到，在观察数据时有一个小问题：当根扩展时，新的根会立刻生效，某些模型会立刻对其作用……包括根生长模型。这意味着新根可能在同一时间步内继续发出其他根，依此类推。\n\n你可以通过查看模拟在前两个时间步内的状态来发现这一点：\n\nouts = run!(mtg, mapping, first(meteo_day, 2))\n\nroot_nodes_per_timestep = [0, 0]\nfor i in 1:length(outs[\"Root\"])\n    if outs[\"Root\"][i].timestep < 3\n        root_nodes_per_timestep[outs[\"Root\"][i].timestep] += 1    \n    end\nend\n\nroot_nodes_per_timestep\n\n我们的根在一个时间步内就达到了完全长度。太快了。\n\n这是PlantSimEngine的一个实现决定：默认情况下，新创建的器官是立即激活的，相关模型可以在其创建后马上对其进行操作。\n\n在我们的例子里，节间生长受到一个积温指标的限制，这种限制通常需要若干时间步的积累，所以即使新的节间马上生效，也无法在同一时间步内再长出新器官。但如我们已见，根就有这个问题。\n\n同样的问题也发生在 XPalm.jl（另一个使用PlantSimEngine的包）：部分器官采用状态机，并在创建时被视为“未成熟”，只有当条件满足并进阶为成熟状态后才能继续生长新的器官。器官出现的控制条件可能还包括积温等阈值（参见这里的一个例子）。\n\nnote: Note\n新器官立即激活的实现方式在PlantSimEngine的未来版本中有可能更改。请注意，依赖图结构决定了模型的执行顺序，映射中模型的增加或调整会导致模型运行顺序的变化。部分模型可能会出现“晚一拍”的现象，关于详细内容见 新增模型时的仿真顺序不稳定。\n\nnote: Note\nMTG节点输出数据有其结构细节，详见 多尺度输出数据结构。","category":"section"},{"location":"multiscale/multiscale_example_3.html#延迟器官成熟","page":"修复植株模拟中的错误","title":"延迟器官成熟","text":"如何避免根的“瞬间极长”呢？当然可以像节间那样添加一个积温约束，也可以直接改动水资源等参数。\n\n除此之外，我们可以在MTG的根和节间节点添加一个简单的状态机变量，记录新器官为“未成熟”，从而禁止其在同一时间步内生长新器官。由于本例根不分叉，只需记录一个状态变量即可。见 状态机 小节了解具体例子。\n\n此外，也可以调整执行根生长检查的尺度，由其他模型在合适的时机直接调用根生长模型，这样只有每一时间步最末端根节点满足条件时才执行扩展，而不是每个根每步都检查。","category":"section"},{"location":"multiscale/multiscale_example_3.html#资源分配-Bug","page":"修复植株模拟中的错误","title":"资源分配 Bug","text":"你还可以注意到，水和碳的库存是通过累加全部叶片的光合和全部根的吸收得到的……但消耗时却不总是被正确减去！\n\n如果末端根生长，则会输出carbon_root_creation_consumed；但在某些条件下，即使碳已经不足，还是可能生成多个根与节间。\n\n具体来说，当根和叶的水分条件都满足，且只够一个根或节间生长时，如果根生长模型比节间模型先运行，则二者都用到了“器官产生之前”的碳库存，节间模型不会计入根的碳消耗。\n\n这是因为carbon_stock库存只在时间步更新一次，直到下一个时间步才更新。","category":"section"},{"location":"multiscale/multiscale_example_3.html#资源消耗修正：根生长决策模型","page":"修复植株模拟中的错误","title":"资源消耗修正：根生长决策模型","text":"为防止这种问题，可以将根生长模型与节间产生模型绑定，并将carbon_root_creation_consumed传递给节间模型，使其计算到已消耗的碳。或者插入一个中间模型，在转给节间模型之前，先重新计算一次库存。\n\n更多相关讨论见[技巧与变通(Tips and workarounds)]一章：模型中变量不能同时作为输入和输出。\n\n本节采用第一个方法，即根生长模型与节间模型耦合。","category":"section"},{"location":"multiscale/multiscale_example_3.html#节间模型调整","page":"修复植株模拟中的错误","title":"节间模型调整","text":"对节间模型的唯一必要修改，就是把carbon_root_creation_consumed作为新的输入变量，从\"Root\"尺度映射过来，然后在run!函数中用这个变量修正碳库存。例如：\n\n # 考虑已消耗碳\n    carbon_stock_updated_after_roots = status.carbon_stock - status.carbon_root_creation_consumed\n\n    # 如果剩余碳不足，不产生新器官\n    if carbon_stock_updated_after_roots < m.carbon_internode_creation_cost\n        return nothing\n    end","category":"section"},{"location":"multiscale/multiscale_example_3.html#跨尺度强依赖出现","page":"修复植株模拟中的错误","title":"跨尺度强依赖出现","text":"我们的“根生长决策模型”接管了上一章\"root_growth\"模型的一部分工作，输入、参数以及条件判断类似。原始根生长模型仅负责长度检查，决策模型专注资源分配。\n\n由于决策模型要直接调用实际的根生长模型，因此需要声明依赖于后者，且不能独立运行。\n\n这种依赖是跨多尺度的，因为两个模型分别作用于\"Plant\"和\"Root\"层级。更多关于多尺度强依赖见 多尺度环境下的依赖关系处理。\n\n声明多尺度强依赖与单尺度类似，只是要加上尺度映射信息：\n\nPlantSimEngine.dep(::ToyRootGrowthDecisionModel) = (root_growth=AbstractRoot_GrowthModel=>[\"Root\"],)\n\n在决策模型run!函数中，status变量只有Plant级变量，要调用根模型的状态（\"Root\"级），可通过extra参数获得。\n\n多尺度模拟中，extra包含所有不同尺度的状态以及以“尺度-过程名”为索引的所有模型。\n\n在根生长决策模型run!中访问\"Root\"层状态的方法：\n\nstatus_Root= extra_args.statuses[\"Root\"][1]\n\n随后，在父模型调用子模型的方式：\n\nPlantSimEngine.run!(extra.models[\"Root\"].root_growth, models, status_Root, meteo, constants, extra)\n\n基于此就可以完善完整决策模型：","category":"section"},{"location":"multiscale/multiscale_example_3.html#根生长决策模型实现","page":"修复植株模拟中的错误","title":"根生长决策模型实现","text":"通过上面的耦合方式，可得到完整的根生长决策模型：\n\nPlantSimEngine.@process \"root_growth_decision\" verbose = false\n\nstruct ToyRootGrowthDecisionModel{T} <: AbstractRoot_Growth_DecisionModel\n    water_threshold::T\n    carbon_root_creation_cost::T\nend\n\nPlantSimEngine.inputs_(::ToyRootGrowthDecisionModel) = \n(water_stock=0.0,carbon_stock=0.0)\n\nPlantSimEngine.outputs_(::ToyRootGrowthDecisionModel) = NamedTuple()\n\nPlantSimEngine.dep(::ToyRootGrowthDecisionModel) = (root_growth=AbstractRoot_GrowthModel=>[\"Root\"],)\n\n# status为Plant尺度\nfunction PlantSimEngine.run!(m::ToyRootGrowthDecisionModel, models, status, meteo, constants=nothing, extra=nothing)\n\n    if status.water_stock < m.water_threshold && status.carbon_stock > m.carbon_root_creation_cost\n        # 获取Root层的状态\n        status_Root= extra_args.statuses[\"Root\"][1]\n        # 直接以“强依赖方式”调用子模型\n        PlantSimEngine.run!(extra.models[\"Root\"].root_growth, models, status_Root, meteo, constants, extra)\n    end\nend\n\n根生长模型仍然输出carbon_root_creation_consumed，即便它作为依赖模型对外是隐性的，输出依然可以给下游模型使用。\n\n有了这个“串联”，每步最多只会新长一个根节点，因为决策模型只在Plant层调用一次。","category":"section"},{"location":"multiscale/multiscale_example_3.html#根生长模型","page":"修复植株模拟中的错误","title":"根生长模型","text":"该版本比上一章实现更精简：\n\nPlantSimEngine.@process \"root_growth\" verbose = false\n\nstruct ToyRootGrowthModel <: AbstractRoot_GrowthModel\n    root_max_len::Int\nend\n\nPlantSimEngine.inputs_(::ToyRootGrowthModel) = NamedTuple()\nPlantSimEngine.outputs_(::ToyRootGrowthModel) = (carbon_root_creation_consumed=0.0,)\n\nfunction PlantSimEngine.run!(m::ToyRootGrowthModel, models, status, meteo, constants=nothing, extra=nothing)    \n    status.carbon_root_creation_consumed = 0.0\n\n    root_end = get_root_end_node(status.node)\n        \n    if length(root_end) != 1 \n        throw(AssertionError(\"未找到符号为\\\"Root\\\"的MTG叶节点\"))\n    end\n    \n    root_len = get_roots_count(root_end[1])\n    if root_len < m.root_max_len\n        st = add_organ!(root_end[1], extra, \"<\", \"Root\", 2, index=1)\n        status.carbon_root_creation_consumed = m.carbon_root_creation_cost\n    end\nend","category":"section"},{"location":"multiscale/multiscale_example_3.html#映射调整","page":"修复植株模拟中的错误","title":"映射调整","text":"新映射变动很直接：一些模型不再跨尺度，部分变量的映射方式也变化。例如，carbon_root_creation_consumed不再是向量映射，而是标量：\n\nmapping = Dict(\n\"Scene\" => ToyDegreeDaysCumulModel(),\n\"Plant\" => (\n    MultiScaleModel(\n        model=ToyStockComputationModel(),          \n        mapped_variables=[\n            :carbon_captured=>[\"Leaf\"],\n            :water_absorbed=>[\"Root\"],\n            :carbon_root_creation_consumed=>\"Root\",\n            :carbon_organ_creation_consumed=>[\"Internode\"]\n\n        ],\n        ),\n    MultiScaleModel(\n        model=ToyRootGrowthDecisionModel(10.0, 50.0),\n    ),\n        Status(water_stock = 0.0, carbon_stock = 0.0)\n    ),\n\"Internode\" => (        \n        MultiScaleModel(\n            model=ToyCustomInternodeEmergence(), # TT_emergence=20.0\n            mapped_variables=[:TT_cu => \"Scene\",\n            :water_stock=>\"Plant\",\n            :carbon_stock=>\"Plant\", \n            :carbon_root_creation_consumed=>\"Root\"],\n        ),        \n        Status(carbon_organ_creation_consumed=0.0),\n    ),\n\"Root\" =>   (ToyRootGrowthModel(10),       \n            ToyWaterAbsorptionModel(),\n            Status(carbon_root_creation_consumed=0.0, root_water_assimilation=1.0),\n            ),\n\"Leaf\" => ( ToyLeafCarbonCaptureModel(),),\n)\n\n现在我们可以像以前一样运行模拟了么？\n\nERROR: Cyclic dependency detected for process resource_stock_computation: resource_stock_computation for organ Plant depends on root_growth from organ Root, which depends on the first one. This is not allowed, you may need to develop a new process that does the whole computation by itself.\n\n发现由于在当前timestep用到了根消耗的碳，导致依赖循环。","category":"section"},{"location":"multiscale/multiscale_example_3.html#断开循环依赖","page":"修复植株模拟中的错误","title":"断开循环依赖","text":"其实解决办法一目了然：我们不能先用“当前步”的carbon_root_creation_consumed计算库存，然后又即刻用更新后的再消耗一次。正确做法是“资源库存总是用上一步的消耗”，即库存模型读取前一时刻的消耗或吸收，根/器官生长模型再决定本步是否生长并输出本步消耗。\n\n如有需要，水的消耗也可采用同理。","category":"section"},{"location":"multiscale/multiscale_example_3.html#映射最终版","page":"修复植株模拟中的错误","title":"映射最终版","text":"需要做的只是如下修改：\n\nmapping = Dict(\n...\n\"Plant\" => (\n    MultiScaleModel(\n        model=ToyStockComputationModel(),          \n        mapped_variables=[\n            :carbon_captured=>[\"Leaf\"],\n            :water_absorbed=>[\"Root\"],\n            PreviousTimeStep(:carbon_root_creation_consumed)=>\"Root\",\n            PreviousTimeStep(:carbon_organ_creation_consumed)=>[\"Internode\"],\n        ],\n        ),\n        ToyRootGrowthDecisionModel(10.0, 50.0),\n        Status(water_stock = 0.0, carbon_stock = 0.0)\n    ),\n...\n)","category":"section"},{"location":"multiscale/multiscale_example_3.html#总结与后记","page":"修复植株模拟中的错误","title":"总结与后记","text":"现在你已经可以正常运行模拟了。\n\n完整脚本地址：ToyMultiScalePlantModel 示例子文件夹下。\n\n此模型能模拟有两种生长方向的植物。初期根不断生长直至水分充足。\n\n当然，该实现依然有诸多设计问题，例如水消耗未建模、条件过于简化、健壮性欠佳，模型与变量命名也有优化空间。\n\n不过再次强调，这一示例旨在展示框架能力而非生态生理学合理性。基于此框架可不断丰富模型和参数、引入新的植物信息，逐步完善，朝着真实、生产乃至预测模拟的目标迈进。","category":"section"},{"location":"introduction/why_julia.html#为什么选择使用-Julia","page":"为什么选择 Julia？","title":"为什么选择使用 Julia","text":"PlantSimEngine 是用 Julia 语言实现的。它的诞生源自一系列 需求与要求，这些恰好是 Julia 能够有效满足的。\n\n其他建模框架、FSPM 和作物模型往往是用 Java、C++、Python 或 Fortran 等多种语言的组合实现的。鉴于 Julia 目前还不是多数研究人员（甚至开发者！）最为熟悉的语言，因此本页简要解释了我们选择 Julia 的理由。另一个不错的资源是 Alejandro Morales Sierra（Virtual Plant Lab 的创始人和维护者）在 discourse 上的帖子。","category":"section"},{"location":"introduction/why_julia.html#从科研到实际应用","page":"为什么选择 Julia？","title":"从科研到实际应用","text":"PlantSimEngine 最初是一个面向目标的框架。其特性是为应对日益复杂的仿真需求而产生——并持续不断地发展和优化。\n\n虽然 PlantSimEngine 主要帮助研究人员高效地原型开发和测试模型，但我们始终以推动其在实际应用中发挥作用为愿景。我们的目标是建立学术植物建模与实际田间应用之间的桥梁。理想情况下，研究者能在舒适环境下开发和完善自己的模型，并最终能将这些模型部署到生产环境中。\n\n这种双重功能的愿景促使我们高度重视性能优化。我们希望你开发的模型不仅仅止步于学术论文，还能在对效率和准确性要求极高的实际场景下可靠运行。Julia 强大的性能特性为这种愿景提供了其他语言难以匹敌的支撑。\n\nPlantSimEngine 致力于在科学严谨性与开发效率之间取得平衡，长期目标是确保模型可以大规模部署。Julia 为研究人员提供了能够直接用代码表达复杂数学思想的环境，而且性能出色，为模型走向实际应用铺平道路。","category":"section"},{"location":"introduction/why_julia.html#PlantSimEngine-的约束条件","page":"为什么选择 Julia？","title":"PlantSimEngine 的约束条件","text":"","category":"section"},{"location":"introduction/why_julia.html#性能","page":"为什么选择 Julia？","title":"性能","text":"虽然在过去几十年中，计算机的算力与内存已经提升了好几个数量级，以至于许多曾经的性能瓶颈都已消失，但性能依然可能成为限制因素。\n\n在许多植物个体、数以万计的叶片上，用用户自定义变量来模拟多个过程，需要大量的计算。如果使用如 Python 或 R 这样的高级语言，仿真所需时间并不理想。\n\n事实上，最初决定转向 Julia 的部分动力，正是来自于将 一个模型 从 R 移植到 Julia 后，性能实现了数量级的提升。“开箱即用”的情况下，原本需要数分钟的运算变成了几秒钟，更加确信了选择（参见此基准测试，性能相差高达 5 个数量级）。\n\nJulia 拥有优良的 “即时（Just-ahead-of-time）编译” 模型，同时又可以灵活进行底层优化，因此不会像只用 Python 或 R 时遇到那样的限制。","category":"section"},{"location":"introduction/why_julia.html#灵活性与易用性","page":"为什么选择 Julia？","title":"灵活性与易用性","text":"PlantSimEngine 的开发初衷之一，就是让假设检验变得简单。目前，验证 FSPM、作物模型或生态生理学机制的假设，在许多现有框架中都非常困难——要么结构过于僵硬，要么学习门槛太高。\n\n同样地，在开发一个功能齐全的 FSPM 时，难免要针对某个过程测试不同模型，或用更复杂的模型进行替换。这时，API 友好与语言易用性，与自动化模型耦合一样重要，有助于保证这些变更顺畅地进行。","category":"section"},{"location":"introduction/why_julia.html#面向更广泛社区的包","page":"为什么选择 Julia？","title":"面向更广泛社区的包","text":"如前所述，PlantSimEngine 面向的是大众用户，其中只有很少部分具备扎实开发背景。更多的潜在用户可能是精通生态生理学或植物结构的研究者，他们只会一些 Python、Matlab 或 R。降低这类用户的使用门槛尤为重要。\n\n开源库/包、易于安装和低入门门槛，同样是我们决策时的重要参考。","category":"section"},{"location":"introduction/why_julia.html#保持性能的同时兼具模块化与灵活性","page":"为什么选择 Julia？","title":"保持性能的同时兼具模块化与灵活性","text":"一种常用做法，是将如 Python 这样的灵活语言与高性能语言（如 C++、Fortran）结合：用慢但灵活的语言做原型开发，当需要性能时再用更高效的语言重写部分代码。\n\n这种方式虽然满足性能要求，但也有不少缺点。","category":"section"},{"location":"introduction/why_julia.html#开发资源有限","page":"为什么选择 Julia？","title":"开发资源有限","text":"当然，预算、时间和人力资源也是现实要素。研究者和建模者越能独立开发、越少依赖专业开发或工程资源，项目的可持续发展性也就越强。","category":"section"},{"location":"introduction/why_julia.html#对比","page":"为什么选择 Julia？","title":"对比","text":"","category":"section"},{"location":"introduction/why_julia.html#“两种语言”问题","page":"为什么选择 Julia？","title":"“两种语言”问题","text":"将两种不同的语言结合使用需要大量的语言知识，并且经常需要不断温习，因为在实际开发中，只有偶尔才会用到并调试底层语言。同时会消耗更多的工程资源。\n\n而每当性能成为瓶颈时，开发和迭代的速度就会下降，这在我们的应用场景下非常常见。即使像 Python 这样模块化且易用的语言，也会在需要切换到低级语言实现时让开发节奏变慢。\n\nJulia 有效地解决了这一难题。虽然它的学习曲线比 Python 略高，并需要额外的知识去充分发挥其灵活性和性能优势，但整体上能带来更流畅的开发体验。\n\n所有工作都可以仅用 Julia 完成，无需再掌握两种语言，也无需处理它们之间的接口问题。即使需要底层实现，开发的迭代速度也不会突然停滞。具备一定技能的研究者/开发者可以毫无障碍地从原型开发过渡到实际生产，同时还能专注于建模和植物本身的科学问题。\n\n(Image: 不同机器学习包的语言占比对比（图片来源：https://pde-on-gpu.vaw.ethz.ch/lecture1/）) （不同机器学习包的语言使用对比，来源：https://pde-on-gpu.vaw.ethz.ch/lecture1/）\n\n显然，并不只有我们发现 Julia 是解决该类问题的重要工具。Julia 正在越来越多的细分领域获得认可，尤其是那些计算密集型且研究活跃的领域，如机器学习和气候建模——这些场景中对表达能力和性能的平衡同样至关重要。","category":"section"},{"location":"introduction/why_julia.html#易用性兼顾的良好平衡","page":"为什么选择 Julia？","title":"易用性兼顾的良好平衡","text":"另一个选择 Julia 的理由是，PlantSimEngine 旨在让希望验证假设或复现其他论文结果的研究者能够方便使用。当运行和修改仿真的门槛更低时，科学复现性也会大大提升。\n\n许多研究人员并非职业开发者，纯用 Java 或 C++ 实现的模型，不仅难以上手，也难以获得广泛采用。\n\n尽管 Julia 在学术圈还不如其他语言普及，但它的语法风格更接近 Python 和 R，比 Java、C++ 更加友好，对初学者而言也更易入门。Python 用户学习简单的 Julia 包，显然比学 C++ 容易得多。\n\n用户实现新模型时，不需要担心底层实现或跨语言接口等潜在障碍，可以专注于快速试验——原型阶段无需额外花时间进行性能优化。","category":"section"},{"location":"introduction/why_julia.html#环境搭建便利","page":"为什么选择 Julia？","title":"环境搭建便利","text":"同样，Julia 本身的环境和包管理非常简单直观，不需要额外的知识。\n\nJulia 内置的包管理器极大地简化了依赖管理。对于科学工作流程的可复现性而言，这一点非常重要——保持一致的运行环境是关键。","category":"section"},{"location":"introduction/why_julia.html#可接受的不足","page":"为什么选择 Julia？","title":"可接受的不足","text":"Julia 对“研究者-开发者”来说非常实用，但它当然不是各个领域的完美语言。Julia 拥有丰富的语言特性，运行时较重，要快速掌握和精通也比 Python 困难。对于初学者来说有一些门槛，对开发者来说也存在一些不够成熟的工具和奇怪的地方，还没有特别标准推荐的“正确工作流”等等。\n\n在很多其他环境下，转向 Julia 可能并不划算。然而，这些缺点在嵌入式系统或游戏开发等场景中很重要，但对 PlantSimEngine 而言却大多不构成障碍。其他问题则完全可以通过完善的文档和学习资源加以缓解。","category":"section"},{"location":"introduction/why_julia.html#总结","page":"为什么选择 Julia？","title":"总结","text":"对于 PlantSimEngine 的具体需求而言——兼顾性能与灵活性、在保证计算效率的同时实现快速迭代，以及为科研人员和实际从业者提供友好易用的界面——Julia 是非常合适的选择。这门语言使我们能够构建一个高效协作、科学严谨且面向生产部署的生态系统，从而推动植物建模的进步并为实际应用带来价值。\n\n当然，没有哪种编程语言是十全十美的，但 Julia 独特的特性组合，使其非常适合应对现代植物建模与仿真的挑战，无论是在科学研究还是实际应用中。我们对 Julia 在植物建模未来所展现的潜力，充满信心。","category":"section"},{"location":"step_by_step/implement_a_model_additional.html#模型实现补充说明","page":"实现一个模型：补充说明","title":"模型实现补充说明","text":"Pages = [\"implement_a_model_additional.md\"]\nDepth = 3","category":"section"},{"location":"step_by_step/implement_a_model_additional.html#参数化类型","page":"实现一个模型：补充说明","title":"参数化类型","text":"在实现一个模型章节，Beer 模型的结构体是以参数化类型声明的。\n\nstruct Beer{T} <: AbstractLight_InterceptionModel\n    k::T\nend\n\n为什么不直接强制指定类型呢？毕竟 Float64 比 Float32 更精确：\n\nstruct YourStruct <: AbstractLight_InterceptionModel\n    k::Float64\n    x::Float64\n    y::Float64\n    z::Int\nend\n\n这样做会损失用户对模型使用上的灵活性。例如，用户可能想用 MonteCarloMeasurements.jl 包中的 Particles 类型来做自动不确定性传播，只有类型支持参数化，这样的用法才成为可能。如果强制字段为 Float64，就无法和 Particles 类型兼容。","category":"section"},{"location":"step_by_step/implement_a_model_additional.html#类型提升","page":"实现一个模型：补充说明","title":"类型提升","text":"当你实现一个新模型时，可以做一些额外的、可选的细化工作以方便未来的用户。\n\n你可以为类型提升（type promotion）专门添加一个方法。对于前面的 Beer 示例来说没必要，因为只有一个参数。但我们可以举一个包含两个参数的新模型，比如叫作 Beer2：\n\nstruct Beer2{T} <: AbstractLight_InterceptionModel\n    k::T\n    x::T\nend\n\n为了给 Beer2 添加类型提升（type promotion）的功能，我们可以这样做：\n\nfunction Beer2(k,x)\n    Beer2(promote(k,x)...)\nend\n\nnote: Note\npromote 返回一个 NamedTuple，需要用展开（splatting）操作符 ... 传递给构造函数。更多解释可以参考 Julia 官方文档，或参见我们的 Julia 入门指南 页面，里面有关于 PlantSimEngine 使用的一些 Julia 概念的参考链接。\n\n这样可以让用户使用不同类型参数来实例化模型。例如，用户可以写：\n\nBeer2(0.6,2)\n\nBeer2 是一个参数化类型，所有字段都具有相同的类型 T。这里的 T 就出现在 Beer2{T} 以及 k::T 和 x::T。这要求用户提供的所有参数类型相同。\n\n在上面的例子中，k 的值是 0.6（类型为 Float64），而 x 的值是 2（类型为 Int）。如果没有类型提升，Julia 会报错，因为两个参数类型不同。而类型提升则在这里派上用场：它会自动将你的所有输入提升为一种统一类型（如果可能的话）。在本例中，2 会被提升为 2.0。","category":"section"},{"location":"step_by_step/implement_a_model_additional.html#其他辅助函数和构造方法","page":"实现一个模型：补充说明","title":"其他辅助函数和构造方法","text":"","category":"section"},{"location":"step_by_step/implement_a_model_additional.html#参数默认值","page":"实现一个模型：补充说明","title":"参数默认值","text":"你可以通过为某些参数（如果适用）提供默认值，简化用户的模型使用方式。例如，在 Beer 模型中，用户几乎不会去修改 k 的值，所以我们可以如下提供默认值：\n\nBeer() = Beer(0.6)\n\n现在，用户可以直接使用无参数的 Beer() 调用，此时 k 会默认采用 0.6。","category":"section"},{"location":"step_by_step/implement_a_model_additional.html#以关键字参数形式传递参数值","page":"实现一个模型：补充说明","title":"以关键字参数形式传递参数值","text":"另一个很实用的做法是允许使用关键字参数来实例化你的模型类型，也就是给参数显式命名。你可以通过添加如下方法实现：\n\nBeer(;k) = Beer(k)\n\n这里的 ; 语法表示后面的参数可以作为关键字参数传递，因此现在我们可以这样调用 Beer：\n\nBeer(k = 0.7)\n\n当参数较多、部分参数有默认值时，这种方式可以大大提升代码的可读性。","category":"section"},{"location":"step_by_step/implement_a_model_additional.html#eltype","page":"实现一个模型：补充说明","title":"eltype","text":"最后一个可选的辅助方法，是为你的模型类型实现 eltype 方法：\n\nBase.eltype(x::Beer{T}) where {T} = T\n\n这样可以让 Julia 知道结构体中元素的类型，从而提升执行效率。","category":"section"},{"location":"troubleshooting_and_testing/implicit_contracts.html","page":"隐性约定","title":"隐性约定","text":"本页面总结了在使用PlantSimEngine实现新模型时，可能需要特别注意的一些假设、耦合约束和内部工作机制。\n\n如果你对具体实现的细节存在疑问，可以查阅本页面，看看是否能为你解答。\n\nPages = [\"implicit_contracts.md\"]\nDepth = 2","category":"section"},{"location":"troubleshooting_and_testing/implicit_contracts.html#天气数据提供仿真的时间步长，但模型可以偏离它","page":"隐性约定","title":"天气数据提供仿真的时间步长，但模型可以偏离它","text":"天气数据的时间步长，无论是按小时还是按天，通常决定了大多数其他模型的运行节奏。\n\n在 XPalm 中，大多数模型的天气数据按天提供，这意味着生物量的计算也是按天进行的。\n\n许多模型在该时间范围内被认为是稳态的，但也并非全部：例如，叶片修剪模型对植株的影响是非稳态的。此外，一些需要多次迭代计算以实现稳定（通常属于强依赖部分）的模型，其时间步长也可能与天气数据无关。\n\n!!! 注意     这意味着，传递给仿真的任意向量变量必须与天气时间步数保持一致。唯一的例外是：如果只提供一个天气值但提供了更长的向量变量，系统会在每一个时间步重复使用该天气值。（未来如果支持单个仿真中不同的时间步长，该功能可能会变化）","category":"section"},{"location":"troubleshooting_and_testing/implicit_contracts.html#仿真前必须对天气数据进行插值处理","page":"隐性约定","title":"仿真前必须对天气数据进行插值处理","text":"如果你的天气数据没有调整为符合规律的时间步长（例如每日、每小时等），则需要你自行进行调整。PlantSimEngine 在仿真前不会自动进行插值处理，期望输入的数据已经是规律的时间步长。","category":"section"},{"location":"troubleshooting_and_testing/implicit_contracts.html#简化的依赖图不能有循环依赖","page":"隐性约定","title":"简化的依赖图不能有循环依赖","text":"用于仿真的模型依赖图由软依赖节点和硬依赖节点组成，最终只保留软依赖节点之间的连接，并且应当确保没有循环依赖。\n\n任何用户模型的耦合如果导致出现循环依赖，则需要做额外处理：要么重新设计模型，要么对部分有问题的模型建立强依赖关系，或者通过让某个变量采用上一个时间步的值来打破循环。\n\n关于依赖图约束的更多讨论，请见依赖图（Dependency graphs）及以下小节。\n\n注意：在PlantSimEngine中，除非专门设计模型，目前只能访问前一个时间步的状态。如果需要存储更多过往时间步信息，可参考提示与变通方法页面中的多尺度模拟中利用历史状态的方法内容。","category":"section"},{"location":"troubleshooting_and_testing/implicit_contracts.html#硬依赖必须在模型定义中声明","page":"隐性约定","title":"硬依赖必须在模型定义中声明","text":"硬依赖由其所属的软依赖模型在内部处理，即硬依赖的 run! 函数会被软依赖的 run! 函数直接调用。\n\n目前 PlantSimEngine 构建依赖图的方式要求用户在硬依赖中明确声明所需的过程，以及该依赖需要从哪个尺度调取模型及其变量。","category":"section"},{"location":"troubleshooting_and_testing/implicit_contracts.html#并行化的机会必须在模型定义中体现","page":"隐性约定","title":"并行化的机会必须在模型定义中体现","text":"指示模型是否独立或者是否可以并行的特性，必须在模型定义时加以说明。建模者在实现新模型时需要注意这一点。\n\n目前，这主要是单一尺度仿真时的关注点，因为多尺度仿真还未实现并行化；当模型修改 MTG 时，需要实现更复杂的调度器，并在特定尺度支持更有价值的并行化机会。\n\n未来，针对多植株仿真，可能会有新的并行化功能推出。","category":"section"},{"location":"troubleshooting_and_testing/implicit_contracts.html#硬依赖在依赖图中只能有一个父节点","page":"隐性约定","title":"硬依赖在依赖图中只能有一个父节点","text":"最终的依赖关系图仅包含软依赖节点，并且被保证不存在循环。硬依赖由其所属的软依赖祖先在内部处理。为了避免处理顺序上的歧义，每个硬依赖只能由一个软依赖节点“拥有”，同理，嵌套的硬依赖也只能有一个软依赖祖先。\n\n这不仅是 PlantSimEngine 内部实现的细节，如果你的仿真需要复杂的耦合，可能需要慎重考虑如何管理硬依赖，或者插入额外的中间模型来简化结构。","category":"section"},{"location":"troubleshooting_and_testing/implicit_contracts.html#一个模型在同一尺度下只能使用一次","page":"隐性约定","title":"一个模型在同一尺度下只能使用一次","text":"同样地，为了避免依赖图中的歧义（并保证仿真的一致性），PlantSimEngine 目前假设对同一过程的建模，每个模型在同一尺度下只出现一次。\n\n通过重命名模型或复制模型可以绕过该限制。未来随着多植株/多物种功能的实现，这一假设可能会有所变化。","category":"section"},{"location":"troubleshooting_and_testing/implicit_contracts.html#同一尺度下不能有同名变量","page":"隐性约定","title":"同一尺度下不能有同名变量","text":"此规则旨在避免潜在的歧义，否则在仿真过程中不仅会影响模型的执行顺序，还可能导致模型错误地耦合到不正确的变量。\n\n对于某些需要同时作为输入和输出变量的情况，可以参考这里的变通方法：模型中变量不能同时作为输入和输出。","category":"section"},{"location":"troubleshooting_and_testing/implicit_contracts.html#新增模型时的仿真顺序不稳定","page":"隐性约定","title":"新增模型时的仿真顺序不稳定","text":"需要特别注意的是，PlantSimEngine 会自动根据模型之间的依赖关系图确定模型的执行顺序。\n\n仿真的执行顺序依赖于模型之间的耦合方式。如果你用一组新模型替换了原有模型，或者加入了创建新耦合关系的新变量，都可能导致仿真顺序发生变化。\n\n在不断迭代并逐步增强仿真的生理机制复杂性时，很容易因为用户的更改而导致两个模型的执行顺序被颠倒。\n\n这一设计选择是为了方便和灵活地开发仿真模型作出的权衡——意味着在你的模型组合尚未完全稳定，并且还不清楚哪些变量是 PreviousTimestep 以及模型具体执行顺序时，随着你不断扩展和调整模型集合，有些模型在单步仿真中的执行效果可能会有差异。这本身不是一个概念性的问题，因为大多数模型都是稳态的，而且对于固定的模型集合，仿真顺序是稳定的。但这也意味着 PlantSimEngine 在某些类型的仿真应用中会有不够便利的地方。","category":"section"},{"location":"FAQ/translate_a_model.html#我想用-PlantSimEngine-来实现我的模型","page":"我想用 PlantSimEngine 来实现我的模型","title":"我想用 PlantSimEngine 来实现我的模型","text":"如果你已经有了一个模型，只需要做些小调整，就可以很容易地用 PlantSimEngine 与其他模型耦合。","category":"section"},{"location":"FAQ/translate_a_model.html#LAI-玩具模型","page":"我想用 PlantSimEngine 来实现我的模型","title":"LAI 玩具模型","text":"","category":"section"},{"location":"FAQ/translate_a_model.html#模型描述","page":"我想用 PlantSimEngine 来实现我的模型","title":"模型描述","text":"下面我们以一个简单的 LAI 模型为例：\n\n\"\"\"\n使用一个简单的双逻辑函数，根据播种后的积温（degree-days）模拟作物的叶面积指数（LAI，单位：m² m⁻²）。\n\n# 参数\n\n- `TT_cu`：播种以来的积温（degree-days）\n- `max_lai=8`：LAI 的最大值\n- `dd_incslope=500`：LAI 增长最快时对应的积温\n- `inc_slope=5`：LAI 曲线上升阶段的斜率\n- `dd_decslope=1000`：LAI 下降最快时对应的积温\n- `dec_slope=2`：LAI 曲线下降阶段的斜率\n\"\"\"\nfunction lai_toymodel(TT_cu; max_lai=8.0, dd_incslope=500, inc_slope=70, dd_decslope=1000, dec_slope=20)\n    LAI = max_lai * (1 / (1 + exp((dd_incslope - TT_cu) / inc_slope)) - 1 / (1 + exp((dd_decslope - TT_cu) / dec_slope)))\n    if LAI < 0\n        LAI = 0\n    end\n    return LAI\nend\n\n该模型以播种后的天数作为输入，返回模拟得到的 LAI。我们可以绘制一整年模拟得到的 LAI 曲线如下：\n\nusing CairoMakie\n\nlines(1:1300, lai_toymodel.(1:1300), color=:green, axis=(ylabel=\"LAI (m² m⁻²)\", xlabel=\"Days since sowing\"))","category":"section"},{"location":"FAQ/translate_a_model.html#针对-PlantSimEngine-的调整","page":"我想用 PlantSimEngine 来实现我的模型","title":"针对 PlantSimEngine 的调整","text":"该模型可以通过 PlantSimEngine 实现，方法如下：","category":"section"},{"location":"FAQ/translate_a_model.html#定义一个过程","page":"我想用 PlantSimEngine 来实现我的模型","title":"定义一个过程","text":"如果 LAI 动态过程（Process）尚未实现，我们可以这样定义：\n\n@process LAI_Dynamic","category":"section"},{"location":"FAQ/translate_a_model.html#定义模型结构体","page":"我想用 PlantSimEngine 来实现我的模型","title":"定义模型结构体","text":"我们需要为我们的模型定义一个结构体，用于保存模型的参数：\n\nstruct ToyLAIModel <: AbstractLai_DynamicModel\n    max_lai::Float64\n    dd_incslope::Int\n    inc_slope::Float64\n    dd_decslope::Int\n    dec_slope::Float64\nend\n\n我们还可以通过定义带有关键字参数的方法，为参数设置默认值：\n\nToyLAIModel(; max_lai=8.0, dd_incslope=500, inc_slope=70, dd_decslope=1000, dec_slope=20) = ToyLAIModel(max_lai, dd_incslope, inc_slope, dd_decslope, dec_slope)\n\n这样，用户只需调用 ToyLAIModel() 就可以使用默认参数创建模型，也可以只指定自己想要更改的参数，例如 ToyLAIModel(inc_slope=80.0)。","category":"section"},{"location":"FAQ/translate_a_model.html#定义输入-/-输出","page":"我想用 PlantSimEngine 来实现我的模型","title":"定义输入 / 输出","text":"接下来我们可以定义模型的输入和输出变量，以及初始化时的默认值：\n\nPlantSimEngine.inputs_(::ToyLAIModel) = (TT_cu=-Inf,)\nPlantSimEngine.outputs_(::ToyLAIModel) = (LAI=-Inf,)\n\nnote: Note\n请注意，这里我们为默认值使用了 -Inf，这是 Float64 类型推荐的默认值（Int 类型推荐为 -999），因为它对于该类型是有效的，并且如果未正确赋值时很容易在输出中捕捉到（因为它会在计算中持续传播）。你也可以使用 NaN 作为默认值。","category":"section"},{"location":"FAQ/translate_a_model.html#定义模型函数","page":"我想用 PlantSimEngine 来实现我的模型","title":"定义模型函数","text":"最后，我们可以定义模型的主计算函数，此函数会在每个时间步自动被调用：\n\nfunction PlantSimEngine.run!(::ToyLAIModel, models, status, meteo, constants=nothing, extra=nothing)\n    status.LAI = models.LAI_Dynamic.max_lai * (1 / (1 + exp((models.LAI_Dynamic.dd_incslope - status.TT_cu) / models.LAI_Dynamic.inc_slope)) - 1 / (1 + exp((models.LAI_Dynamic.dd_decslope - status.TT_cu) / models.LAI_Dynamic.dec_slope)))\n\n    if status.LAI < 0\n        status.LAI = 0\n    end\nend\n\nnote: Note\n请注意，在函数定义中我们没有直接返回 LAI 的值，而是通过更新 status 变量实现对 LAI 的赋值。status 结构体高效地存储了模型在每个时间步的状态，包含了所有声明为输入或输出的变量。通过 status.LAI，我们可以在任何时间步访问 LAI 的值。\n\nnote: Note\n该函数只针对单个时间步进行定义，并且会由 PlantSimEngine 在每个时间步自动调用。这意味着我们不需要在该函数内自行编写时间循环。","category":"section"},{"location":"FAQ/translate_a_model.html#defining_the_meteo","page":"我想用 PlantSimEngine 来实现我的模型","title":"运行模拟","text":"现在我们已经完成了前面的准备工作，可以运行一次模拟了。首先需要设置气象数据：\n\n# 导入所需的包:\nusing PlantMeteo, Dates, DataFrames\n\n# 定义模拟的时间范围:\nperiod = [Dates.Date(\"2021-01-01\"), Dates.Date(\"2021-12-31\")]\n\n# 获取法国蒙彼利埃 CIRAD 站点的气象数据:\nmeteo = get_weather(43.649777, 3.869889, period, sink = DataFrame)\n\n# 计算以10°C为基温的积温(°C日):\nmeteo.TT = max.(meteo.T .- 10.0, 0.0)\n\n# 将气象数据聚合为日尺度:\n# 为什么要 sum(x) / 24\nmeteo_day = to_daily(meteo, :TT => (x -> sum(x) / 24) => :TT)\n\n接下来我们可以定义模型列表，并在初始化状态时传递 TT_cu 的数值：\n\nm = ModelList(\n    ToyLAIModel(),\n    status = (TT_cu = cumsum(meteo_day.TT),),\n)\n\noutputs_sim = run!(m)\n\nlines(outputs_sim[:TT_cu], outputs_sim[:LAI], color=:green, axis=(ylabel=\"LAI (m² m⁻²)\", xlabel=\"Days since sowing\"))","category":"section"},{"location":"multiscale/multiscale_coupling.html#多尺度环境下的依赖关系处理","page":"多尺度耦合相关说明","title":"多尺度环境下的依赖关系处理","text":"Pages = [\"multiscale_coupling.md\"]\nDepth = 3","category":"section"},{"location":"multiscale/multiscale_coupling.html#标量变量与向量变量的映射","page":"多尺度耦合相关说明","title":"标量变量与向量变量的映射","text":"在前文详细讨论的例子 多尺度变量映射 中，已经多次出现了在不同尺度间进行变量映射的情景。这里我们再简要回顾一下这些映射方式，以便引出后续更为高级的内容。典型的变量映射片段如下：\n\n\"Plant\" => (\n        MultiScaleModel(\n            model=ToyLAIModel(),\n            mapped_variables=[\n                :TT_cu => \"Scene\",\n            ],\n        ),\n        ...\n        MultiScaleModel(\n            model=ToyCAllocationModel(),\n            mapped_variables=[\n                :carbon_assimilation => [\"Leaf\"],\n                :carbon_demand => [\"Leaf\", \"Internode\"],\n                :carbon_allocation => [\"Leaf\", \"Internode\"]\n            ],\n        ),\n        ...\n    ),\n\n出于灵活性的考虑，PlantSimEngine 并不是在不同尺度的模型之间显式建立大多数连接，而只是声明某些变量需要从另一个尺度获取（更准确地说，是从输出这些变量的另一个尺度下的模型获取）。这样做的好处在于，切换模型时只需少量修改映射关系，极大提高了便利性。\n\n然而，需要注意的是，由于尺度名称都是由用户自定义的，PlantSimEngine 无法自动推断每个尺度下到底是多实例存在还是单实例存在。\n\n比如上面的例子，“Scene” 只有一个场景，“Plant” 只有一株植物，因此在这两个尺度之间进行 TT_cu 变量的映射时，是一对一的标量与标量之间的对应关系。\n\n而另一个变量 carbon_assimilation 则是针对每一片叶片分别计算的。在实际模拟时，叶片可能多达数百甚至上千，这就是标量到向量的对应关系。碳同化模型会在每个时间步对每片叶片多次运行，而碳分配模型每个时间步只运行一次。并且一开始也可能只有一个叶片，这意味着 PlantSimEngine 仅根据初始配置无法判断后续模拟过程中会生成多少片叶片。\n\n因此，这两者在映射声明上的差异如下：TT_cu 作为标量之间的映射声明为：\n\n:TT_cu => \"Scene\",\n\n而 carbon_assimilation（和其它类似变量）则要声明为向量映射关系：\n\n:carbon_assimilation => [\"Leaf\"],\n\n需要注意的是，某些情况下，你可能希望自行编写模型来将多实例尺度上的变量进行汇总或聚合。","category":"section"},{"location":"multiscale/multiscale_coupling.html#不同尺度下模型之间的强依赖关系","page":"多尺度耦合相关说明","title":"不同尺度下模型之间的强依赖关系","text":"如果一个模型需要某些输入变量，而这些变量是在另一个尺度中计算得到的，那么为该变量提供适当的映射即可解决命名冲突，使得无论对于用户还是模型开发者，只要耦合关系为“软依赖”，模型都可以顺利运行，无需进一步操作。\n\n而当强依赖（hard dependency）发生在与父级模型相同的尺度时，强依赖的声明方式与单尺度模拟完全相同，用户侧也无需额外步骤：\n\n父模型会直接调用其强依赖的子模型，也就是说这些依赖不会被顶层的依赖关系图显式管理；\n因此，依赖的“拥有者”模型在依赖图中是可见的，而其强依赖节点只作为内部节点存在；\n当调用者（或其它需要从强依赖模型获取变量的下游模型）与被调用的强依赖模型处于同一尺度时，变量可以直接访问，无需额外映射。\n\n另一方面，对于开发者来说，需要注意以下情形：如果某个模型的强依赖在与其父模型不同的器官（尺度）层级下，则需要根据依赖所处尺度进行声明。\n\n也就是说，如果某个模型需要被父模型直接调用，但它运行在不同的（更细或更粗的）尺度／器官层级上，则开发者必须像用户提供映射那样，声明强依赖所对应的尺度。\n\n概念上如下所示：\n\n PlantSimEngine.dep(m::ParentModel) = (\n    name_provided_in_the_mapping=AbstractHardDependencyModel => [\"Organ_Name_1\",],\n)","category":"section"},{"location":"multiscale/multiscale_coupling.html#教学案例中的一个例子","page":"多尺度耦合相关说明","title":"教学案例中的一个例子","text":"你可以在玩具植物模拟教程第三部分 跨尺度强依赖出现 小节中找到关于强依赖的具体讨论与例子。","category":"section"},{"location":"multiscale/multiscale_coupling.html#来自-XPalm.jl-的示例","page":"多尺度耦合相关说明","title":"来自 XPalm.jl 的示例","text":"以下是在 XPalm（一个基于 PlantSimEngine 开发的油棕模型）中的一个具体示例。器官是在小枝（phytomer）尺度生成的，但在生殖器官尺度上需要运行年龄模型和生物量模型。\n\nPlantSimEngine.dep(m::ReproductiveOrganEmission) = (\n    initiation_age=AbstractInitiation_AgeModel => [m.male_symbol, m.female_symbol],\n    final_potential_biomass=AbstractFinal_Potential_BiomassModel => [m.male_symbol, m.female_symbol],\n)\n\n用户在映射中为特定的器官级别提供了所需的模型。以下是关于雄性生殖器官的相关映射片段：\n\nmapping = Dict(\n    ...\n    \"Male\" =>\n    MultiScaleModel(\n        model=XPalm.InitiationAgeFromPlantAge(),\n        mapped_variables=[:plant_age => \"Plant\",],\n    ),\n    ...\n    XPalm.MaleFinalPotentialBiomass(\n        p.parameters[:male][:male_max_biomass],\n        p.parameters[:male][:age_mature_male],\n        p.parameters[:male][:fraction_biomass_first_male],\n    ),\n    ...\n)\n\n该模型的构造函数为对应的生殖器官尺度提供了便捷的默认命名。如果用户的命名方案或 MTG 属性有差异，也可以进行覆盖。\n\nfunction ReproductiveOrganEmission(mtg::MultiScaleTreeGraph.Node; phytomer_symbol=\"Phytomer\", male_symbol=\"Male\", female_symbol=\"Female\")\n    ...\nend","category":"section"},{"location":"multiscale/multiscale_coupling.html#实现细节：如何从不同尺度访问强依赖模型的变量","page":"多尺度耦合相关说明","title":"实现细节：如何从不同尺度访问强依赖模型的变量","text":"但是，当一个模型 M 需要调用其强依赖 H 的 run! 函数时，该如何为 H 提供所需要的变量呢？用户传递给 M 的 status 参数仅作用于 M 所在的器官层级，如果直接用于调用 H 的 run! 函数，H 需要的变量可能会缺失。\n\n为了解决这一问题，PlantSimEngine 在仿真图中引入了 Status 模板。每个器官层级都有自己对应的 Status 模板，模板列出了该层级可用的所有变量。因此，当模型 M 调用强依赖 H 的 run! 函数时，可以通过 H 所在器官层级的 Status 模板，获得所需的变量。","category":"section"},{"location":"multiscale/multiscale_coupling.html#回到-XPalm-示例","page":"多尺度耦合相关说明","title":"回到 XPalm 示例","text":"仍以油棕多尺度 FSPM 模型 XPalm 为例：\n\n# 注意：函数中的 status 参数不包含强依赖所需的变量，因为调用模型所在的器官层级是 \"Phytomer\"，而非 \"Male\" 或 \"Female\"\n\nfunction PlantSimEngine.run!(m::ReproductiveOrganEmission, models, status, meteo, constants, sim_object)\n    ...\n    status.graph_node_count += 1\n\n    # 以该小枝为父节点新建一个生殖器官\n    st_repro_organ = add_organ!(\n        status.node[1],              # 小枝（Phytomer）上的节间是它的第一个子节点\n        sim_object,                  # 仿真对象，用于添加新的 status\n        \"+\", status.sex, 4;\n        index=status.phytomer_count,\n        id=status.graph_node_count,\n        attributes=Dict{Symbol,Any}()\n    )\n\n    # 计算该器官的起始年龄\n    PlantSimEngine.run!(sim_object.models[status.sex].initiation_age, sim_object.models[status.sex], st_repro_organ, meteo, constants, sim_object)\n    PlantSimEngine.run!(sim_object.models[status.sex].final_potential_biomass, sim_object.models[status.sex], st_repro_organ, meteo, constants, sim_object)\nend\n\n在上述示例中，生殖器官节点及其 Status 模板是在运行时动态创建的。 如果不是这种情况，也可以通过仿真图访问到对应的 Status 模板：\n\nfunction PlantSimEngine.run!(m::ReproductiveOrganEmission, models, status, meteo, constants, sim_object)\n\n    ...\n\n    if status.sex == \"Male\"\n\n        status_male = sim_object.statuses[\"Male\"][1]\n        run!(sim_object.models[\"Male\"].initiation_age, models, status_male, meteo, constants, sim_object)\n        run!(sim_object.models[\"Male\"].final_potential_biomass, models, status_male, meteo, constants, sim_object)\n    else\n        # 雌性\n        ...\n    end\nend","category":"section"},{"location":"API/API_private.html#API-内部函数","page":"内部 API","title":"API - 内部函数","text":"","category":"section"},{"location":"API/API_private.html#未导出成员","page":"内部 API","title":"未导出成员","text":"PlantSimEngine 中的私有函数、类型或常量。这些内容均未导出，因此需要通过 PlantSimEngine. 前缀来访问（例如 PlantSimEngine.DataFormat）。大多数属于开发者代码，但其中有些内容对希望深入探索或需更精细控制模拟参数的用户也有用（未来文档版本可能会将这些类别分拆到不同页面以提升清晰度）。","category":"section"},{"location":"API/API_private.html#索引","page":"内部 API","title":"索引","text":"Pages = [\"API_private.md\"]","category":"section"},{"location":"API/API_private.html#API-文档","page":"内部 API","title":"API 文档","text":"","category":"section"},{"location":"API/API_private.html#DataFrames.DataFrame-Tuple{T} where T<:(AbstractArray{<:ModelList})","page":"内部 API","title":"DataFrames.DataFrame","text":"DataFrame(components <: AbstractArray{<:ModelList})\nDataFrame(components <: AbstractDict{N,<:ModelList})\n\n从ModelList（或其数组/字典）的状态中提取数据为一个DataFrame。\n\n示例\n\nusing PlantSimEngine\nusing DataFrames\n\n# 创建一个 ModelList\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=(var1=15.0, var2=0.3)\n)\n\n# 转换为 DataFrame\ndf = DataFrame(models)\n\n# 创建一个包含 ModelList 的字典\nmodels = Dict(\n    \"Leaf\" => ModelList(\n        process1=Process1Model(1.0),\n        process2=Process2Model(),\n        process3=Process3Model()\n    ),\n    \"InterNode\" => ModelList(\n        process1=Process1Model(1.0),\n        process2=Process2Model(),\n        process3=Process3Model()\n    )\n)\n\n# 转换为 DataFrame\ndf = DataFrame(models)\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#DataFrames.DataFrame-Union{Tuple{ModelList{T, S}}, Tuple{S}, Tuple{T}} where {T, S<:Status}","page":"内部 API","title":"DataFrames.DataFrame","text":"DataFrame(components::ModelList{T,S}) where {T,S<:Status}\n\n用于只有一个时间步的 ModelList 模型的 DataFrame 实现。\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#PlantSimEngine.AbstractBasic_Current_TimestepModel","page":"内部 API","title":"PlantSimEngine.AbstractBasic_Current_TimestepModel","text":"basic_current_timestep 过程的抽象模型类型。\n\n所有模拟 basic_current_timestep 过程的模型都必须为此类型的子类型，例如:  struct MyBasic_Current_TimestepModel <: AbstractBasic_Current_TimestepModel end。\n\n可通过 subtypes 查看实现该过程的所有模型：\n\n例子\n\nsubtypes(AbstractBasic_Current_TimestepModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_private.html#PlantSimEngine.AbstractBasic_Next_TimestepModel","page":"内部 API","title":"PlantSimEngine.AbstractBasic_Next_TimestepModel","text":"basic_next_timestep 过程的抽象模型类型。\n\n所有模拟 basic_next_timestep 过程的模型都必须为此类型的子类型，例如:  struct MyBasic_Next_TimestepModel <: AbstractBasic_Next_TimestepModel end。\n\n可通过 subtypes 查看实现该过程的所有模型：\n\n例子\n\nsubtypes(AbstractBasic_Next_TimestepModel)\n\n\n\n\n\n","category":"type"},{"location":"API/API_private.html#PlantSimEngine.AbstractNodeMapping","page":"内部 API","title":"PlantSimEngine.AbstractNodeMapping","text":"AbstractNodeMapping\n\n用于节点映射类型的抽象类型，例如单节点映射或多节点映射。\n\n\n\n\n\n","category":"type"},{"location":"API/API_private.html#PlantSimEngine.DataFormat-Tuple{Type{<:AbstractDataFrame}}","page":"内部 API","title":"PlantSimEngine.DataFormat","text":"DataFormat(T::Type)\n\n返回类型 T 的数据格式。数据格式用于确定如何遍历数据。支持以下数据格式：\n\nTableAlike：数据为类似表格的对象，例如 DataFrame 或 TimeStepTable。数据通过 Tables.jl 接口按行遍历。\nSingletonAlike：数据为类似单例的对象，例如 NamedTuple 或 TimeStepRow。数据通过按列遍历。\nTreeAlike：数据为类似树结构的对象，例如 Node。\n\n默认实现中，AbstractDataFrame、TimeStepTable、AbstractVector 和 Dict 返回 TableAlike；GraphSimulation 返回 TreeAlike；Status、ModelList、NamedTuple 和 TimeStepRow 返回 SingletonAlike。\n\nAny 的默认实现会抛出异常。如果用户希望使用其他输入类型，应为新数据格式定义此 trait，例如：\n\nPlantSimEngine.DataFormat(::Type{<:MyType}) = TableAlike()\n\n示例\n\njulia> using PlantSimEngine, PlantMeteo, DataFrames\n\njulia> PlantSimEngine.DataFormat(DataFrame)\nPlantSimEngine.TableAlike()\n\njulia> PlantSimEngine.DataFormat(TimeStepTable([Status(a = 1, b = 2, c = 3)]))\nPlantSimEngine.TableAlike()\n\njulia> PlantSimEngine.DataFormat([1, 2, 3])\nPlantSimEngine.TableAlike()\n\njulia> PlantSimEngine.DataFormat(Dict(:a => 1, :b => 2))\nPlantSimEngine.TableAlike()\n\njulia> PlantSimEngine.DataFormat(Status(a = 1, b = 2, c = 3))\nPlantSimEngine.SingletonAlike()\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#PlantSimEngine.DependencyGraph","page":"内部 API","title":"PlantSimEngine.DependencyGraph","text":"DependencyGraph{T}(roots::T, not_found::Dict{Symbol,DataType})\n\n模型之间依赖关系的图。\n\n参数\n\nroots::T：图的根节点。\nnot_found::Dict{Symbol,DataType}：在图中未找到的模型。\n\n\n\n\n\n","category":"type"},{"location":"API/API_private.html#PlantSimEngine.DependencyTrait","page":"内部 API","title":"PlantSimEngine.DependencyTrait","text":"DependencyTrait(T::Type)\n\n返回关于模型 T 在计算时是否依赖于其他时间步或对象的信息。依赖特性用于判断模型能否并行化。\n\n支持以下依赖特性：\n\nTimeStepDependencyTrait：定义模型对于时间步是否可以并行化计算的特性。\nObjectDependencyTrait：定义模型对于对象是否可以并行化计算的特性。\n\n\n\n\n\n","category":"type"},{"location":"API/API_private.html#PlantSimEngine.GraphSimulation","page":"内部 API","title":"PlantSimEngine.GraphSimulation","text":"GraphSimulation(graph, mapping)\nGraphSimulation(graph, statuses, dependency_graph, models, outputs)\n\n一个类型，包含了图上仿真所需的所有信息。\n\n参数\n\ngraph：一个图实例，比如 MTG\nmapping：模型映射字典\nstatuses：定义每个节点状态的结构体\nstatus_templates：状态模板字典\nreverse_multiscale_mapping：多尺度下其它层次的映射字典\nvar_need_init：需要初始化的变量字典\ndependency_graph：应用于图的模型的依赖图\nmodels：模型字典\noutputs：输出字典\n\n\n\n\n\n","category":"type"},{"location":"API/API_private.html#PlantSimEngine.MappedVar","page":"内部 API","title":"PlantSimEngine.MappedVar","text":"MappedVar(source_organ, variable, source_variable, source_default)\n\n映射到其他层级的变量。\n\n参数\n\nsource_organ: 映射所针对的器官（或多个器官）\nvariable: 被映射的变量名\nsource_variable: 来源器官中的变量名（实际计算该变量的变量名）\nsource_default: 变量的默认值\n\n示例\n\njulia> using PlantSimEngine\n\njulia> PlantSimEngine.MappedVar(PlantSimEngine.SingleNodeMapping(\"Leaf\"), :carbon_assimilation, :carbon_assimilation, 1.0)\nPlantSimEngine.MappedVar{PlantSimEngine.SingleNodeMapping, Symbol, Symbol, Float64}(PlantSimEngine.SingleNodeMapping(\"Leaf\"), :carbon_assimilation, :carbon_assimilation, 1.0)\n\n\n\n\n\n","category":"type"},{"location":"API/API_private.html#PlantSimEngine.MultiNodeMapping","page":"内部 API","title":"PlantSimEngine.MultiNodeMapping","text":"MultiNodeMapping(scale)\n\n用于多节点映射的类型，例如 [:carbon_assimilation => [\"Leaf\"],]。注意 \"Leaf\" 以向量形式给出， 这意味着 :carbon_assimilation 将会是从植物图中每个 \"Leaf\" 取得的值的向量。\n\n\n\n\n\n","category":"type"},{"location":"API/API_private.html#PlantSimEngine.ObjectDependencyTrait","page":"内部 API","title":"PlantSimEngine.ObjectDependencyTrait","text":"ObjectDependencyTrait(::Type{T})\n\n定义模型 T 计算时是否依赖其他对象的特性。该依赖特性用于判断模型是否可以在对象上并行化。\n\n支持以下依赖特性：\n\nIsObjectDependent：模型依赖其他对象计算，不能并行。\nIsObjectIndependent：模型不依赖其他对象，可以并行。\n\n所有模型默认设为对象依赖（即 IsObjectDependent）。这样设计的考虑：\n\n这是最安全的默认值，如果用户忘记重载不会导致错误，而相反则可能出错。\n对于对象独立模型，用户可以方便重载 trait。\n\n参见\n\ntimestep_parallelizable：判断模型能否按时间步并行。\nobject_parallelizable：判断模型能否按对象并行。\nparallelizable：判断模型是否可并行化。\nTimeStepDependencyTrait：定义模型对其他时间步的依赖性。\n\n示例\n\n定义一个测试过程:\n\nusing PlantSimEngine\n\n# 定义一个测试过程:\n@process \"TestProcess\"\n\n定义一个对象独立的模型:\n\nstruct MyModel <: AbstractTestprocessModel end\n\n# 重载对象依赖 trait:\nPlantSimEngine.ObjectDependencyTrait(::Type{MyModel}) = IsObjectIndependent()\n\n检查模型能否按对象并行:\n\nobject_parallelizable(MyModel()) # false\n\n定义一个对象依赖的模型:\n\nstruct MyModel2 <: AbstractTestprocessModel end\n\n# 重载对象依赖 trait:\nPlantSimEngine.ObjectDependencyTrait(::Type{MyModel2}) = IsObjectDependent()\n\n检查模型能否按对象并行:\n\nobject_parallelizable(MyModel()) # true\n\n\n\n\n\n","category":"type"},{"location":"API/API_private.html#PlantSimEngine.RefVariable","page":"内部 API","title":"PlantSimEngine.RefVariable","text":"RefVariable(reference_variable)\n\n用于手动标记模型中的某个变量，以在相同尺度下采用另一个变量的值的结构体。 用于变量重命名，当某变量已经由一个模型计算，但被另一个名称所引用时使用。\n\n注意：在 status 中我们并不会真正重命名变量（其他模型可能需要这个变量），而是新建一个对原有变量的引用。\n\n\n\n\n\n","category":"type"},{"location":"API/API_private.html#PlantSimEngine.RefVector","page":"内部 API","title":"PlantSimEngine.RefVector","text":"RefVector(field::Symbol, sts...)\nRefVector(field::Symbol, sts::Vector{<:Status})\nRefVector(v::Vector{Base.RefValue{T}})\n\n一个引用结构体向量中特定字段的引用向量。 用于在不同尺度之间高效地传递数值。\n\n参数\n\nfield: 要引用的结构体字段\nsts...: 要引用的结构体实例\nsts::Vector{<:Status}: 要引用的结构体实例向量\n\n示例\n\njulia> using PlantSimEngine\n\n假设有两个 Status 结构体：\n\njulia> status1 = Status(a = 1.0, b = 2.0, c = 3.0);\n\njulia> status2 = Status(a = 2.0, b = 3.0, c = 4.0);\n\n我们可以创建引用结构体 status1 和 status2 字段 a 的 RefVector：\n\njulia> rv = PlantSimEngine.RefVector(:a, status1, status2)\n2-element PlantSimEngine.RefVector{Float64}:\n 1.0\n 2.0\n\n这等效于：\n\njulia> rv = PlantSimEngine.RefVector(:a, [status1, status2])\n2-element PlantSimEngine.RefVector{Float64}:\n 1.0\n 2.0\n\n可以访问 RefVector 的值：\n\njulia> rv[1]\n1.0\n\n修改 RefVector 中的值会同时修改原结构体中的值：\n\njulia> rv[1] = 10.0\n10.0\n\njulia> status1.a\n10.0\n\n我们还可以通过引用向量创建 RefVector：\n\njulia> vec = [Ref(1.0), Ref(2.0), Ref(3.0)]\n3-element Vector{Base.RefValue{Float64}}:\n Base.RefValue{Float64}(1.0)\n Base.RefValue{Float64}(2.0)\n Base.RefValue{Float64}(3.0)\n\njulia> rv = PlantSimEngine.RefVector(vec)\n3-element PlantSimEngine.RefVector{Float64}:\n 1.0\n 2.0\n 3.0\n\njulia> rv[1]\n1.0\n\n\n\n\n\n","category":"type"},{"location":"API/API_private.html#PlantSimEngine.SelfNodeMapping","page":"内部 API","title":"PlantSimEngine.SelfNodeMapping","text":"SelfNodeMapping()\n\n自节点映射类型，即节点映射到其自身。 用于标记将会被其他模型以标量值引用的变量。可出现于两种情况：     - 该变量由其他层级计算，因此需要作为输入存在于本层级（否则不会在本层级计算）     - 该变量作为输入用于其他层级，但仅以单值（标量）引用，因此需要将其作为标量引用。\n\n\n\n\n\n","category":"type"},{"location":"API/API_private.html#PlantSimEngine.SingleNodeMapping","page":"内部 API","title":"PlantSimEngine.SingleNodeMapping","text":"SingleNodeMapping(scale)\n\n用于单节点映射的类型，例如 [:soil_water_content => \"Soil\",]。注意 \"Soil\" 是以标量形式给出， 这意味着 :soil_water_content 将会是从植物图中特定的 \"Soil\" 节点取得的一个标量值。\n\n\n\n\n\n","category":"type"},{"location":"API/API_private.html#PlantSimEngine.TimeStepDependencyTrait-Tuple{Type}","page":"内部 API","title":"PlantSimEngine.TimeStepDependencyTrait","text":"TimeStepDependencyTrait(::Type{T})\n\n定义模型 T 计算时是否依赖其他时间步的特性。该依赖特性用于判断模型是否可以在时间步上并行化。\n\n支持以下依赖特性：\n\nIsTimeStepDependent：该模型的计算依赖其他时间步，不能并行执行。\nIsTimeStepIndependent：该模型的计算不依赖其他时间步，可以并行执行。\n\n所有模型默认设为时间步依赖（即 IsTimeStepDependent）。虽然大多数模型不一定如此，但这样设计有两个原因：\n\n这是最安全的默认值——如果用户忘记重载这个 trait，不会导致错误结果，相反（设为独立）则可能出错。\n对于时间步独立的模型，用户可以很方便地重载此 trait。\n\n参见\n\ntimestep_parallelizable：判断模型能否在时间步并行。\nobject_parallelizable：判断模型能否在对象间并行。\nparallelizable：判断模型是否可并行化。\nObjectDependencyTrait：定义模型对其他对象的依赖性。\n\n示例\n\n定义一个测试过程:\n\nusing PlantSimEngine\n\n# 定义一个测试过程:\n@process \"TestProcess\"\n\n定义一个时间步独立的模型:\n\nstruct MyModel <: AbstractTestprocessModel end\n\n# 重载时间步依赖 trait:\nPlantSimEngine.TimeStepDependencyTrait(::Type{MyModel}) = IsTimeStepIndependent()\n\n检查模型能否按时间步并行:\n\ntimestep_parallelizable(MyModel()) # false\n\n定义一个时间步依赖的模型:\n\nstruct MyModel2 <: AbstractTestprocessModel end\n\n# 重载时间步依赖 trait:\nPlantSimEngine.TimeStepDependencyTrait(::Type{MyModel2}) = IsTimeStepDependent()\n\n检查模型能否按时间步并行:\n\ntimestep_parallelizable(MyModel()) # true\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#PlantSimEngine.UninitializedVar","page":"内部 API","title":"PlantSimEngine.UninitializedVar","text":"UninitializedVar(variable, value)\n\n尚未初始化的变量，赋予一个名称和一个默认值。\n\n\n\n\n\n","category":"type"},{"location":"API/API_private.html#Base.copy-Tuple{T} where T<:(AbstractArray{<:ModelList})","page":"内部 API","title":"Base.copy","text":"Base.copy(l::AbstractArray{<:ModelList})\n\n复制 ModelList 的数组类结构\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#Base.copy-Tuple{T} where T<:(AbstractDict{N, <:ModelList} where N)","page":"内部 API","title":"Base.copy","text":"Base.copy(l::AbstractDict{N,<:ModelList} where N)\n\n复制字典类 ModelList\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#Base.copy-Tuple{T} where T<:ModelList","page":"内部 API","title":"Base.copy","text":"Base.copy(l::ModelList)\nBase.copy(l::ModelList, status)\n\n复制一个 ModelList，可选替换新的 status。\n\n示例\n\nusing PlantSimEngine\n\n# 包含示例过程和模型：\nusing PlantSimEngine.Examples;\n\n# 创建模型列表：\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=(var1=15.0, var2=0.3)\n)\n\n# 复制模型列表：\nml2 = copy(models)\n\n# 使用新 status 复制模型列表：\nml3 = copy(models, TimeStepTable([Status(var1=20.0, var2=0.5))])\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#Base.getindex-Union{Tuple{T}, Tuple{T, Any}} where T<:ModelList","page":"内部 API","title":"Base.getindex","text":"getindex(component<:ModelList, key::Symbol)\ngetindex(component<:ModelList, key)\n\n对组件模型结构进行索引:     - 当参数为整数时，会返回第 i 个时间步的状态     - 其他（Symbol、String）则会返回状态中的对应变量\n\n示例\n\nusing PlantSimEngine\n\nlm = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status = (var1=[15.0, 16.0], var2=0.3)\n);\n\nlm[:var1] # 返回 Tₗ 变量的值\nlm[2]  # 返回第二个时间步的状态\nlm[2][:var1] # 返回第二个时间步的 Tₗ 变量的值\nlm[:var1][2] # 等价于上面\n\n# 输出\n16.0\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#PlantSimEngine.add_mapped_variables_with_outputs_as_inputs!-Tuple{Any}","page":"内部 API","title":"PlantSimEngine.add_mapped_variables_with_outputs_as_inputs!","text":"add_mapped_variables_with_outputs_as_inputs!(mapped_vars)\n\n将计算于一个尺度并写入到另一个尺度的变量添加进映射字典。\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#PlantSimEngine.add_model_vars-Tuple{Any, Any, Any}","page":"内部 API","title":"PlantSimEngine.add_model_vars","text":"add_model_vars(x, models, type_promotion)\n\n检测 x 中哪些变量还未初始化（根据一组 models 及其所需模拟变量）。如有变量未初始化，将其初始化为默认值。\n\n本函数需根据不同类型的 x 实现。默认方法适用于任意 Tables.jl 兼容结构和 NamedTuples。\n\n注意，该函数会在变量未齐全时复制输入 x。\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#PlantSimEngine.check_dimensions-Tuple{Any, Any}","page":"内部 API","title":"PlantSimEngine.check_dimensions","text":"check_dimensions(component,weather)\ncheck_dimensions(status,weather)\n\n检查组件状态（或直接检查状态）和天气数据长度是否一致，或它们是否可以被复用（其中一个的长度为1）。\n\n示例\n\nusing PlantSimEngine, PlantMeteo\n\n# 引入包含虚拟过程和模型的示例脚本：\nusing PlantSimEngine.Examples\n\n# 创建一个虚拟天气：\nw = Atmosphere(T = 20.0, Rh = 0.5, Wind = 1.0)\n\n# 创建一个虚拟组件：\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=(var1=[15.0, 16.0], var2=0.3)\n)\n\n# 检查时间步数是否兼容（此处兼容，返回nothing）：\nPlantSimEngine.check_dimensions(models, w) \n\n# 创建一个包含3个时间步的虚拟天气：\nw = Weather([\n    Atmosphere(T = 20.0, Rh = 0.5, Wind = 1.0),\n    Atmosphere(T = 25.0, Rh = 0.5, Wind = 1.0),\n    Atmosphere(T = 30.0, Rh = 0.5, Wind = 1.0)\n])\n\n# 检查时间步数是否兼容（此处不兼容，会抛出错误）：\nPlantSimEngine.check_dimensions(models, w)\n\n# output\nERROR: DimensionMismatch: Component status has a vector variable : var1 implying multiple timesteps but weather data only provides a single timestep.\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#PlantSimEngine.convert_reference_values!-Tuple{Dict{String, Dict{Symbol, Any}}}","page":"内部 API","title":"PlantSimEngine.convert_reference_values!","text":"convert_reference_values!(mapped_vars::Dict{String,Dict{Symbol,Any}})\n\n将MappedVar{SelfNodeMapping}或MappedVar{SingleNodeMapping}变量转为参考同一变量值的RefValue； 将MappedVar{MultiNodeMapping}转为RefVector，引用源器官的变量值。\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#PlantSimEngine.convert_vars","page":"内部 API","title":"PlantSimEngine.convert_vars","text":"convert_vars(ref_vars, type_promotion::Dict{DataType,DataType})\nconvert_vars(ref_vars, type_promotion::Nothing)\nconvert_vars!(ref_vars::Dict{Symbol}, type_promotion::Dict{DataType,DataType})\nconvert_vars!(ref_vars::Dict{Symbol}, type_promotion::Nothing)\n\n将 status 变量转换为 type_promotion 字典中指定的类型。 注：带 ! 的变异版仅适用于变量字典。\n\n示例\n\n若需将所有 Real 类型变量转为 Float32，可使用：\n\nusing PlantSimEngine\n\n# 包含示例过程和模型：\nusing PlantSimEngine.Examples;\n\nref_vars = init_variables(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n)\ntype_promotion = Dict(Real => Float32)\n\nPlantSimEngine.convert_vars(type_promotion, ref_vars.process3)\n\n\n\n\n\n","category":"function"},{"location":"API/API_private.html#PlantSimEngine.convert_vars!","page":"内部 API","title":"PlantSimEngine.convert_vars!","text":"convert_vars(ref_vars, type_promotion::Dict{DataType,DataType})\nconvert_vars(ref_vars, type_promotion::Nothing)\nconvert_vars!(ref_vars::Dict{Symbol}, type_promotion::Dict{DataType,DataType})\nconvert_vars!(ref_vars::Dict{Symbol}, type_promotion::Nothing)\n\n将 status 变量转换为 type_promotion 字典中指定的类型。 注：带 ! 的变异版仅适用于变量字典。\n\n示例\n\n若需将所有 Real 类型变量转为 Float32，可使用：\n\nusing PlantSimEngine\n\n# 包含示例过程和模型：\nusing PlantSimEngine.Examples;\n\nref_vars = init_variables(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n)\ntype_promotion = Dict(Real => Float32)\n\nPlantSimEngine.convert_vars(type_promotion, ref_vars.process3)\n\n\n\n\n\n","category":"function"},{"location":"API/API_private.html#PlantSimEngine.convert_vars!-Tuple{Dict{String, Dict{Symbol, Any}}, Any}","page":"内部 API","title":"PlantSimEngine.convert_vars!","text":"convert_vars!(mapped_vars::Dict{String,Dict{String,Any}}, type_promotion)\n\n使用 type_promotion 字典将映射（mapped_vars）中的变量类型进行转换。\n\nmapped_vars 应为器官名称到变量字典的字典，变量名为 Symbol，变量值为值。\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#PlantSimEngine.default_variables_from_mapping","page":"内部 API","title":"PlantSimEngine.default_variables_from_mapping","text":"default_variables_from_mapping(mapped_vars, verbose=true)\n\n递归从映射关系中查找原始映射值，获取映射变量的默认值。\n\n参数\n\nmapped_vars::Dict{String,Dict{Symbol,Any}}: 每个器官的映射变量。\nverbose::Bool: 是否打印在mapping中查找默认值的堆栈追踪。\n\n\n\n\n\n","category":"function"},{"location":"API/API_private.html#PlantSimEngine.diff_vars-Tuple{Any, Any}","page":"内部 API","title":"PlantSimEngine.diff_vars","text":"diff_vars(x, y)\n\n返回 x 和 y 中值不同的变量名称。\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#PlantSimEngine.draw_guide-NTuple{5, Any}","page":"内部 API","title":"PlantSimEngine.draw_guide","text":"draw_guide(h, w, prefix, isleaf, guides)\n\n为依赖图的一个节点绘制连线引导\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#PlantSimEngine.draw_panel","page":"内部 API","title":"PlantSimEngine.draw_panel","text":"draw_panel(node, graph, prefix, dep_graph_guides, parent; title=\"Soft-coupled model\")\n\n为所有依赖项绘制面板\n\n\n\n\n\n","category":"function"},{"location":"API/API_private.html#PlantSimEngine.drop_process-Tuple{Any, Symbol}","page":"内部 API","title":"PlantSimEngine.drop_process","text":"drop_process(proc_vars, process)\n\n返回将 NamedTuple proc_vars 中 process process 删除后的新 NamedTuple。\n\n参数\n\nproc_vars::NamedTuple: 要删除进程的 NamedTuple。\nprocess::Symbol: 需要从 NamedTuple proc_vars 中删除的进程。\n\n返回\n\n删除了 process 后的 NamedTuple。\n\n示例\n\njulia> drop_process((a = 1, b = 2, c = 3), :b)\n(a = 1, c = 3)\n\njulia> drop_process((a = 1, b = 2, c = 3), (:a, :c))\n(b = 2,)\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#PlantSimEngine.flatten_vars-Tuple{Any}","page":"内部 API","title":"PlantSimEngine.flatten_vars","text":"flatten_vars(vars)\n\n返回 vars 字典中的变量集合。\n\n参数\n\nvars::Dict{Symbol, Tuple{Symbol, Vararg{Symbol}}}: 进程到变量内容的字典。\n\n返回\n\nvars 字典中的变量集合。\n\n示例\n\njulia> flatten_vars(Dict(:process1 => (:var1, :var2), :process2 => (:var3, :var4)))\nSet{Symbol} with 4 elements:\n  :var4\n  :var3\n  :var2\n  :var1\n\njulia> flatten_vars([:process1 => (var1 = -Inf, var2 = -Inf), :process2 => (var3 = -Inf, var4 = -Inf)])\n(var2 = -Inf, var4 = -Inf, var3 = -Inf, var1 = -Inf)\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#PlantSimEngine.get_mapped_variables-Tuple{Any}","page":"内部 API","title":"PlantSimEngine.get_mapped_variables","text":"get_mapped_variables(m)\n\n获取模型映射字典中的变量映射。\n\n参数\n\nm::Dict{String,Any}: 一个模型映射的字典\n\n返回由符号和字符串或字符串向量组成的Pair的向量。\n\n示例\n\n参见get_models中的示例。\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#PlantSimEngine.get_model_nodes-Tuple{PlantSimEngine.DependencyGraph, Any}","page":"内部 API","title":"PlantSimEngine.get_model_nodes","text":"get_model_nodes(dep_graph::DependencyGraph, model)\n\n获取依赖图中实现某种模型类型的节点。\n\n参数\n\ndep_graph::DependencyGraph：依赖关系图。\nmodel：要查找的模型类型。\n\n返回\n\n实现该模型类型的节点数组。\n\n示例\n\nPlantSimEngine.get_model_nodes(dependency_graph, Beer)\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#PlantSimEngine.get_models-Tuple{Any}","page":"内部 API","title":"PlantSimEngine.get_models","text":"get_models(m)\n\n获取模型映射字典中的模型。\n\n参数\n\nm::Dict{String,Any}: 一个模型映射的字典\n\n返回一个模型的向量\n\n示例\n\njulia> using PlantSimEngine;\n\n导入示例模型（可以在本包的examples文件夹或Examples子模块中找到）:\n\njulia> using PlantSimEngine.Examples;\n\n如果只提供一个MultiScaleModel，将获得其模型，结果为单元素向量：\n\njulia> models = MultiScaleModel( model=ToyCAllocationModel(), mapped_variables=[ :carbon_assimilation => [\"Leaf\"], :carbon_demand => [\"Leaf\", \"Internode\"], :carbon_allocation => [\"Leaf\", \"Internode\"] ], );\n\njulia> PlantSimEngine.get_models(models)\n1-element Vector{ToyCAllocationModel}:\n ToyCAllocationModel()\n\n如果提供一个模型元组，将分别得到每个模型，返回为向量：\n\njulia> models2 = (  MultiScaleModel( model=ToyAssimModel(), mapped_variables=[:soil_water_content => \"Soil\",], ), ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0), Status(aPPFD=1300.0, TT=10.0), );\n\n注意此处在映射时提供的是\"Soil\"而不是[\"Soil\"]，因为此处只需要一个值。\n\njulia> PlantSimEngine.get_models(models2)\n2-element Vector{AbstractModel}:\n ToyAssimModel{Float64}(0.2)\n ToyCDemandModel{Float64}(10.0, 200.0)\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#PlantSimEngine.get_multiscale_default_value","page":"内部 API","title":"PlantSimEngine.get_multiscale_default_value","text":"get_multiscale_default_value(mapped_vars, val, mapping_stacktrace=[])\n\n从映射关系获取变量的默认值。\n\n参数\n\nmapped_vars::Dict{String,Dict{Symbol,Any}}: 每个器官的映射变量。\nval::Any: 需要获取默认值的变量。\nmapping_stacktrace::Vector{Any}: 在向上查找映射值时的堆栈追踪。\n\n\n\n\n\n","category":"function"},{"location":"API/API_private.html#PlantSimEngine.get_nsteps-Tuple{Any}","page":"内部 API","title":"PlantSimEngine.get_nsteps","text":"get_nsteps(t)\n\n获取对象的时间步数量。\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#PlantSimEngine.get_status-Tuple{Any}","page":"内部 API","title":"PlantSimEngine.get_status","text":"get_status(m)\n\n获取模型映射字典中的状态。\n\n参数\n\nm::Dict{String,Any}: 一个模型映射的字典\n\n返回Status或nothing。\n\n示例\n\n参见get_models中的示例。\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#PlantSimEngine.hard_dependencies-Tuple{Any}","page":"内部 API","title":"PlantSimEngine.hard_dependencies","text":"hard_dependencies(models; verbose::Bool=true)\nhard_dependencies(mapping::Dict{String,T}; verbose::Bool=true)\n\n计算模型之间的硬依赖关系。\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#PlantSimEngine.homogeneous_ts_kwargs-Tuple{Any}","page":"内部 API","title":"PlantSimEngine.homogeneous_ts_kwargs","text":"homogeneous_ts_kwargs(kwargs)\n\n默认情况下，此函数直接返回其参数。\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#PlantSimEngine.homogeneous_ts_kwargs-Union{Tuple{NamedTuple{N, T}}, Tuple{T}, Tuple{N}} where {N, T}","page":"内部 API","title":"PlantSimEngine.homogeneous_ts_kwargs","text":"kwargs_to_timestep(kwargs::NamedTuple{N,T}) where {N,T}\n\n将各变量为（可选）向量的 NamedTuple，转换为每个时间步为一个 NamedTuple 的向量。 可用于对某一变量在所有时间步赋常值。\n\n示例\n\nPlantSimEngine.homogeneous_ts_kwargs((Tₗ=[25.0, 26.0], aPPFD=1000.0))\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#PlantSimEngine.init_node_status!","page":"内部 API","title":"PlantSimEngine.init_node_status!","text":"init_node_status!(\n    node, \n    statuses, \n    mapped_vars, \n    reverse_multiscale_mapping,\n    vars_need_init=Dict{String,Any}(),\n    type_promotion=nothing;\n    check=true,\n    attribute_name=:plantsimengine_status)\n)\n\n初始化植物图节点的状态，考虑多尺度映射，并将状态添加到statuses字典中。\n\n参数\n\nnode：要初始化的节点\nstatuses：按节点类型分的状态字典\nmapped_vars：每个节点类型的状态模板\nreverse_multiscale_mapping：被映射到其他尺度的变量\nvar_need_init：没有被其它模型初始化或计算的变量\nnodes_with_models：有模型定义的节点\ntype_promotion：变量类型提升\ncheck：是否检查映射中的错误（见Details）\nattribute_name：状态存储到节点中的属性名，默认为:plantsimengine_status\n\n细节\n\n大部分参数可以根据图和映射计算获得：\n\nstatuses通过第一次初始化获得：statuses = Dict(i => Status[] for i in nodes_with_models)\nmapped_vars用mapped_variables()得到，见init_statuses中的代码\nvars_need_init通过vars_need_init = Dict(org => filter(x -> isa(last(x), UninitializedVar), vars) |> keys for (org, vars) in mapped_vars) |> filter(x -> length(last(x)) > 0) 计算获得\n\ncheck参数表示是否检查变量初始化。在某些变量需要初始化（部分初始化映射）的情况下，会判断节点属性（按变量名）中是否可获取。如果true，当属性不存在时会报错，否则使用模型的默认值。\n\n\n\n\n\n","category":"function"},{"location":"API/API_private.html#PlantSimEngine.init_simulation-Tuple{Any, Any}","page":"内部 API","title":"PlantSimEngine.init_simulation","text":"init_simulation(mtg, mapping; nsteps=1, outputs=nothing, type_promotion=nothing, check=true, verbose=true)\n\n初始化仿真环境，返回：\n\nmtg\n各器官类型下每个节点的status，考虑多尺度变量\n模型依赖图\n模型字典 organ type => NamedTuple of process => model mapping\n预分配的输出outputs\n\n参数\n\nmtg：MTG\nmapping::Dict{String,Any}：模型映射字典\nnsteps：仿真步数\noutputs：仿真需要的动态输出项\ntype_promotion：变量类型提升\ncheck：是否检查映射错误，会传递到init_node_status!\nverbose：关于映射错误的信息\n\n细节\n\n本函数首先为每个在mapping中拥有模型的器官类型计算status模板。 然后利用该模板初始化每个节点的status，兼顾用户自定义的初始化和多尺度mapping。 mapping用于对跨尺度定义的变量创建引用，从而保证当变量在其它尺度更新时自动同步。 目前支持两种多尺度变量类型：RefVector和MappedVar。 前者用于变量映射到一组节点，后者用于变量映射到单个节点。 用法为：只要用字符串即可表示单节点（如=> \"Leaf\"），用字符串数组表示多节点（如=> [\"Leaf\"]或=> [\"Leaf\", \"Internode\"]）。\n\n本函数还会计算模型的依赖图，即根据模型间的输入输出关系，确定仿真调用顺序。 依赖图用于仿真运行时保证模型调用的合理顺序。\n\n注意，如果变量既没有被模型计算，也没有在mapping初始化，会在MTG属性中查找其值。 该值是拷贝，而非对MTG属性的引用，因为无法引用Dict中的值。 如需引用特定变量，可以在MTG中直接用Ref，会被自动原样传递。\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#PlantSimEngine.init_statuses-Tuple{Any, Any, Any}","page":"内部 API","title":"PlantSimEngine.init_statuses","text":"init_statuses(mtg, mapping, dependency_graph=dep(mapping); type_promotion=nothing, verbose=true, check=true)\n\n获取每个MTG节点的状态，按节点类型分组，预初始化，考虑多尺度变量。\n\n参数\n\nmtg：植物图\nmapping：模型映射的字典\ndependency_graph::DependencyGraph：一级依赖图，其中每个模型在映射中被分配为一个节点。 但是，识别为硬依赖的模型不会单独作为节点存在，而是作为子节点嵌套在其他模型下。\ntype_promotion：用于变量的类型提升\nverbose：在编译映射时打印信息\ncheck：是否检查映射中的错误。此参数会传递给init_node_status!。\n\n返回值\n\n返回一个NamedTuple，内容包含按节点类型分的状态、按节点类型分的状态模板、被映射到其他尺度的变量字典、 需要被其它模型初始化或计算的变量字典，以及一个有已定义模型符号的节点向量：\n\n(;statuses, status_templates, reverse_multiscale_mapping, vars_need_init, nodes_with_models)\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#PlantSimEngine.init_variables_manual-Tuple{Any, Any}","page":"内部 API","title":"PlantSimEngine.init_variables_manual","text":"init_variables_manual(models...;vars...)\n\n以给定值初始化模型变量。\n\n示例\n\nusing PlantSimEngine\n\n# 加载包中的示例虚拟模型：\nusing PlantSimEngine.Examples\n\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model()\n)\n\nPlantSimEngine.init_variables_manual(status(models), (var1=20.0,))\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#PlantSimEngine.initialise_all_as_hard_dependency_node-Tuple{Any, Any}","page":"内部 API","title":"PlantSimEngine.initialise_all_as_hard_dependency_node","text":"initialise_all_as_hard_dependency_node(models)\n\n针对一组模型，为每个模型初始化一个硬依赖节点， 并返回:process => HardDependencyNode组成的字典。\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#PlantSimEngine.is_graph_cyclic-Tuple{PlantSimEngine.DependencyGraph}","page":"内部 API","title":"PlantSimEngine.is_graph_cyclic","text":"is_graph_cyclic(dependency_graph::DependencyGraph; full_stack=false, verbose=true)\n\n判断依赖图是否包含环。\n\n参数\n\ndependency_graph::DependencyGraph：需要检查的依赖图。\nfull_stack::Bool=false：若为true，返回构成环的所有节点栈，否则只返回环本身。\nwarn::Bool=true：若为true，当检测到环时输出格式化的警告信息。\n\n返回一个布尔值指示图是否有环，以及作为向量的节点栈。\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#PlantSimEngine.mapped_variables","page":"内部 API","title":"PlantSimEngine.mapped_variables","text":"mapped_variables(mapping, dependency_graph=first(hard_dependencies(mapping; verbose=false)); verbose=false)\n\n从依赖图中获取每种器官类型的变量，并为多尺度映射构建MappedVar。\n\n参数\n\nmapping::Dict{String,T}: 模型与尺度的映射关系。\ndependency_graph::DependencyGraph: 第一阶依赖图，每个mapping中的模型为一个节点。 但被识别为“硬依赖”的模型不会分配单独节点，而是作为子节点嵌套到其他模型下。\nverbose::Bool: 是否打印在mapping中寻找默认值时的堆栈跟踪。\n\n\n\n\n\n","category":"function"},{"location":"API/API_private.html#PlantSimEngine.mapped_variables_no_outputs_from_other_scale","page":"内部 API","title":"PlantSimEngine.mapped_variables_no_outputs_from_other_scale","text":"mapped_variables_no_outputs_from_other_scale(mapping, dependency_graph=first(hard_dependencies(mapping; verbose=false)))\n\n从依赖图中获取每种器官类型的变量，但不包括那些来自其他尺度输出的变量。\n\n参数\n\nmapping::Dict{String,T}: 模型与尺度的映射关系。\ndependency_graph::DependencyGraph: 第一阶依赖图，每个mapping中的模型为一个节点。但硬依赖模型不会分配独立节点，而作为子节点嵌套到其他模型下。\n\n细节\n\n本函数返回每个器官类型的（多尺度）输入输出变量字典。\n\n注意本函数不包括来自其他尺度但在本尺度未计算的输出变量， 相关处理见mapped_variables_with_outputs_as_inputs。\n\n\n\n\n\n","category":"function"},{"location":"API/API_private.html#PlantSimEngine.model_-Tuple{AbstractModel}","page":"内部 API","title":"PlantSimEngine.model_","text":"model_(m::AbstractModel)\n\n获取抽象模型的模型（如果不是多尺度模型 MultiScaleModel，则返回其本身）。\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#PlantSimEngine.object_parallelizable-Tuple{T} where T","page":"内部 API","title":"PlantSimEngine.object_parallelizable","text":"object_parallelizable(x::T)\nobject_parallelizable(x::DependencyGraph)\n\n判断模型 x 是否可以并行化计算，即模型是否能在不同对象间并行计算，返回 true 或 false。\n\n默认情况下，所有模型均返回 false。 如果你的模型可以按对象并行化，应为其添加 ObjectDependencyTrait 方法。\n\n本方法也可直接用于 DependencyGraph，若图中所有模型可并行化则返回 true，否则为 false。\n\n参见\n\ntimestep_parallelizable：判断模型能否按时间步并行。\nparallelizable：判断模型是否可并行化。\nObjectDependencyTrait：定义模型对其他对象的依赖性。\n\n示例\n\n定义一个测试过程:\n\nusing PlantSimEngine\n\n# 定义一个测试过程:\n@process \"TestProcess\"\n\n定义一个对象独立的模型:\n\nstruct MyModel <: AbstractTestprocessModel end\n\n# 重载对象依赖 trait:\nPlantSimEngine.ObjectDependencyTrait(::Type{MyModel}) = IsObjectIndependent()\n\n检查模型能否按对象并行:\n\nobject_parallelizable(MyModel()) # true\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#PlantSimEngine.parallelizable-Tuple{T} where T","page":"内部 API","title":"PlantSimEngine.parallelizable","text":"parallelizable(::T)\nobject_parallelizable(x::DependencyGraph)\n\n判断模型 T 或整个依赖图是否可并行化，也即模型是否可在不同的时间步或对象之间并行计算。默认所有模型均返回 false。\n\n参见\n\ntimestep_parallelizable：判断模型能否按时间步并行。\nobject_parallelizable：判断模型能否按对象并行。\nTimeStepDependencyTrait：定义模型对其他时间步的依赖性。\n\n示例\n\n定义一个测试过程:\n\nusing PlantSimEngine\n\n# 定义一个测试过程:\n@process \"TestProcess\"\n\n定义一个可并行化模型:\n\nstruct MyModel <: AbstractTestprocessModel end\n\n# 重载时间步依赖 trait:\nPlantSimEngine.TimeStepDependencyTrait(::Type{MyModel}) = IsTimeStepIndependent()\n\n# 重载对象依赖 trait:\nPlantSimEngine.ObjectDependencyTrait(::Type{MyModel}) = IsObjectIndependent()\n\n检查模型是否可并行化:\n\nparallelizable(MyModel()) # true\n\n或者更细致地查看：\n\ntimestep_parallelizable(MyModel())\nobject_parallelizable(MyModel())\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#PlantSimEngine.ref_var-Tuple{Any}","page":"内部 API","title":"PlantSimEngine.ref_var","text":"ref_var(v)\n\n为变量创建引用。如果变量已经是Base.RefValue，则直接返回，否则返回其副本的Ref， 如果是RefVector则返回其Ref。\n\n示例\n\njulia> using PlantSimEngine;\n\njulia> PlantSimEngine.ref_var(1.0)\nBase.RefValue{Float64}(1.0)\n\njulia> PlantSimEngine.ref_var([1.0])\nBase.RefValue{Vector{Float64}}([1.0])\n\njulia> PlantSimEngine.ref_var(Base.RefValue(1.0))\nBase.RefValue{Float64}(1.0)\n\njulia> PlantSimEngine.ref_var(Base.RefValue([1.0]))\nBase.RefValue{Vector{Float64}}([1.0])\n\njulia> PlantSimEngine.ref_var(PlantSimEngine.RefVector([Ref(1.0), Ref(2.0), Ref(3.0)]))\nBase.RefValue{PlantSimEngine.RefVector{Float64}}(RefVector{Float64}[1.0, 2.0, 3.0])\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#PlantSimEngine.reverse_mapping-Union{Tuple{Dict{String, T}}, Tuple{T}} where T","page":"内部 API","title":"PlantSimEngine.reverse_mapping","text":"reverse_mapping(mapping::Dict{String,Tuple{Any,Vararg{Any}}}; all=true)\nreverse_mapping(mapped_vars::Dict{String,Dict{Symbol,Any}})\n\n获取模型映射字典的反向映射，即，被映射到其他尺度的变量，换句话说， 从给定尺度向其他尺度传递了哪些变量。 这可以用于，例如，了解哪些尺度需要把数值赋给其他尺度。\n\n参数\n\nmapping::Dict{String,Any}: 模型映射的字典。\nall::Bool: 是否获取所有被映射到其他尺度的变量，包括那些被映射为单一值的变量。\n\n返回值\n\n一个以器官（键）为主的字典，值为字典：源器官 => 一组变量对的字典。你可以这样理解输出结果： “对于每个器官（源器官），它向哪个其他器官（目标器官）传递了自己的哪些变量。然后对于每个源器官，具体哪个变量 传递到了目标器官（对中的第一个符号），以及它在目标器官中被映射为哪个变量（对中的第二个符号）。”\n\n示例\n\njulia> using PlantSimEngine\n\n导入示例模型（可在包的 examples 文件夹，或 Examples 子模块中找到）： \n\njulia> using PlantSimEngine.Examples;\n\njulia> mapping = Dict( \"Plant\" => MultiScaleModel( model=ToyCAllocationModel(), mapped_variables=[ :carbon_assimilation => [\"Leaf\"], :carbon_demand => [\"Leaf\", \"Internode\"], :carbon_allocation => [\"Leaf\", \"Internode\"] ], ), \"Internode\" => ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0), \"Leaf\" => ( MultiScaleModel( model=ToyAssimModel(), mapped_variables=[:soil_water_content => \"Soil\",], ), ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0), Status(aPPFD=1300.0, TT=10.0), ), \"Soil\" => ( ToySoilWaterModel(), ), );\n\n注意我们在 Leaf 的 ToyAssimModel 的映射中提供了 \"Soil\"，而不是 [\"Soil\"] 。 这是因为预期在这里映射 soil_water_content 的只有一个土壤，因此允许 将该值作为单值获取，而不是一个值向量。\n\njulia> PlantSimEngine.reverse_mapping(mapping)\nDict{String, Dict{String, Dict{Symbol, Any}}} with 3 entries:\n  \"Soil\"      => Dict(\"Leaf\"=>Dict(:soil_water_content=>:soil_water_content))\n  \"Internode\" => Dict(\"Plant\"=>Dict(:carbon_allocation=>:carbon_allocation, :ca…\n  \"Leaf\"      => Dict(\"Plant\"=>Dict(:carbon_allocation=>:carbon_allocation, :ca…\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#PlantSimEngine.save_results!-Tuple{PlantSimEngine.GraphSimulation, Any}","page":"内部 API","title":"PlantSimEngine.save_results!","text":"save_results!(object::GraphSimulation, i)\n\n将时间步 i 的仿真结果存储到 object 中。 对于 GraphSimulation 对象，此操作会把 status(object) 里的结果写入 outputs(object)。\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#PlantSimEngine.search_inputs_in_multiscale_output-NTuple{6, Any}","page":"内部 API","title":"PlantSimEngine.search_inputs_in_multiscale_output","text":"search_inputs_in_multiscale_output(process, organ, inputs, soft_dep_graphs)\n\n参数\n\nprocess::Symbol: 需要查找其它尺度下软依赖的进程。\norgan::String: 需要查找软依赖的器官（层级）。\ninputs::Dict{Symbol, Vector{Pair{Symbol}, Tuple{Symbol, Vararg{Symbol}}}}: 一个 dict，进程 => [:子进程 => (:var1, :var2)]。\nsoft_dep_graphs::Dict{String, ...}: 一个 dict，器官 => (依赖子图, 输入, 输出)。\nrev_mapping::Dict{Symbol, Symbol}: 反向映射，映射变量 => 来源变量。\n'harddependenciesfromotherscale' : 存储跨层级硬依赖的 HardDependencyNode 向量，便于不遍历整个图时访问\n\n细节\n\n输入（输出同理）给出了每个进程的输入，按来源进程分类，来源可以是进程自身或硬依赖的其他进程。\n\n返回\n\n每个进程在其他层级下在输出中找到的软依赖变量组成的字典，例如：\n\nDict{String, Dict{Symbol, Vector{Symbol}}} with 2 entries:\n    \"Internode\" => Dict(:carbon_demand=>[:carbon_demand])\n    \"Leaf\"      => Dict(:carbon_assimilation=>[:carbon_assimilation], :carbon_demand=>[:carbon_demand])\n\n上述结果表示变量 :carbon_demand 由 \"Internode\" 层级下的 :carbondemand 过程计算，变量 `:carbonassimilation` 则由 \"Leaf\" 层级下的 :carbon_assimilation 过程计算。这些变量作为当前进程的输入。\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#PlantSimEngine.search_inputs_in_output-Tuple{Any, Any, Any}","page":"内部 API","title":"PlantSimEngine.search_inputs_in_output","text":"search_inputs_in_output(process, inputs, outputs)\n\n返回依赖图 d 中进程的软依赖组成的字典。 软依赖是指模型中没有显式定义，但可以通过进程的输入输出推断出来的依赖关系。\n\n参数\n\nprocess::Symbol: 需要查找软依赖的进程。\ninputs::Dict{Symbol, Vector{Pair{Symbol}, Tuple{Symbol, Vararg{Symbol}}}}: 一个 dict，进程对应其输入符号。\noutputs::Dict{Symbol, Tuple{Symbol, Vararg{Symbol}}}: 一个 dict，进程对应其输出符号。\n\n细节\n\n输入（输出同理）给出了每个进程的输入，按来源进程分类，来源可以是进程自身或硬依赖的其他进程。\n\n返回\n\n进程软依赖组成的字典。\n\n示例\n\nin_ = Dict(\n    :process3 => [:process3=>(:var4, :var5), :process2=>(:var1, :var3), :process1=>(:var1, :var2)],\n    :process4 => [:process4=>(:var0,)],\n    :process6 => [:process6=>(:var7, :var9)],\n    :process5 => [:process5=>(:var5, :var6)],\n)\n\nout_ = Dict(\n    :process3 => Pair{Symbol}[:process3=>(:var4, :var6), :process2=>(:var4, :var5), :process1=>(:var3,)],\n    :process4 => [:process4=>(:var1, :var2)],\n    :process6 => [:process6=>(:var8,)],\n    :process5 => [:process5=>(:var7,)],\n)\n\nsearch_inputs_in_output(:process3, in_, out_)\n(process4 = (:var1, :var2),)\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#PlantSimEngine.set_variables_at_timestep!-Tuple{Status, Status, Any, Any}","page":"内部 API","title":"PlantSimEngine.set_variables_at_timestep!","text":"set_variables_at_timestep!(status_timestep::Status, user_status::Status, variables_to_update, timestep)\n\n将 status_timestep 中所有在 variables_to_update 中的变量，更新为用户提供的 user_status 在指定 timestep 上的当前值。 变量名列表由 variables_to_update 提供，为符号向量。\n\nstatus_timestep 是表示单次时间步长的状态，user_status 是用户提供的状态，包含未被任何模型计算的变量的值。 其变量值可以为常量，也可以是向量。如果为向量，则用 timestep 指定当前步长所用的值。\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#PlantSimEngine.soft_dependencies","page":"内部 API","title":"PlantSimEngine.soft_dependencies","text":"soft_dependencies(d::DependencyGraph)\n\n返回一个带有依赖图 d 中进程的软依赖的 DependencyGraph。 软依赖是指模型中没有显式定义，但可以通过进程的输入输出推断出来的依赖关系。\n\n参数\n\nd::DependencyGraph: 硬依赖图。\n\n示例\n\nusing PlantSimEngine\n\n# 加载包中提供的示例模型：\nusing PlantSimEngine.Examples\n\n# 创建模型列表：\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    process4=Process4Model(),\n    process5=Process5Model(),\n    process6=Process6Model(),\n)\n\n# 创建硬依赖图：\nhard_dep = hard_dependencies(models.models, verbose=true)\n\n# 获取软依赖图：\nsoft_dep = soft_dependencies(hard_dep)\n\n\n\n\n\n","category":"function"},{"location":"API/API_private.html#PlantSimEngine.status_from_template-Tuple{Dict{Symbol}}","page":"内部 API","title":"PlantSimEngine.status_from_template","text":"status_from_template(d::Dict{Symbol,Any})\n\n从变量和值的模板字典创建一个status。如果值本身是RefValue或RefVector，则直接使用，否则会自动转为Ref。\n\n参数\n\nd::Dict{Symbol,Any}：变量和值的字典。\n\n返回\n\n一个Status。\n\n示例\n\njulia> using PlantSimEngine\n\njulia> a, b = PlantSimEngine.status_from_template(Dict(:a => 1.0, :b => 2.0));\n\njulia> a\n1.0\n\njulia> b\n2.0\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#PlantSimEngine.timestep_parallelizable-Tuple{T} where T","page":"内部 API","title":"PlantSimEngine.timestep_parallelizable","text":"timestep_parallelizable(x::T)\ntimestep_parallelizable(x::DependencyGraph)\n\n返回 true 表示模型 x 可以按时间步进行并行计算，否则返回 false。\n\n默认情况下，所有模型都返回 false。 如果您开发的模型能够按时间步并行，请为您的模型添加 ObjectDependencyTrait 的方法。\n\n本方法也可直接用于 DependencyGraph，若图中所有模型可并行化则返回 true，否则为 false。\n\n参见\n\nobject_parallelizable：判断模型能否按时间步并行。\nparallelizable：判断模型是否可并行化。\nTimeStepDependencyTrait：定义模型对其他时间步的依赖性。\n\n示例\n\n定义一个测试过程:\n\nusing PlantSimEngine\n\n# 定义一个测试过程:\n@process \"TestProcess\"\n\n定义一个时间步独立的模型:\n\nstruct MyModel <: AbstractTestprocessModel end\n\n# 重载时间步依赖 trait:\nPlantSimEngine.TimeStepDependencyTrait(::Type{MyModel}) = IsTimeStepIndependent()\n\n检查模型能否按对象并行:\n\ntimestep_parallelizable(MyModel()) # true\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#PlantSimEngine.transform_single_node_mapped_variables_as_self_node_output!-Tuple{Any}","page":"内部 API","title":"PlantSimEngine.transform_single_node_mapped_variables_as_self_node_output!","text":"transform_single_node_mapped_variables_as_self_node_output!(mapped_vars)\n\n查找作为SingleNodeMapping输入到其他尺度的变量，并以自身为源在源尺度声明为MappedVar。 这样有助于我们在创建模板status对象时以引用方式声明。\n\n这些节点表现为[:variable_name => \"Plant\"]的写法（注意\"Plant\"为标量）。\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#PlantSimEngine.traverse_dependency_graph!-Tuple{PlantSimEngine.HardDependencyNode, Function, Vector}","page":"内部 API","title":"PlantSimEngine.traverse_dependency_graph!","text":"traverse_dependency_graph(node::HardDependencyNode, f::Function, var::Vector)\n\n对 node 应用函数 f，然后遍历其子节点（硬依赖节点）。\n\n通过将节点的进程名和函数 f 的结果组成的对推入向量 var，以实现对 var 的累加。\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#PlantSimEngine.traverse_dependency_graph!-Tuple{PlantSimEngine.SoftDependencyNode, Function, Vector}","page":"内部 API","title":"PlantSimEngine.traverse_dependency_graph!","text":"traverse_dependency_graph(node::SoftDependencyNode, f::Function, var::Vector; visit_hard_dep=true)\n\n对 node 应用函数 f，遍历其硬依赖节点（当 visit_hard_dep=true 时），然后遍历其软依赖的子节点。\n\n通过将节点的进程名和函数 f 的结果组成的对推入向量 var，以实现对 var 的累加。\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#PlantSimEngine.traverse_dependency_graph-Tuple{PlantSimEngine.DependencyGraph, Function}","page":"内部 API","title":"PlantSimEngine.traverse_dependency_graph","text":"traverse_dependency_graph(graph::DependencyGraph, f::Function; visit_hard_dep=true)\ntraverse_dependency_graph(graph; visit_hard_dep=true)\n\n遍历依赖 graph，并对每个节点应用函数 f。如果未提供 f，则仅返回节点本身。\n\n首先遍历第一层软依赖节点，然后遍历它们的硬依赖节点（如果 visit_hard_dep=true），最后遍历软依赖节点的子节点。\n\n返回一个由节点与函数 f 结果组成的元组对的向量。\n\n示例\n\nusing PlantSimEngine\n\n# 包含示例进程和模型:\nusing PlantSimEngine.Examples;\n\nfunction f(node)\n    node.value\nend\n\nvars = (\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    process4=Process4Model(),\n    process5=Process5Model(),\n    process6=Process6Model(),\n    process7=Process7Model(),\n)\n\ngraph = dep(vars)\ntraverse_dependency_graph(graph, f)\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#PlantSimEngine.variables_multiscale","page":"内部 API","title":"PlantSimEngine.variables_multiscale","text":"variables_multiscale(node, organ, mapping, st=NamedTuple())\n\n获取 HardDependencyNode 的变量，考虑多尺度映射，也就是说， 如果变量被映射到了另一个尺度，则定义为 MappedVar。默认值 取自模型本身，如果用户未指定（st），且如果为节点的输入变量，则 用 UninitializedVar 标记。\n\n返回一个包含变量及其默认值的 NamedTuple。\n\n参数\n\nnode::HardDependencyNode：需要获取变量的节点。\norgan::String：器官类型，如 \"Leaf\"。\nvars_mapping::Dict{String,T}：模型的映射（详见下方）。\nst::NamedTuple：可选，包含变量默认值的 NamedTuple。\n\n详情\n\nvars_mapping 是一个以器官类型为 key、以字典为 value 的字典。 它由用户映射计算得到：\n\n\n\n\n\n","category":"function"},{"location":"API/API_private.html#PlantSimEngine.variables_outputs_from_other_scale-Tuple{Any}","page":"内部 API","title":"PlantSimEngine.variables_outputs_from_other_scale","text":"variables_outputs_from_other_scale(mapped_vars)\n\n对于mapped_vars中的每个器官，查找那些仅为其他尺度输出、而本尺度未计算的变量。 该函数用于mapped_variables。\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#PlantSimEngine.variables_typed-Tuple{T} where T<:AbstractModel","page":"内部 API","title":"PlantSimEngine.variables_typed","text":"variables_typed(model)\nvariables_typed(model, models...)\n\n返回模型所需变量（变量名及类型）的具名元组，或多个模型的变量类型联合。\n\n示例\n\nusing PlantSimEngine;\n\n# Load the dummy models given as example in the package:\nusing PlantSimEngine.Examples;\n\nPlantSimEngine.variables_typed(Process1Model(1.0))\n(var1 = Float64, var2 = Float64, var3 = Float64)\n\nPlantSimEngine.variables_typed(Process1Model(1.0), Process2Model())\n\n# output\n(var4 = Float64, var5 = Float64, var1 = Float64, var2 = Float64, var3 = Float64)\n\n参见\n\ninputs, outputs and variables\n\n\n\n\n\n","category":"method"},{"location":"API/API_private.html#PlantSimEngine.vars_not_init_-Union{Tuple{T}, Tuple{T, Any}} where T<:Status","page":"内部 API","title":"PlantSimEngine.vars_not_init_","text":"vars_not_init_(st<:Status, var_names)\n\n获取状态结构体中尚未正确初始化的变量。\n\n\n\n\n\n","category":"method"},{"location":"multiscale/multiscale_considerations.html#多尺度建模的注意事项","page":"多尺度建模考量","title":"多尺度建模的注意事项","text":"Pages = [\"multiscale_considerations.md\"]\nDepth = 3\n\n本页面简要介绍了多尺度模拟与以往单尺度模拟在细节上的不同之处。接下来的几页将通过示例展示这些微妙的差异。\n\n声明并运行多尺度模拟总体流程与单尺度模拟类似，但多尺度模拟有一些重要区别：\n\n模拟需要一个多尺度树图（Multi-scale Tree Graph, MTG）作为基础，并在该图上运行\n在运行时，模型被绑定到特定的尺度，只能访问与本地相关的信息\n同一个模型在每个时间步可能会被执行多次\nModelList 被一个更复杂的模型映射（model mapping）取代，用于将模型与它们作用的尺度关联起来\n\n模拟的依赖图依然会被自动计算并处理大多数耦合，因此一旦模型声明好，用户不需要再手动指定模型的执行顺序。不过你仍然需要声明硬依赖，且在多尺度情况下可能需要额外的硬依赖声明。\n\n多尺度模拟通常还需要添加额外的辅助模型，以便为某些主模型准备所需的变量。","category":"section"},{"location":"multiscale/multiscale_considerations.html#相关页面","page":"多尺度建模考量","title":"相关页面","text":"本多尺度章节的其他页面介绍了：\n\n如何将单尺度 ModelList 模拟直接转为多尺度模拟，并添加另一个尺度：将单尺度模拟转换为多尺度模拟\n展示跨尺度变量映射的更复杂的多尺度模拟示例：多尺度变量映射\n通过三步教程组合模型来模拟一个生长中的玩具植物：编写多尺度模拟\n如何处理变量导致环状依赖（循环依赖）的情况：避免循环依赖\n多尺度特有的耦合与细节注意事项：多尺度环境下的依赖关系处理","category":"section"},{"location":"multiscale/multiscale_considerations.html#多尺度树图","page":"多尺度建模考量","title":"多尺度树图","text":"功能-结构植物模型（Functional-Structural Plant Models, FSPM）通常用于模拟植物的生长过程。进行多尺度模拟时，默认的操作对象是一个类似于植物结构的对象，这正是用多尺度树图（Multi-scale Tree Graph, MTG）来表示的。\n\n因此，要运行多尺度模拟，就需要一个多尺度树图（MTG）对象（关于MTG的简要介绍请见多尺度树图小节）。即便你的模拟实际上并不真正影响MTG，也可以使用一个“虚拟”MTG，但该参数始终是多尺度run!函数的必要输入。\n\n本章所有多尺度模拟示例均采用了配套包MultiScaleTreeGraph.jl，因此强烈推荐你也基于此包运行自己的多尺度模拟。若想可视化多尺度树图，也推荐使用[PlantGeom](https://github.com/VEZY/PlantGeom.jl）。\n\nnote: Note\n多尺度树图的部分术语与PlantSimEngine自身的概念存在冲突，详细讨论见尺度 / 符号（symbol）术语的混淆。如果你对这些概念还不熟悉，请务必先阅读相关章节并加以区分。","category":"section"},{"location":"multiscale/multiscale_considerations.html#模型每个器官实例运行一次，而不是每个器官层级运行一次","page":"多尺度建模考量","title":"模型每个器官实例运行一次，而不是每个器官层级运行一次","text":"有些模型（如在单尺度模拟中见到的那些）面向整个植株，结构非常简单。\n\n更精细的模型则可以绑定到某一个具体的植物器官。\n\n例如，一个根据叶龄计算叶片面积的模型将在“叶片”这个尺度上运行，也就是说每片叶子每个仿真步都会调用一次。而若你要计算整株植物的总叶面积，只需每次仿真步在“植株”尺度上运行一次即可。\n\n这是单尺度与多尺度模拟之间的一个重大区别。在单尺度模拟中，每个模型每个仿真步只会执行一次。而在多尺度模拟中，如果一个植物某类器官有多个实例，比如有一百片叶子，那么任何在“叶片”尺度上的模型将默认在每个仿真步被调用一百次，除非通过其他模型（例如通过硬依赖配置）对其执行次数进行明确控制。","category":"section"},{"location":"multiscale/multiscale_considerations.html#映射关系（Mappings）","page":"多尺度建模考量","title":"映射关系（Mappings）","text":"当用户定义要使用哪些模型时，PlantSimEngine 无法预先判断各模型对应的尺度等级。这部分原因是多尺度树图（MTG）中的植物器官并没有统一命名，另外某些器官可能初始并未包含在 MTG 中，因此仅靠解析 MTG 无法推断出所有用到的尺度。\n\n因此，用户需要在模拟中明确指出每个模型对应于哪个物理尺度。\n\n多尺度映射指的是将模型与其运行的尺度关联，通过 Julia 的 Dict 实现。例如，将 \"Leaf\"（叶片）与在该尺度运行的 \"LeafSurfaceAreaModel\"（叶面积模型）相连。这种映射在多尺度模拟中相当于单尺度模拟下的 ModelList。\n\n多尺度模型可以与上文介绍的单尺度模型类似，或者，当需要使用其他尺度变量时，需要包裹为 MultiScaleModel 对象。许多模型实际上不固定于某一尺度，因此可在不同尺度或单尺度场景下复用。","category":"section"},{"location":"multiscale/multiscale_considerations.html#仿真是基于-MTG-进行的","page":"多尺度建模考量","title":"仿真是基于 MTG 进行的","text":"与单尺度模拟不同，单尺度模拟借助 Status 对象来存储每个变量的当前状态；多尺度模拟则以每个器官为基础。\n\n这意味着每个器官实例都会有自己的 Status，并带有当前尺度下的专属属性。\n\n这导致了模拟运行时的两个重要差别：\n\n首先，MTG 中不存在的尺度将不会被执行。举例来说，你的 MTG 若没有叶片节点，则所有运行于“叶片”尺度的模型都无法开始，直至创建一个叶片节点并添加到 MTG。否则没有对应的 MTG 节点可作用。唯一例外是“硬依赖”模型（hard dependency models），它们可以被其他已有尺度的节点模型直接调用，即使本尺度节点不存在。\n其次，模型默认只能访问自己的本地器官信息。在 run! 函数中，status 参数只包含该模型所属尺度的变量，除非通过 MultiScaleModel 包装将跨尺度变量显式映射进来。","category":"section"},{"location":"multiscale/multiscale_considerations.html#run!-函数的调用签名","page":"多尺度建模考量","title":"run! 函数的调用签名","text":"run! 函数与单尺度版本稍有不同。目前的基本结构（省略一些高级或已废弃的可选参数）如下：\n\nrun!(mtg, mapping, meteo, constants, extra; nsteps, tracked_outputs)\n\n不同于单尺度模型只需 ModelList，此处需要一个 MTG 和映射表。可选参数 meteo 与 constants 与单尺度用法一致。extra 参数已预留，不建议使用。新增了 nsteps 关键字参数，可以指定仿真的步数上限。","category":"section"},{"location":"multiscale/multiscale_considerations.html#多尺度输出数据结构","page":"多尺度建模考量","title":"多尺度输出数据结构","text":"多尺度仿真的输出结构，与映射类似，是一个以尺度名称为索引的 Julia Dict 字典。每个键对应一个特定尺度，其值为 Vector{NamedTuple}（命名元组数组），其中列表内为每个仿真步、当前尺度下每个节点需要输出的变量。此外，输出数据中还添加了仿真步（:timestep）和树图节点（:node）两个入口。\n\n这种字典结构使得多尺度仿真的输出相较于单尺度更为繁琐，不便直接查阅，但整体用法类似，同时该结构紧凑、可高效地转换为 Dict{String, DataFrame}，从而便于后续查询分析。\n\nnote: Note\n部分映射变量（例如从标量自动扩展为向量的变量）为节省内存和空间不会被写入输出，因为它们是冗余的。\n\n下面以玩具植物教程第 3 部分为例，展示 “Root”（根）尺度下某一变量的输出片段（详细内容见 修复植物模拟中的Bug）：\n\njulia> outs\n\nDict{String, Vector} with 5 entries:\n  \"Internode\" => @NamedTuple{timestep::Int64, node::Node{NodeMTG, Dict{Symbol, Any}}, carbon_root_creation_consumed::Float64, TT_cu::Float64, carbon_…\n  \"Root\"      => @NamedTuple{timestep::Int64, node::Node{NodeMTG, Dict{Symbol, Any}}, carbon_root_creation_consumed::Float64, water_absorbed::Float64…\n  \"Scene\"     => @NamedTuple{timestep::Int64, node::Node{NodeMTG, Dict{Symbol, Any}}, TT_cu::Float64, TT::Float64}[(timestep = 1, node = / 1: Scene…\n  \"Plant\"     => @NamedTuple{timestep::Int64, node::Node{NodeMTG, Dict{Symbol, Any}}, carbon_root_creation_consumed::Float64, carbon_stock::Float64, …\n  \"Leaf\"      => @NamedTuple{timestep::Int64, node::Node{NodeMTG, Dict{Symbol, Any}}, carbon_captured::Float64}[(timestep = 1, node = + 4: Leaf…\n\njulia> outs[\"Root\"]\n3257-element Vector{@NamedTuple{timestep::Int64, node::Node{NodeMTG, Dict{Symbol, Any}}, carbon_root_creation_consumed::Float64, water_absorbed::Float64, root_water_assimilation::Float64}}:\n (timestep = 1, node = + 9: Root\n└─ < 10: Root\n   └─ < 11: Root\n      └─ < 12: Root\n         └─ < 13: Root\n            └─ < 14: Root\n               └─ < 15: Root\n                  └─ < 16: Root\n                     └─ < 17: Root\n, carbon_root_creation_consumed = 50.0, water_absorbed = 0.5, root_water_assimilation = 1.0)\n ⋮\n\n与单尺度仿真相比，多尺度仿真下的输出更难直接索引查找，因为无法简单对应到每一个仿真步。\n\njulia> [Pair(outs[\"Root\"][i][:timestep], outs[\"Root\"][i][:carbon_root_creation_consumed]) for i in 1:length(outs[\"Root\"])]\n3257-element Vector{Pair{Int64, Float64}}:\n   1 => 50.0\n   1 => 50.0\n   2 => 50.0\n   2 => 50.0\n   2 => 50.0\n     ⋮\n 365 => 50.0\n 365 => 50.0\n 365 => 50.0\n 365 => 50.0\n 365 => 50.0\n 365 => 50.0\n 365 => 50.0\n 365 => 50.0\n 365 => 50.0\n\n将输出转换为 DataFrame 对象的字典，可以使此类查询变得更加容易书写。\n\nwarning: Warning\n当前，:node 条目只做了浅拷贝。不同尺度下每一时刻的 :node 实际都反映了节点的最终状态，因此在该时刻属性值可能与真实历史值不一致。若需精确记录每步的属性值，建议通过专门的模型输出来保存这些信息。 另外，目前还没有移除节点的方法，被认为已经修剪/死亡/流产的器官，其对应的节点依然会保留在输出数据结构里。\n\n多尺度模拟，尤其是具有数千个叶片、节间、根分枝、芽和果实的植物，可能会产生大量数据。与单尺度模拟类似，可以通过run!函数的 tracked_outputs 关键字参数，仅保留每个模拟步中需要跟踪的变量，其余则予以过滤。\n\n这些被跟踪的变量需要按尺度进行索引以避免歧义：\n\nouts = Dict(\n    \"Scene\" => (:TT, :TT_cu,),\n    \"Plant\" => (:aPPFD, :LAI),\n    \"Leaf\" => (:carbon_assimilation, :carbon_demand, :carbon_allocation, :TT),\n    \"Internode\" => (:carbon_allocation,),\n    \"Soil\" => (:soil_water_content,),\n)","category":"section"},{"location":"multiscale/multiscale_considerations.html#耦合关系与多尺度强依赖","page":"多尺度建模考量","title":"耦合关系与多尺度强依赖","text":"多尺度仿真带来了新的耦合类型：映射是处理不同尺度模型间变量引用的方法之一。某个模型也可能对另一个运作于不同尺度的模型存在强依赖。这些多尺度下的专有复杂性，会在多尺度环境下的依赖关系处理中进一步讨论。","category":"section"},{"location":"working_with_data/visualising_outputs.html#输出和数据可视化","page":"可视化输出与数据","title":"输出和数据可视化","text":"","category":"section"},{"location":"working_with_data/visualising_outputs.html#输出结构","page":"可视化输出与数据","title":"输出结构","text":"PlantSimEngine 的 run! 函数会在每个时间步返回所请求变量（通过 tracked_outputs 关键字参数设定，若未指定则返回所有变量）的状态。多尺度模拟还会指明这些状态变量关联的器官和 MTG 节点。\n\n以下是一个使用 CairoMakie（绘图用包）来绘制输出数据的示例。\n\n# ] add PlantSimEngine, DataFrames, CSV\nusing PlantSimEngine, PlantMeteo, DataFrames, CSV\n\n# 从示例文件夹中引入模型定义：\nusing PlantSimEngine.Examples\n\n# 导入示例气象数据：\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n\n# 定义耦合模型的列表：\nmodels = ModelList(\n    ToyLAIModel(),\n    Beer(0.6),\n    status=(TT_cu=cumsum(meteo_day[:, :TT]),),  # 将积温作为 ToyLAIModel 的输入，也可以通过其他模型完成\n)\n\n# 运行模拟：\nsim_outputs = run!(models, meteo_day)\n\n输出的数据默认以 TimeStepTable 结构显示。也可以通过可选的 tracked_outputs 关键字参数筛选需要保留的变量。","category":"section"},{"location":"working_with_data/visualising_outputs.html#输出结果的可视化","page":"可视化输出与数据","title":"输出结果的可视化","text":"使用 CairoMakie，可以绘制选定的变量：\n\nnote: Note\n你需要先通过 Pkg 模式向环境中添加 CairoMakie。\n\n# 绘制结果：\nusing CairoMakie\n\nfig = Figure(resolution=(800, 600))\nax = Axis(fig[1, 1], ylabel=\"LAI (m² m⁻²)\")\nlines!(ax, sim_outputs[:TT_cu], sim_outputs[:LAI], color=:mediumseagreen)\n\nax2 = Axis(fig[2, 1], xlabel=\"Cumulated growing degree days since sowing (°C)\", ylabel=\"aPPFD (mol m⁻² d⁻¹)\")\nlines!(ax2, sim_outputs[:TT_cu], sim_outputs[:aPPFD], color=:firebrick1)\n\nfig","category":"section"},{"location":"working_with_data/visualising_outputs.html#TimeStepTable-与-DataFrame","page":"可视化输出与数据","title":"TimeStepTable 与 DataFrame","text":"输出数据通常以 PlantMeteo.jl 中定义的 TimeStepTable 结构存储，这是一种高效的类似 DataFrame 的结构，每个时间步储存一个 Status。输出也可以为任何 Tables.jl 兼容结构，例如普通的 DataFrame。气象数据也常以 TimeStepTable 结构存储，但每个时间步是一个 Atmosphere。\n\n还有一种简单方法可以将结果转换为 DataFrame，这很容易，因为 TimeStepTable 实现了 Tables.jl 接口：\n\nusing DataFrames\nsim_outputs_df = PlantSimEngine.convert_outputs(sim_outputs, DataFrame)\nsim_outputs_df[[1, 2, 3, 363, 364, 365], :]\n\n也可以从特定变量创建 DataFrame：\n\ndf = DataFrame(aPPFD=sim_outputs[:aPPFD][1], LAI=sim_outputs.LAI[1], Ri_PAR_f=meteo.Ri_PAR_f[1])\n\n在 参数拟合 时，这种方法也非常有用。","category":"section"},{"location":"model_coupling/model_coupling_user.html#用户使用的模型耦合","page":"用户使用的模型耦合","title":"用户使用的模型耦合","text":"PlantSimEngine.jl 的设计目标是让模型耦合对模型开发者和用户都变得简单。例如，PlantBiophysics.jl 实现了 Fvcb 模型以模拟光合作用过程。该模型需要气孔导度过程来参与模拟，因此在其实现过程中会再次调用 run!。请注意，这里并不强制要求某一种特定的导度模型，而只要求有一个导度模型即可，这样用户可以根据实际需求选择用哪种模型来进行模拟，与所选用的光合模型无关。\n\n我们在 examples/dummy 提供了一个示例脚本，实现了七个虚拟过程。过程名称依次为 \"process1\", \"process2\"……，相应的模型实现为 Process1Model, Process2Model…… ","category":"section"},{"location":"model_coupling/model_coupling_user.html#硬耦合模型（Hard-Coupling）","page":"用户使用的模型耦合","title":"硬耦合模型（Hard Coupling）","text":"Process3Model 会调用 Process2Model，而 Process2Model 又会调用 Process1Model。在 PlantSimEngine 中，这种显式的调用关系称为“硬依赖（hard-dependency）”。\n\n余下的几个过程的模型分别为 Process4Model, Process5Model ……，它们在运行时并不会显式地调用其它模型，但它们的部分输出会被其他模型作为输入，这种被称为“软依赖（soft-dependency）”。\n\ntip: Tip\n模型的硬耦合通常用于某些模型之间存在迭代型计算、相互依赖的情况。本示例其实非常简单，这里并不需要这样的耦合，模型完全可以按顺序依次调用。对于更具代表性的例子，参见 PlantBiophysics.jl 中的 Monteith 能量平衡计算，它与光合模型存在硬耦合。\n\n回到我们的示例，使用 Process3Model 时需要有 \"process2\" 模型，这里我们只有一个实现：Process2Model。后者同样要求有 \"process1\" 模型，而当前实现中也仅有 Process1Model。\n\n让我们用一下 Examples 子模块看看效果：\n\n# 导入在 `Examples` 子模块中定义的示例模型：\nusing PlantSimEngine.Examples\n\ntip: Tip\n使用 subtypes(x) 可以了解某个过程可用的模型类型。例如，对于 \"process1\"，可以使用 subtypes(AbstractProcess1Model) 查询。\n\n下面展示如何进行模型耦合：\n\nm = ModelList(Process1Model(2.0), Process2Model(), Process3Model())\nnothing # hide\n\n可以看到，只有第一个模型有参数。通常可以通过查看结构体的帮助信息（例如 ?Process1Model）来了解参数情况，或者也可以通过 fieldnames(Process1Model) 查看结构体的字段名称。\n\n注意，用户只需要声明要用的模型，而不需要声明模型之间的耦合方式，因为 PlantSimEngine.jl 会自动处理这些耦合关系。\n\n在上面的例子中，系统会返回一些警告，提示需要初始化一些变量：var1 和 var2。PlantSimEngine.jl 会根据所有模型的输入输出变量（包括硬依赖和软依赖）自动推断需要初始化哪些变量。\n\n例如，Process1Model 需要以下变量作为输入：\n\ninputs(Process1Model(2.0))\n\nProcess2Model 需要以下变量作为输入：\n\ninputs(Process2Model())\n\n我们可以看到，var1 在这两个模型中都需要作为输入变量，同时我们也注意到 var3 是 Process2Model 的输出变量：\n\noutputs(Process2Model())\n\n所以考虑到这两个模型，我们只需要初始化 var1 和 var2，因为 var3 会被模型计算得出。这也是我们推荐使用 to_initialize 而不是 inputs 的原因，to_initialize 只返回真正需要初始化的变量。因为某些输入变量在多个模型中重复，同时有的输入变量实际上是由其它模型计算得出的（即它们是其他模型的输出）：\n\nm = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    variables_check=false # 只是为了不打印出警告信息\n)\n\nto_initialize(m)\n\n最直接初始化模型列表的方法，就是在实例化时通过 status 关键字参数传递初始变量：\n\nm = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    status = (var1=15.0, var2=0.3)\n)\nnothing # hide\n\n我们的组件模型结构现在已经被完全参数化，并且为模拟做好了初始化！\n\n让我们来进行一次模拟：\n\nusing PlantMeteo\nmeteo = Atmosphere(T = 22.0, Wind = 0.8333, P = 101.325, Rh = 0.4490995)\n\nrun!(m, meteo)\n\nm[:var5]","category":"section"},{"location":"model_coupling/model_coupling_user.html#软耦合模型","page":"用户使用的模型耦合","title":"软耦合模型","text":"接下来的所有模型（Process4Model 到 Process7Model）在运行时不会显式调用其他模型，但部分模型的输出会作为其他模型的输入。在 PlantSimEngine 中，这被称为软依赖（soft-dependency）。\n\n让我们创建一个包含这些软耦合模型的新模型列表：\n\nm = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    Process4Model(),\n    Process5Model(),\n    Process6Model(),\n    Process7Model(),\n)\nnothing # hide\n\n在这个模型列表中，我们只需要初始化 var0，它是 Process4Model 和 Process7Model 的输入：\n\nto_initialize(m)\n\n我们可以如下进行初始化：\n\nm = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    Process4Model(),\n    Process5Model(),\n    Process6Model(),\n    Process7Model(),\n    status = (var0=15.0,)\n)\nnothing # hide\n\n让我们来进行一次模拟：\n\nusing PlantMeteo\nmeteo = Atmosphere(T = 22.0, Wind = 0.8333, P = 101.325, Rh = 0.4490995)\n\nrun!(m, meteo)\n\nstatus(m)","category":"section"},{"location":"model_coupling/model_coupling_user.html#仿真执行顺序","page":"用户使用的模型耦合","title":"仿真执行顺序","text":"当调用 run! 时，模型会根据它们之间的强依赖和软依赖关系，自动建立依赖图并依照以下规则顺序执行：\n\n首先运行独立的模型。一个模型是独立的，如果它可以单独运行，或只依赖初始值，即没有依赖其他模型。\n按其子节点依赖关系执行：\n总是优先运行强依赖。内部的强依赖关系图会整体被视为一个软依赖（即作为一个整体去处理软依赖）。\n然后依次运行软依赖。如果某个软依赖有多个父节点（即它所需的输入由多个模型计算），只有在所有父节点都已经被执行过后才会运行该节点。实际上，当访问一个节点时，如果它有某个父节点还未执行，则会暂停遍历该分支，直到从最后一个被运行的父节点分支重新访问到该节点时才执行。","category":"section"},{"location":"planned_features.html#路线图","page":"规划功能","title":"路线图","text":"","category":"section"},{"location":"planned_features.html#计划中的主要功能","page":"规划功能","title":"计划中的主要功能","text":"","category":"section"},{"location":"planned_features.html#可变时间步长","page":"规划功能","title":"可变时间步长","text":"目前，所有模型都需要使用相同的时间步长。然而，植物内部的一些生理现象往往以小时为单位进行，其他则更慢。而气象数据通常是按天提供的。根据模型启用不同的时间步长已在开发计划中，并被列为下一个重要的里程碑。","category":"section"},{"location":"planned_features.html#多植株/多物种模拟","page":"规划功能","title":"多植株/多物种模拟","text":"PlantSimEngine 的一个目标是能够模拟包含多个植株（可能属于不同物种）数据的复杂场景，以应用于农林复合系统等场景。\n\n当前的实现还不支持灵活地声明多种植物，或让多个植株基于一部分相同，另一部分不同的模型或参数来进行建模。","category":"section"},{"location":"planned_features.html#次要功能","page":"规划功能","title":"次要功能","text":"实现一个 trait 或预处理检查，以判断是否需要气象数据，并确保需要时已正确提供到模拟中\n更好的依赖图可视化和信息输出","category":"section"},{"location":"planned_features.html#次要改进与易用性提升","page":"规划功能","title":"次要改进与易用性提升","text":"改进并统一 Mapping API，支持多尺度依赖声明\n改善用户报错信息\n添加更多示例\n优化依赖关系图的遍历功能\n确保循环依赖检查与 PreviousTimestep 在 ModelLists 中生效","category":"section"},{"location":"planned_features.html#测试方面的改进","page":"规划功能","title":"测试方面的改进","text":"更好地追踪内存使用和类型稳定性\n完善 CI / 下游测试\n实现状态机检查器，用于验证输出的不变量\n实现图结构模糊测试，以改进边界情况测试","category":"section"},{"location":"planned_features.html#可能的功能（当前优先级较低）","page":"规划功能","title":"可能的功能（当前优先级较低）","text":"支持迭代式构建与验证映射和 ModelList 的 API\n模型的构建步骤，例如：提供一个函数，将映射或 ModelList 写入 Julia 脚本，实现验证、提升可读性，甚至也许能提升性能（不再需要遍历依赖图）\n并行化改进\n在单一尺度下重新引入多对象并行计算","category":"section"},{"location":"planned_features.html#其他小点","page":"规划功能","title":"其他小点","text":"浮点数累计误差的示例或解决方案\n更多关于拟合/类型转换/误差传播的示例\nMTG 一些新特性 #106\n其他小的 bug\nrun! 函数的展开","category":"section"},{"location":"planned_features.html#其它","page":"规划功能","title":"其它","text":"复现其他 FSPM 吗？\n扩散模型示例？\n\n完整问题列表可见 这里","category":"section"},{"location":"multiscale/multiscale_example_1.html#编写多尺度模拟","page":"简单植株模拟","title":"编写多尺度模拟","text":"本小节分为三部分，逐步带你从零构建一个多尺度模拟。这主要演示你在开发和逐步调整一个功能-结构植物模型（FSPM）过程中会经历的迭代流程，而前面的多尺度示例更多侧重于API语法的介绍。\n\n你可以在示例文件夹下的 ToyMultiScalePlantModel 子目录找到本节第一部分的玩具模拟完整脚本。\n\nPages = [\"multiscale_example_1.md\"]\nDepth = 3","category":"section"},{"location":"multiscale/multiscale_example_1.html#声明","page":"简单植株模拟","title":"声明","text":"这里实现的“植物”以及自定义模型并没有真正的生物学意义，仅为临时拼凑（因此大多也不是 examples 文件夹内的标准独立模型）。同样地，许多参数都纯属虚构，并不对应真实的文献或实验数据。\n\n这里的重点在于展示 PlantSimEngine 的多尺度特性和模型的组织方式，而不是准确性、现实性或性能。","category":"section"},{"location":"multiscale/multiscale_example_1.html#初始化设置","page":"简单植株模拟","title":"初始化设置","text":"像往常一样，我们需要先在 Julia 环境中添加并使用几个包：\n\nusing PlantSimEngine\nusing PlantSimEngine.Examples # 导入 ToyDegreeDaysCumulModel 示例模型\nusing PlantMeteo\nusing MultiScaleTreeGraph # 多尺度\nusing CSV, DataFrames # 导入示例气象数据","category":"section"},{"location":"multiscale/multiscale_example_1.html#一个基础的生长植物模型","page":"简单植株模拟","title":"一个基础的生长植物模型","text":"要模拟一个简单的“生长”过程，至少需要：\n\n一个多尺度树图（MTG）来表示植物本体\n一种向植物中添加新器官的方法\n某种时间推进机制，让生长能够跨多个时间步展开\n\n我们先设定一个“叶片”的概念，用以吸收生长器官所需的（碳）资源；器官的产生则发生在“节间”层级，这样可以演示不同类型器官的行为差异。\n\n我们将假设节间利用的是来自公共碳池的碳。我们还将利用积温作为生长延迟因子。\n\n总结下来，模型包括如下内容：\n\n一个包含生长中节间和叶片的 MTG\n不同叶片分别吸收碳，但都汇总到一个公共池\n节间从碳池中获取资源来制造新器官，但过程受到积温的限制\n\n这种建模方式可以按照多个尺度和模型来实现：\n\n场景（Scene）尺度：用于累积温度积算时间。 examples 文件夹 中的 ToyDegreeDaysCumulModel 可根据温度数据计算积温\n植株（Plant）尺度：定义碳资源池\n节间（Internode）尺度：从碳池中抽取碳，产生新器官\n叶片（Leaf）尺度：负责碳捕获\n\n此外，我们还人为地引入一个限制：如果总叶面积超过某一阈值，则不再生成新器官。\n\n仿真的模型与比例映射大致如下所示（实际会更复杂）：\n\nmapping = Dict(\n\"Scene\" => ToyDegreeDaysCumulModel(),\n\"Plant\" => ToyStockComputationModel(),\n\"Internode\" => ToyCustomInternodeEmergence(),\n\"Leaf\" => ToyLeafCarbonCaptureModel(),\n)\n\n其中，部分模型需要获取别的尺度上的变量信息，因此需要转化为 MultiScaleModels。","category":"section"},{"location":"multiscale/multiscale_example_1.html#实现","page":"简单植株模拟","title":"实现","text":"","category":"section"},{"location":"multiscale/multiscale_example_1.html#碳捕获","page":"简单植株模拟","title":"碳捕获","text":"我们先从最简单的模型开始。我们的“假”叶片在每个时间步都持续固定地捕获一定量的碳。该模型不需要任何输入或参数。\n\nPlantSimEngine.@process \"leaf_carbon_capture\" verbose = false\n\nstruct ToyLeafCarbonCaptureModel<: AbstractLeaf_Carbon_CaptureModel end\n\nfunction PlantSimEngine.inputs_(::ToyLeafCarbonCaptureModel)\n    NamedTuple() # 无需输入\nend\n\nfunction PlantSimEngine.outputs_(::ToyLeafCarbonCaptureModel)\n    (carbon_captured=0.0,)\nend\n\nfunction PlantSimEngine.run!(::ToyLeafCarbonCaptureModel, models, status, meteo, constants, extra)   \n    status.carbon_captured = 40\nend","category":"section"},{"location":"multiscale/multiscale_example_1.html#资源储存","page":"简单植株模拟","title":"资源储存","text":"用于存储整个植株资源的模型需要两个输入：叶片捕获的碳量，以及用于新器官形成所消耗的碳量。该模型输出当前的碳库量。\n\nPlantSimEngine.@process \"resource_stock_computation\" verbose = false\n\nstruct ToyStockComputationModel <: AbstractResource_Stock_ComputationModel\nend\n\nPlantSimEngine.inputs_(::ToyStockComputationModel) = \n(carbon_captured=0.0,carbon_organ_creation_consumed=0.0)\n\nPlantSimEngine.outputs_(::ToyStockComputationModel) = (carbon_stock=-Inf,)\n\nfunction PlantSimEngine.run!(m::ToyStockComputationModel, models, status, meteo, constants=nothing, extra=nothing)\n    status.carbon_stock += sum(status.carbon_captured) - sum(status.carbon_organ_creation_consumed)\nend","category":"section"},{"location":"multiscale/multiscale_example_1.html#器官创建","page":"简单植株模拟","title":"器官创建","text":"本模型为 ToyInternodeEmergence 模型的改进版本，可以在 examples 文件夹中找到。一个节间会生成两个叶片和一个新的节间。\n\n我们首先定义一个辅助函数，用于遍历多尺度树图，并返回叶片的数量：\n\nfunction get_n_leaves(node::MultiScaleTreeGraph.Node)\n    root = MultiScaleTreeGraph.get_root(node)\n    nleaves = length(MultiScaleTreeGraph.traverse(root, x->1, symbol=\"Leaf\"))\n    return nleaves\nend\n\n现在我们已经有了这些，让我们为模型定义几个参数。需要以下参数：\n\n一个积温出苗阈值\n器官形成的碳消耗成本\n\n我们还将添加另外几个参数，这些参数可以放在其他位置：\n\n叶片的表面积（无变化，无生长阶段）\n叶片最大表面积，超过此值器官形成停止\n\nPlantSimEngine.@process \"organ_emergence\" verbose = false\n\nstruct ToyCustomInternodeEmergence{T} <: AbstractOrgan_EmergenceModel\n    TT_emergence::T\n    carbon_internode_creation_cost::T\n    leaf_surface_area::T\n    leaves_max_surface_area::T\nend\n\nnote: Note\n这里我们采用了参数化类型而非直观的 Float64，以获得更高的灵活性。详情请参见参数化类型。\n\n并为它们设置一些默认值：\n\nToyCustomInternodeEmergence(;TT_emergence=300.0, carbon_internode_creation_cost=200.0, leaf_surface_area=3.0, leaves_max_surface_area=100.0) = ToyCustomInternodeEmergence(TT_emergence, carbon_internode_creation_cost, leaf_surface_area, leaves_max_surface_area)\n\n节间模型需要积温和可用的碳，并输出碳的消耗量，以及最近一次器官发生时的积温（当同一节间可以多次产生新器官时很有用，但本例中不会发生）。\n\nPlantSimEngine.inputs_(m::ToyCustomInternodeEmergence) = (TT_cu=0.0, carbon_stock=0.0)\nPlantSimEngine.outputs_(m::ToyCustomInternodeEmergence) = (TT_cu_emergence=0.0, carbon_organ_creation_consumed=0.0)\n\n最后，run! 函数会检查是否满足创建新器官的条件：\n\n积温超过阈值\n所有叶片的总表面积不超过限定阈值\n碳储量充足\n该节间还没有创建新器官\n\n满足条件时会更新 MTG。\n\nfunction PlantSimEngine.run!(m::ToyCustomInternodeEmergence, models, status, meteo, constants=nothing, sim_object=nothing)\n\n    leaves_surface_area = m.leaf_surface_area * get_n_leaves(status.node)\n    status.carbon_organ_creation_consumed = 0.0\n\n    if leaves_surface_area > m.leaves_max_surface_area\n        return nothing\n    end\n    \n    # if not enough carbon, no organ creation\n    if status.carbon_stock < m.carbon_internode_creation_cost\n        return nothing\n    end\n  \n    if length(MultiScaleTreeGraph.children(status.node)) == 2 && \n        status.TT_cu - status.TT_cu_emergence >= m.TT_emergence            \n        status_new_internode = add_organ!(status.node, sim_object, \"<\", \"Internode\", 2, index=1)\n        add_organ!(status_new_internode.node, sim_object, \"+\", \"Leaf\", 2, index=1)\n        add_organ!(status_new_internode.node, sim_object, \"+\", \"Leaf\", 2, index=1) \n\n        status_new_internode.TT_cu_emergence = m.TT_emergence - status.TT_cu\n        status.carbon_organ_creation_consumed = m.carbon_internode_creation_cost\n    end\n\n    return nothing\nend","category":"section"},{"location":"multiscale/multiscale_example_1.html#更新后的映射","page":"简单植株模拟","title":"更新后的映射","text":"现在我们可以为本次模拟定义最终的映射。\n\n碳捕获和积温模型不需要从早期版本进行更改。 \"节间\"尺度的器官创建模型需要来自\"植株\"尺度的碳库存，以及来自\"场景\"尺度的积温。 \"植株\"尺度的资源存储模型需要每个叶片捕获的碳，以及每个在此时间步创建了新器官的节间所消耗的碳。这需要对向量变量进行映射：\n\n mapped_variables=[\n            :carbon_captured=>[\"Leaf\"],\n            :carbon_organ_creation_consumed=>[\"Internode\"]\n        ],\n\n这与只映射单变量（如碳存量）有所不同。例如：\n\n mapped_variables=[:TT_cu => \"Scene\",\n            PreviousTimeStep(:carbon_stock)=>\"Plant\"],\n\n当然，某些变量也需要在 status 结构体中初始化：\n\nmapping = Dict(\n    \"Scene\" => ToyDegreeDaysCumulModel(),\n    \"Plant\" => (\n        MultiScaleModel(\n            model=ToyStockComputationModel(),          \n            mapped_variables=[\n                :carbon_captured=>[\"Leaf\"],\n                :carbon_organ_creation_consumed=>[\"Internode\"]\n            ],\n        ),\n        Status(carbon_stock = 0.0)\n    ),\n    \"Internode\" => (        \n        MultiScaleModel(\n            model=ToyCustomInternodeEmergence(), # TT_emergence=20.0\n            mapped_variables=[\n                :TT_cu => \"Scene\",\n                PreviousTimeStep(:carbon_stock)=>\"Plant\"\n            ],\n        ),        \n        Status(carbon_organ_creation_consumed=0.0),\n    ),\n    \"Leaf\" => ToyLeafCarbonCaptureModel(),\n)\n\nnote: Note\n以上代码片段（以及完整脚本）展示了经过完整初始化的最终映射结构。但在开发过程中，建议多使用辅助函数to_initialize并关注 PlantSimEngine 的用户报错信息，以便及时发现和修正未初始化的变量。","category":"section"},{"location":"multiscale/multiscale_example_1.html#运行模拟","page":"简单植株模拟","title":"运行模拟","text":"我们只需要一个 MTG，以及一些气象数据，就可以开始模拟了。让我们先创建一个简单的 MTG：\n\n mtg = MultiScaleTreeGraph.Node(MultiScaleTreeGraph.NodeMTG(\"/\", \"Scene\", 1, 0))   \n    plant = MultiScaleTreeGraph.Node(mtg, MultiScaleTreeGraph.NodeMTG(\"+\", \"Plant\", 1, 1))\n    \n    internode1 = MultiScaleTreeGraph.Node(plant, MultiScaleTreeGraph.NodeMTG(\"/\", \"Internode\", 1, 2))\n    MultiScaleTreeGraph.Node(internode1, MultiScaleTreeGraph.NodeMTG(\"+\", \"Leaf\", 1, 2))\n    MultiScaleTreeGraph.Node(internode1, MultiScaleTreeGraph.NodeMTG(\"+\", \"Leaf\", 1, 2))\n\n    internode2 = MultiScaleTreeGraph.Node(internode1, MultiScaleTreeGraph.NodeMTG(\"<\", \"Internode\", 1, 2))\n    MultiScaleTreeGraph.Node(internode2, MultiScaleTreeGraph.NodeMTG(\"+\", \"Leaf\", 1, 2))\n    MultiScaleTreeGraph.Node(internode2, MultiScaleTreeGraph.NodeMTG(\"+\", \"Leaf\", 1, 2))\n\n导入气象数据：\n\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\nnothing # hide\n\n就可以开始模拟啦！\n\nouts = run!(mtg, mapping, meteo_day)\n\n如果你在模拟之后查询或显示 MTG，你会发现它扩展并生长出了多个节间和叶片：\n\nmtg\n# get_n_leaves(mtg)\n\n就是这样！可以随意调整参数，看看什么时候模拟会崩溃，从而更好地理解模拟过程。\n\n当然，这只是一个非常粗糙且不现实的模拟，存在很多有问题的假设和参数。但通过同样的方法，也可以实现显著更复杂的建模：XPalm 就是在九个尺度上，利用几十个模型运行的。\n\n本教程为三部分内容，后续章节请参考扩展多尺度模拟。","category":"section"},{"location":"step_by_step/detailed_first_example.html#detailed-walkthrough-of-a-simple-simulation","page":"详细的第一个模拟","title":"简单模拟的详细演示","text":"本页面将带您深入了解一个基础模拟案例，主要面向编程经验较少的用户，目的是结合先前介绍的概念，展示在具体情境下进行模拟所需的各项要素。\n\n在本页面下方的示例模拟小节可以找到一个经过简化的可运行脚本，其它小节详细说明了设置、辅助函数和如何查询输出结果。\n\n如果您只是想复制粘贴范例并做些尝试，可以直接前往快速示例页面查阅多个案例。\n\nPages = [\"detailed_first_example.md\"]\nDepth = 3","category":"section"},{"location":"step_by_step/detailed_first_example.html#环境准备","page":"详细的第一个模拟","title":"环境准备","text":"在本手册涉及的所有脚本中，您都需要一个已安装 PlantSimEngine 的正常 Julia 环境，通常还需添加若干配套包。具体安装与运行方法详见PlantSimEngine 的安装与运行页面。","category":"section"},{"location":"step_by_step/detailed_first_example.html#基本概念","page":"详细的第一个模拟","title":"基本概念","text":"","category":"section"},{"location":"step_by_step/detailed_first_example.html#过程-(Processes)","page":"详细的第一个模拟","title":"过程 (Processes)","text":"在本包中，“过程”定义了某种生物或物理现象。可以将其类比为系统中发生的各种活动，如：光截获、光合作用、水分交换、碳与能量流、生长、产量，乃至太阳能电池板发电等。\n\n“声明”一个过程意味着我们对其做出定义，并实现对应的模型用于模拟。在本例中，我们使用了已定义好并实现了对应模型的过程。","category":"section"},{"location":"step_by_step/detailed_first_example.html#模型（ModelList）","page":"详细的第一个模拟","title":"模型（ModelList）","text":"每个过程都需要通过特定的实现方式——即模型（model）来进行模拟。每个模型都通过一个结构体来实现，并在结构体中列出了该模型的参数。例如，PlantBiophysics 包提供了Beer结构体，用于实现描述光衰减的 Beer-Lambert 定律。在本包中，light_interception（光截获过程）及其所用的 Beer 模型，也作为示例脚本包含在examples/Beer.jl文件中。\n\n模型可包含如下内容：\n\n参数（Parameters）\n气象信息（Meteorological information）\n变量（Variables）\n常量（Constants）\n额外信息（Extras）\n\n参数 是模型内部用于计算输出的常量，仅在该模型内部使用。   气象信息 由用户提供，作为模型输入，定义每个时间步的环境条件，PlantSimEngine.jl 会自动为每个时间步应用这些信息。   变量 包含模型所用或计算得到的数据，可选地在模拟前初始化。变量可以在多个模型中流转——由一个模型计算，再被另一个模型使用；也可以作为全局输出或在模拟开始时由用户指定。   常量 是常量参数，通常为各模型公用，如气体常数等。   额外信息（extras） 可作为模型备用信息或者做为内部数据的占位。\n\n用户需声明用于模拟的一组模型，以及每个模型所需的参数和应初始化的变量。其操作结构为ModelList。\n\n例如，下面通过 ModelList 结构体声明一个仅含 Beer-Lambert 光截获模型的模型组。该模型由 Beer 结构实现，并且只含一个参数——消光系数（k）。\n\n导入主包：\n\nusing PlantSimEngine\n\n再导入Examples子模块中定义的示例（如 light_interception 和 Beer）：\n\nusing PlantSimEngine.Examples\n\n然后，使用 Beer 模型来声明一个 ModelList ：\n\nm = ModelList(Beer(0.5))\n\n发生了什么？我们把 Beer 模型的实例提供给了 ModelList，用以模拟光截获过程。","category":"section"},{"location":"step_by_step/detailed_first_example.html#参数（Parameters）","page":"详细的第一个模拟","title":"参数（Parameters）","text":"参数（Parameter）是在模型内部用于模拟计算且在模拟过程中保持不变的数值。例如，Beer-Lambert 模型使用消光系数（k）来计算光的衰减。具体来说，Beer-Lambert 模型实现中的 Beer 结构体只有一个字段：k。我们可以通过对模型结构体使用 fieldnames 来查看这一点：\n\nfieldnames(Beer)","category":"section"},{"location":"step_by_step/detailed_first_example.html#变量（Variables，输入与输出）","page":"详细的第一个模拟","title":"变量（Variables，输入与输出）","text":"变量可作为模型的输入或输出（即被模型计算得到）。变量及其数值都存储在ModelList结构体中，可以自动或手动初始化。\n\n例如，Beer 模型需要叶面积指数 (LAI, m²/m²) 作为输入。\n\n可使用 inputs 查看模型的输入变量：\n\ninputs(Beer(0.5))\n\n用 outputs 可以查看模型的输出变量：\n\noutputs(Beer(0.5))\n\nModelList 会在模拟运行期间维护每个变量的当前状态，保存在字段 status 中。我们可以利用 status 函数查看，例如本例中可见两个变量：LAI 和 aPPFD。前者为输入，后者为输出。\n\nm = ModelList(Beer(0.5))\nkeys(status(m))\n\n要确定哪些变量需要初始化，可用to_initialize：\n\nm = ModelList(Beer(0.5))\nto_initialize(m)\n\n这些变量尚未初始化（因此会出现警告）：\n\n(m[:LAI], m[:aPPFD])\n\n未初始化变量的初值由模型代码中的 inputs 或 outputs 方法赋予，通常等于类型的最小值，比如 Float64 类型的 -Inf。\n\ntip: Tip\n推荐使用to_initialize 而不是 inputs 检查应初始化哪些变量。前者只返回需要且未初始化的变量，后者则返回模型需要的所有输入变量。在多模型耦合场景下，有些输入实际可由其它模型计算而无需初始化。\n\n初始化变量时，可在声明 ModelList 时直接赋值：\n\nm = ModelList(Beer(0.5), status = (LAI = 2.0,))\n\n也可在实例化后用 init_status! 赋值：\n\nm = ModelList(Beer(0.5))\n\ninit_status!(m, LAI = 2.0)\n\n可调用is_initialized 检查组件是否正确初始化：\n\nis_initialized(m)\n\n有些变量作为输入参数，但实际上由其它模型输出。当多个模型耦合时，to_initialize 只会请求未被其他模型计算的变量。","category":"section"},{"location":"step_by_step/detailed_first_example.html#气象驱动（Climate-forcing）","page":"详细的第一个模拟","title":"气象驱动（Climate forcing）","text":"进行模拟时一般需要测量对象或组件周围的气象条件。\n\n强烈推荐配合使用 PlantMeteo.jl 包，其内置高效的数据结构与预处理功能，可便捷管理气象数据。该包的基本气象结构体叫 Atmosphere，表示稳态（平衡）大气条件。若有多个时间步数据，可用 TimeStepTable。\n\n声明 Atmosphere 时必须指定如下变量：T（气温℃）、Rh（相对湿度0-1）、Wind（风速m/s）。在本例中还需给出光合有效辐射通量（Ri_PAR_f, W/m²）。示例如下：\n\nusing PlantMeteo\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, Rh = 0.65, Ri_PAR_f = 500.0)\n\n上述例子中，meteo 就是可用于模拟的单一气象时段数据。\n\n更多细节可查看包文档。","category":"section"},{"location":"step_by_step/detailed_first_example.html#模拟","page":"详细的第一个模拟","title":"模拟","text":"","category":"section"},{"location":"step_by_step/detailed_first_example.html#过程模拟","page":"详细的第一个模拟","title":"过程模拟","text":"运行模拟时，可在 ModelList 上调用 run! 方法。如需输入多步气象数据，也可将其作为可选参数传入。\n\n调用方式如下：\n\nrun!(model_list, meteo)\n\n第一个参数是模型组（见ModelList），第二个参数是微气候条件。\n\n调用前应确保ModelList 已为该过程完成初始化，可回顾前述输入与输出部分。","category":"section"},{"location":"step_by_step/detailed_first_example.html#示例模拟","page":"详细的第一个模拟","title":"示例模拟","text":"例如，下面模拟单片叶片的“光截获”过程：\n\nusing PlantSimEngine, PlantMeteo\n\n# 导入 `Examples` 子模块中的示例\nusing PlantSimEngine.Examples\n\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, Rh = 0.65, Ri_PAR_f = 500.0)\n\nleaf = ModelList(Beer(0.5), status = (LAI = 2.0,))\n\noutputs_example = run!(leaf, meteo)\n\noutputs_example[:aPPFD]","category":"section"},{"location":"step_by_step/detailed_first_example.html#输出","page":"详细的第一个模拟","title":"输出","text":"ModelList 的status 字段，用于在模拟前初始化变量，也能实时追踪模拟过程中及最后的变量取值。调用 status 可获得最终时间步的输出结果。\n\n而 run! 方法返回的是完整的模拟所有步长的输出数据。通常输出采用 PlantMeteo.jl 的 TimeStepTable 结构（类似 DataFrame，但每行为一个 Status），当然也支持 Tables.jl 的其它结构如常规 DataFrame。气象数据同理，默认也支持 TimeStepTable，每行为一个 Atmosphere。\n\n本例只用了单一气象时段，因此 run! 返回值和模型组的 status 字段内容相同。\n\n现在查看前面叶片模拟的输出结构：\n\n可用索引读取具体变量的值，比如截获的光合有效光：\n\noutputs_example[:aPPFD]\n\n也可以用点语法读取：\n\noutputs_example.aPPFD\n\n您可以将输出打印、转为其它格式或用 Julia 其它绘图库直接可视化。具体方法请参考输出和数据可视化页面。\n\n另一种便捷输出方法是将结果转为 DataFrame，因为 TimeStepTable 实现了 Tables.jl 接口，这非常容易：\n\nusing DataFrames\nconvert_outputs(outputs_example, DataFrame)","category":"section"},{"location":"step_by_step/detailed_first_example.html#模型耦合","page":"详细的第一个模拟","title":"模型耦合","text":"模型既可单独工作，也可联合运行。例如气孔导度模型通常与光合模型耦合使用（由光合模型调用）。\n\nPlantSimEngine.jl 特别设计以方便建模与用户无痛实现模型耦合。更多详细说明请参阅标准模型耦合、耦合更复杂的模型，以及多尺度环境下的依赖关系处理。","category":"section"},{"location":"step_by_step/simple_model_coupling.html#标准模型耦合","page":"模型耦合","title":"标准模型耦合","text":"","category":"section"},{"location":"step_by_step/simple_model_coupling.html#配置你的环境","page":"模型耦合","title":"配置你的环境","text":"同样，请确保你已经拥有一个可用的 Julia 环境，并添加了 PlantSimEngine 以及其他推荐的配套包。详细的安装和运行方法详见PlantSimEngine 的安装与运行一节。","category":"section"},{"location":"step_by_step/simple_model_coupling.html#ModelList","page":"模型耦合","title":"ModelList","text":"ModelList 是一个容器，可以包含多个模型、它们的参数值及相关变量的状态。\n\n在前面的例子中，ModelList 只包含了一个模型，其输入变量在 ModelList 的 status 关键字参数中初始化。\n\n示例模型均取自 examples 文件夹下的示例脚本。\n\n下面是一个带有光截获模型的 ModelList 声明，该模型需要输入叶面积指数（LAI）： \n\nmodellist_coupling_part_1 = ModelList(Beer(0.5), status = (LAI = 2.0,))\n\n下面是第二个 ModelList，包含一个叶面积指数（LAI）模型，并以一个例子形式提供了积温（TTcu）作为输入（TTcu 通常由气象数据计算得来）：\n\nmodellist_coupling_part_2 = ModelList(\n    ToyLAIModel(),\n    status=(TT_cu=1.0:2000.0,), # 将积温作为输入传递给模型\n)","category":"section"},{"location":"step_by_step/simple_model_coupling.html#模型耦合","page":"模型耦合","title":"模型耦合","text":"假设我们希望 ToyLAIModel 为光截获模型计算 LAI 值。\n\n我们可以通过将这两个模型放在同一个 ModelList 容器中实现它们的耦合。此时，LAI 变量会作为 ToyLAIModel 的输出并直接供 Beer 使用，不再需要在 [status] 关键字参数中单独声明。\n\n这就是我们所说的“软依赖”耦合：一个模型将自身输入依赖于另一个模型的输出。\n\n下面是第一次尝试：\n\nusing PlantSimEngine\n# 导入 Examples 子模块中定义的示例：\nusing PlantSimEngine.Examples\n\n# 一个包含两个耦合模型的 ModelList\nmodels = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    status=(TT_cu=1.0:2000.0,),\n)\nstruct UnexpectedSuccess <: Exception end #hack 用于在不导致文档构建失败的情况下检测错误 #hide\n# 参见 https://github.com/JuliaDocs/Documenter.jl/issues/1420 #hide\ntry #hide\nrun!(models)\nthrow(UnexpectedSuccess()) #hide\ncatch err; err isa UnexpectedSuccess ? rethrow(err) : showerror(stderr, err); end  #hide\n\n此时会出现与气象数据相关的报错，详细提示如下：\n\nERROR: type NamedTuple has no field Ri_PAR_f\nStacktrace:\n  [1] getindex(mnt::Atmosphere{(), Tuple{}}, i::Symbol)\n    @ PlantMeteo ~/Path/to/PlantMeteo/src/structs/atmosphere.jl:147\n  [2] getcolumn(row::PlantMeteo.TimeStepRow{Atmosphere{(), Tuple{}}}, nm::Symbol)\n    @ PlantMeteo ~/Path/to/PlantMeteo/src/structs/TimeStepTable.jl:205\n    ...\n\nBeer 模型需要特定的气象参数。为了解决这个问题，我们可以通过导入示例气象数据文件来实现：\n\nusing PlantSimEngine\n\n# 现在使用 PlantMeteo 和 CSV 包\nusing PlantMeteo, CSV\n\n# 导入 Examples 子模块中定义的示例\nusing PlantSimEngine.Examples\n\n# 导入示例气象数据\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n\n# 一个包含两个耦合模型的 ModelList\nmodels = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    status=(TT_cu=cumsum(meteo_day.TT),), # 现在我们可以根据气象数据计算真正的积温\n)\n\n# 在 run! 调用中加入气象数据\noutputs_coupled = run!(models, meteo_day)\n\n\n如上所示，光截获模型使用 ToyLAIModel 计算的叶面积指数进行了后续计算。","category":"section"},{"location":"step_by_step/simple_model_coupling.html#进一步耦合","page":"模型耦合","title":"进一步耦合","text":"当然，还可以继续添加更多模型。下面是一个加入了另一个模型 ToyRUEGrowthModel 的 ModelList 示例，该模型用于计算光合作用带来的碳生物量增量。\n\nmodels = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    ToyRUEGrowthModel(0.2),\n    status=(TT_cu=cumsum(meteo_day.TT),),\n)\n\nnothing # hide","category":"section"},{"location":"introduction/why_plantsimengine.html#为什么选择PlantSimEngine？","page":"为什么选择 PlantSimEngine？","title":"为什么选择PlantSimEngine？","text":"PlantSimEngine的开发旨在解决现有植物建模工具的根本性局限性。该框架源自于这样一种需求：能够高效处理复杂的土壤-植物-大气连续体动态，同时对来自不同学科的研究人员和实际工作者保持友好和易用性。","category":"section"},{"location":"introduction/why_plantsimengine.html#当前植物建模工具的发展现状","page":"为什么选择 PlantSimEngine？","title":"当前植物建模工具的发展现状","text":"多年来，植物建模经历了显著的发展，不同的工具针对特定研究需求作出了不同的设计权衡。总体而言，这些工具大致可以分为三类，每类都各有优劣：","category":"section"},{"location":"introduction/why_plantsimengine.html#单体系统","page":"为什么选择 PlantSimEngine？","title":"单体系统","text":"如APSIM[1]、GroIMP[2]、AMAPStudio[3]、Helios[4]和CPlantBox[5]等系统，提供了全面的功能，但也存在一定的权衡：\n\n这些系统通常具备健壮、成熟且经过科学验证的框架，但它们庞大而复杂的代码库对没有丰富编程经验的用户来说，学习和修改都较为困难。\n\n其全面的体系结构集成了丰富的功能，但如果需要实现与预设框架不一致的新方法，往往需要对系统进行较多适配。\n\n这类系统在特定类型模拟中表现优异，但在实现跨土壤-植物-大气连续体的无缝多尺度模拟和模型耦合时，可能需要额外的工程投入。\n\n此类平台通常需要专门的工程资源来维护和扩展，研究团队往往还需配备专业的技术人员来开发和实现新模型。","category":"section"},{"location":"introduction/why_plantsimengine.html#分布式系统","page":"为什么选择 PlantSimEngine？","title":"分布式系统","text":"如OpenAlea[6]和Crops in Silico[7]等平台也各具优势与权衡：\n\n这些系统通常提供便捷的界面（多用Python等语言），强调易用性和灵活性，便于众多研究人员上手，但在大规模模拟时可能需要性能优化。\n\n其模块化设计有利于组件的复用和集成，但在扩展计算后端时，往往需要掌握多种编程语言。\n\n这类系统支持多样的建模范式，但在设计、实现到性能调优的迭代周期上，可能比专用工具更长。\n\n虽具有高度灵活性，但在实现复杂模型和用底层语言优化性能时，往往需要开发者投入大量时间和精力。","category":"section"},{"location":"introduction/why_plantsimengine.html#架构专注型工具","page":"为什么选择 PlantSimEngine？","title":"架构专注型工具","text":"如AMAPSim[8]等工具针对特定应用做出了专门的设计取舍：\n\n这些系统在聚焦领域（如植物结构建模）中表现突出，但若要对植物生理和环境响应进行全面研究，往往需要与其他工具集成。\n\n采用C++或Java等语言开发，获得了优异的运行性能，但这对不熟悉这些语言的研究人员来说，易用性有所降低。\n\n其在目标应用领域实现了复杂功能，但若希望快速实验和原型开发多样植物科学假设，仍需额外投入工程工作。","category":"section"},{"location":"introduction/why_plantsimengine.html#PlantSimEngine的解决方案","page":"为什么选择 PlantSimEngine？","title":"PlantSimEngine的解决方案","text":"PlantSimEngine融合了多项创新思想，有效平衡并解决上述种种权衡，提供独特的特性组合：","category":"section"},{"location":"introduction/why_plantsimengine.html#自动化模型耦合","page":"为什么选择 PlantSimEngine？","title":"自动化模型耦合","text":"无缝集成： PlantSimEngine 利用 Julia 的多重分派能力，能够自动计算不同模型之间的依赖关系图。这样，研究人员无需编写复杂的连接代码或手动管理依赖，即可轻松实现模型的耦合。\n\n直观的多尺度支持： 框架能够自然处理处于不同尺度（从细胞器到生态系统）的模型，只需极少的操作就能将它们连接起来，并在跨尺度建模中保持一致性。","category":"section"},{"location":"introduction/why_plantsimengine.html#灵活且可控的精度管理","page":"为什么选择 PlantSimEngine？","title":"灵活且可控的精度管理","text":"便捷的模型切换： 研究者只需简单的语法即可在不同组件模型之间切换，无需重写底层代码。这为快速比较不同假设和模型版本提供了便利，加速了科学发现过程。\n\n精细化模型控制： PlantSimEngine 允许用户锁定参数、强制某些变量与观测值一致，或在特定过程上选用更简单的子模型。这种灵活性既可以降低整体系统复杂度，又可在关键点保证模拟精度。\n\n自适应可扩展性： 同一套框架既能高效支持单株研究的原型模型，也能应对复杂生态系统模拟，并能根据问题规模灵活调整计算资源。","category":"section"},{"location":"introduction/why_plantsimengine.html#卓越的计算性能","page":"为什么选择 PlantSimEngine？","title":"卓越的计算性能","text":"极速计算： 基准测试显示，相关操作可在数百纳秒内完成，使 PlantSimEngine 能够胜任对计算性能要求极高的应用。例如，PlantBiophysics.jl 的实现比等效的 R 实现快 38,000 倍以上。\n\n高效的计算利用率： Julia 的“及时编译”（JIT）与原生并行支持确保了，在原型开发阶段做出的优化可以直接应用到大规模应用中，无需为提升效率而用其他语言重写代码。","category":"section"},{"location":"introduction/why_plantsimengine.html#开发者效率","page":"为什么选择 PlantSimEngine？","title":"开发者效率","text":"实现时间大幅缩短： PlantSimEngine 充分利用了 Julia 的动态语言特性，同时保持了静态编译型语言的高性能。这极大地减少了研究人员在模型实现和优化上的时间投入。\n\n模块化构件积木： 基于组件的架构让模型能够像积木一样以独立单元的形式拼接组合，便于搭建复杂系统。这种模块化设计大幅提升了代码复用率，降低了重复开发的工作量。\n\n无需工程额外负担： 与需要专职开发团队的“巨石型系统”或需后端优化的分布式平台不同，PlantSimEngine 让领域科学家无需深厚编程经验，也能独立开发高性能模型。\n\n原型到生产无缝贯通： 用于快速原型的同一份代码可直接用于生产级仿真，无需重写代码，消除了探索性研究与实际应用之间的传统壁垒。","category":"section"},{"location":"introduction/why_plantsimengine.html#关键创新","page":"为什么选择 PlantSimEngine？","title":"关键创新","text":"PlantSimEngine 的植物建模方法带来了建模范式的革新，让科学家能够以全新的方式构建和使用模型：\n\n统一 API： 标准化接口极大简化了新过程和组件模型的定义，降低了研究者的心智负担。\n自动依赖解析： 系统自动判断不同模型与过程间的依赖关系，免去了手动耦合的麻烦。\n无缝并行化： 框架内建对并行与分布式计算的支持，让研究者专注于科学问题而非实现细节。\n灵活模型集成： 可以轻松组合来自不同来源、不同尺度的模型组件，实现更全面、真实的系统模拟。\n以用户为中心的设计： 着重用户体验，确保各类编程背景的研究者都能高效参与和应用系统。\n\nPlantSimEngine 针对现有建模方法的种种取舍，提出了解决方案，让研究者能够把更多精力聚焦于科学问题，而不是技术实现细节，从而加快植物科学、农学及相关领域的发现步伐。\n\n[1]: Holzworth, D. P. et al. APSIM – Evolution towards a new generation of agricultural systems simulation. Environmental Modelling & Software 62, 327-350 (2014).\n\n[2]: Hemmerling, R., Kniemeyer, O., Lanwert, D., Kurth, W. & Buck-Sorlin, G. The rule-based language XL and the modelling environment GroIMP illustrated with simulated tree competition. Funct. Plant Biol. 35, 739 (2008).\n\n[3]: Griffon, S., and de Coligny, F. AMAPstudio: An editing and simulation software suite for plants architecture modelling. Ecological Modelling 290 (2014): 3‑10. https://doi.org/10.1016/j.ecolmodel.2013.10.037.\n\n[4]: Bailey, R. Spatial Modeling Environment for Enhancing Conifer Crown Management. Front. For. Glob. Change 3, 106 (2020).\n\n[5]: Schnepf, A., Leitner, D., Landl, M., Lobet, G., Mai, T. H., Morandage, S., Sheng, C., Zörner, M., Vanderborght, J., & Vereecken, H. CPlantBox: A whole-plant modelling framework for the simulation of water- and carbon-related processes. in silico Plants, 63 (2018).\n\n[6]: Pradal, C. et al. OpenAlea: A visual programming and component-based software platform for plant modeling. Funct. Plant Biol. 35, 751-760 (2008).\n\n[7]: Marshall-Colon, A. et al. Crops In Silico: Generating Virtual Crops Using an Integrative and Multi-Scale Modeling Platform. Frontiers in Plant Science 8 (2017). https://doi.org/10.3389/fpls.2017.00786.\n\n[8]: Barczi, J.-F., Rey, H., Caraglio, Y., Reffye, P. de, Barthélémy, D., Dong, Q. X., & Fourcaud, T. AmapSim: A Structural Whole-plant Simulator Based on Botanical Knowledge and Designed to Host External Functional Models. Annals of botany, 101(8), 1125-1138 (2008).","category":"section"},{"location":"working_with_data/fitting.html#参数拟合","page":"拟合","title":"参数拟合","text":"","category":"section"},{"location":"working_with_data/fitting.html#拟合-(fit)-方法","page":"拟合","title":"拟合 (fit) 方法","text":"模型通常需要利用数据进行校准，但校准过程会根据模型类型以及用户所拥有的数据而有所不同。\n\nPlantSimEngine 定义了一个通用的 fit 函数。这样模型开发者可以为自己的模型提供拟合参数的方法，用户也可以通过该方法使用数据对模型进行校准。\n\n在本包中，fit 函数本身并没有实质作用，仅仅用来为所有模型提供统一的接口。具体方法的实现，需要模型开发者自行为自己的模型进行定义。\n\n此方法的实现遵循如下设计模式：该函数的第一个参数应为模型类型（T::Type{<:AbstractModel}），第二个参数为数据（类型需兼容 Table.jl，例如 DataFrame），其余信息（如常数或带默认值的初始参数）可作为关键字参数传入。","category":"section"},{"location":"working_with_data/fitting.html#Beer-模型的示例","page":"拟合","title":"Beer 模型的示例","text":"实现 Beer 模型的示例脚本（参见 src/examples/Beer.jl）展示了如何为模型实现 fit 方法：\n\nfunction PlantSimEngine.fit(::Type{Beer}, df; J_to_umol=PlantMeteo.Constants().J_to_umol)\n    k = Statistics.mean(log.(df.Ri_PAR_f ./ (df.PPFD ./ J_to_umol)) ./ df.LAI)\n    return (k=k,)\nend\n\n该函数的第一个参数为 Beer 类型，第二个参数为数据，要求为兼容 Tables.jl 的类型，比如 DataFrame。关键字参数 J_to_umol 用于单位换算（μmol m⁻² s⁻¹ 与 J m⁻² s⁻¹ 之间的转换）。\n\ndf 数据框应包含 PPFD（单位：μmol m⁻² s⁻¹）、LAI（单位：m² m⁻²）以及 Ri_PAR_f（单位：W m⁻²）这三列。函数会基于这些值计算参数 k，并返回形如 (参数名=参数值,) 的 NamedTuple。\n\n下面是 fit 方法使用示例：\n\n首先导入需要的脚本和包：\n\nusing PlantSimEngine, PlantMeteo, DataFrames, Statistics\n# 导入在 `Examples` 子模块里定义的示例：\nusing PlantSimEngine.Examples\n\n定义气象数据：\n\nmeteo = Atmosphere(T=20.0, Wind=1.0, P=101.3, Rh=0.65, Ri_PAR_f=300.0)\n\n用 Beer 模型（k=0.6）根据 Ri_PAR_f 值计算 PPFD：\n\nm = ModelList(Beer(0.6), status=(LAI=2.0,))\nrun!(m, meteo)\n\n然后通过模拟得到的 PPFD 值构造用于拟合的数据：\n\ndf = DataFrame(aPPFD=m[:aPPFD][1], LAI=m.status.LAI[1], Ri_PAR_f=meteo.Ri_PAR_f[1])\n\n最后可以利用 fit 方法进行拟合：\n\nfit(Beer, df)\n\nnote: Note\n这是一个简单的演示示例，仅用于展示拟合方法的用法。实际应用中应直接使用观测到的数据来拟合参数值。","category":"section"},{"location":"working_with_data/reducing_dof.html#减少自由度（DoF）","page":"降低自由度","title":"减少自由度（DoF）","text":"","category":"section"},{"location":"working_with_data/reducing_dof.html#概述","page":"降低自由度","title":"概述","text":"","category":"section"},{"location":"working_with_data/reducing_dof.html#为什么要减少模型的自由度","page":"降低自由度","title":"为什么要减少模型的自由度","text":"通过将某些变量强制设为观测值来减少模型的自由度，有以下几个作用：\n\n可以通过约束模型并降低模型复杂性来防止过拟合。\n通过减少变量之间的协变性，有助于更好地校准模型的其他组成部分（参见参数退化（Parameter Degeneracy））。\n通过识别最关键的变量和关系，提高模型的可解释性。\n通过减少需要估算的变量个数，提高模型的计算效率。\n有助于确保模型与已知的物理或观测约束一致，提高模型及其预测结果的可信度。\n需要注意的是，过度约束模型可能导致不良拟合和得出错误结论，因此必须谨慎选择要约束哪些变量以及约束为哪些观测值。","category":"section"},{"location":"working_with_data/reducing_dof.html#参数退化（Parameter-Degeneracy）","page":"降低自由度","title":"参数退化（Parameter Degeneracy）","text":"模型中的“退化”或“参数退化”指的是当模型中的两个或多个变量高度相关时，一个变量的微小变化可以被另一个变量的微小变化补偿，从而导致模型整体预测结果保持不变。参数退化会导致难以准确估算变量的真实值，也难以确定模型的唯一解。这也会使模型对初始条件（如参数）和优化算法变得敏感。\n\n退化与“协变性”或“共线性”相关，它们都指多个变量之间的线性关系程度。在退化模型中，两个及以上变量高度协变，即高度相关，能够产生类似的预测。通过将某个变量固定为观测值，模型调整其他变量的灵活性会降低，有助于减少协变性，提升模型的稳健性。\n\n这是植物/作物建模中非常重要的话题，因为此类模型常常是退化的。在该领域通常称为“多重共线性（multicollinearity）”。在模型校准情境下，也常被称为“参数退化”或“参数共线性”。在模型简化（模型约减）时，也常称为“冗余”或“冗余变量”。","category":"section"},{"location":"working_with_data/reducing_dof.html#在-PlantSimEngine-中减少自由度（DoF）","page":"降低自由度","title":"在 PlantSimEngine 中减少自由度（DoF）","text":"","category":"section"},{"location":"working_with_data/reducing_dof.html#弱耦合模型（Soft-coupled-models）","page":"降低自由度","title":"弱耦合模型（Soft-coupled models）","text":"PlantSimEngine 提供了一种简单的方法来减少模型的自由度：通过将某些变量的值强制为观测值进行约束。\n\n我们先像往常一样，定义一个模型列表，包含 examples/dummy.jl 中的七个过程：\n\nusing PlantSimEngine, PlantMeteo\n# 导入 Examples 子模块中定义的示例模型：\nusing PlantSimEngine.Examples\n\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, P = 101.3, Rh = 0.65)\nm = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    Process4Model(),\n    Process5Model(),\n    Process6Model(),\n    Process7Model(),\n    status=(var0 = 0.5,)\n)\n\nrun!(m, meteo)\n\nstatus(m)\n\n假设 m 是我们的完整模型，现在我们想要通过强制 var9 的值为观测值来减少自由度。var9 之前是通过 Process7Model（一个弱依赖模型）计算得到的。在 PlantSimEngine 中，非常容易实现这个目标：只需从模型列表中移除对应模型，然后在 status 中给出观测值即可：\n\nm2 = ModelList(\n    Process1Model(2.0), \n    Process2Model(),\n    Process3Model(),\n    Process4Model(),\n    Process5Model(),\n    Process6Model(),\n    status=(var0 = 0.5, var9 = 10.0),\n)\n\nout = run!(m2, meteo)\n\n就这样！所有依赖 var9 的模型现在都会直接使用观测值 var9，而不会再使用 Process7Model 计算出的值。","category":"section"},{"location":"working_with_data/reducing_dof.html#强耦合模型（Hard-coupled-models）","page":"降低自由度","title":"强耦合模型（Hard-coupled models）","text":"对于与其他模型强耦合（hard-coupled）的模型，减少自由度会稍微复杂一些，因为它会调用其他模型的 run! 方法。\n\n在这种情况下，我们需要用一个新模型替换原有的模型，使变量值强制等于观测值。具体方法是：将测量值作为新模型的输入，并在 run! 方法中返回 nothing，这样变量的值就不会被修改。\n\n依然以包含上面七个过程的模型列表为例。假设这一次我们想要通过将原本由 Process1Model（一个强依赖模型）计算得到的 var3 强制为观测值来减少自由度。在 PlantSimEngine 中，这很容易实现：只需用一个新的模型替代原有模型，将 var3 的值设为测量值即可：\n\nstruct ForceProcess1Model <: AbstractProcess1Model end\nPlantSimEngine.inputs_(::ForceProcess1Model) = (var3=-Inf,)\nPlantSimEngine.outputs_(::ForceProcess1Model) = (var3=-Inf,)\nfunction PlantSimEngine.run!(::ForceProcess1Model, models, status, meteo, constants=nothing, extra=nothing)\n    return nothing\nend\n\n现在，我们可以用新的 ForceProcess1Model 替换原有的 Process1Model，创建一个新的模型列表：\n\nm3 = ModelList(\n    ForceProcess1Model(), \n    Process2Model(),\n    Process3Model(),\n    Process4Model(),\n    Process5Model(),\n    Process6Model(),\n    Process7Model(),\n    status = (var0=0.5,var3 = 10.0)\n)\n\nout = run!(m3, meteo)\n\nnote: Note\n理论上也可以通过 meteo 数据传递观测变量，但一般并不推荐。meteo 数据仅应用于气象变量，而不建议用作模型内部变量的输入。对于此类变量，最好仍然通过 status 进行赋值。","category":"section"},{"location":"working_with_data/floating_point_accumulation_error.html#浮点数注意事项","page":"浮点运算注意事项","title":"浮点数注意事项","text":"","category":"section"},{"location":"working_with_data/floating_point_accumulation_error.html#误差调查","page":"浮点运算注意事项","title":"误差调查","text":"在将单尺度模拟转换为多尺度模拟页面，我们将一个单尺度仿真转换为了等价的多尺度仿真并对输出进行了比较。这里有一个细节虽然被略过了，但作为 PlantSimEngine 用户十分重要：那就是浮点数近似所带来的影响。","category":"section"},{"location":"working_with_data/floating_point_accumulation_error.html#单尺度仿真","page":"浮点运算注意事项","title":"单尺度仿真","text":"meteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n\nmodels_singlescale = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    ToyRUEGrowthModel(0.2),\n    status=(TT_cu=cumsum(meteo_day.TT),),\n)\n\noutputs_singlescale = run!(models_singlescale, meteo_day)","category":"section"},{"location":"working_with_data/floating_point_accumulation_error.html#多尺度等价实现","page":"浮点运算注意事项","title":"多尺度等价实现","text":"PlantSimEngine.@process \"tt_cu\" verbose = false\n\nstruct ToyTt_CuModel <: AbstractTt_CuModel end\n\nfunction PlantSimEngine.run!(::ToyTt_CuModel, models, status, meteo, constants, extra=nothing)\n    status.TT_cu +=\n        meteo.TT\nend\n\nfunction PlantSimEngine.inputs_(::ToyTt_CuModel)\n    NamedTuple() # 没有输入变量\nend\n\nfunction PlantSimEngine.outputs_(::ToyTt_CuModel)\n    (TT_cu=0.0,)\nend\n\nmapping_multiscale = Dict(\n    \"Scene\" => ToyTt_CuModel(),\n    \"Plant\" => (\n        MultiScaleModel(\n            model=ToyLAIModel(),\n            mapped_variables=[\n                :TT_cu => \"Scene\",\n            ],\n        ),\n        Beer(0.5),\n        ToyRUEGrowthModel(0.2),\n    ),\n)\n\nmtg_multiscale = MultiScaleTreeGraph.Node(MultiScaleTreeGraph.NodeMTG(\"/\", \"Plant\", 0, 0),)\n    plant = MultiScaleTreeGraph.Node(mtg_multiscale, MultiScaleTreeGraph.NodeMTG(\"+\", \"Plant\", 1, 1))\n\noutputs_multiscale = run!(mtg_multiscale, mapping_multiscale, meteo_day)","category":"section"},{"location":"working_with_data/floating_point_accumulation_error.html#输出比较","page":"浮点运算注意事项","title":"输出比较","text":"\ncomputed_TT_cu_multiscale = [outputs_multiscale[\"Scene\"][i].TT_cu for i in 1:length(outputs_multiscale[\"Scene\"])]\nis_approx_equal = length(unique(computed_TT_cu_multiscale .≈ outputs_singlescale.TT_cu)) == 1\n\n为什么要近似比较？为什么使用 ≈ 而不是 ==？\n\n我们来尝试一下。如果直接这么写会怎么样：\n\ncomputed_TT_cu_multiscale = [outputs_multiscale[\"Scene\"][i].TT_cu for i in 1:length(outputs_multiscale[\"Scene\"])]\nis_perfectly_equal = length(unique(computed_TT_cu_multiscale .== outputs_singlescale.TT_cu)) == 1\n\n为什么结果是 false（假）？让我们看一下数据。\n\n仔细观察输出，可以发现前 105 个时间步的取值实际上是完全一致的：\n\n(computed_TT_cu_multiscale .== outputs_singlescale.TT_cu)[104]\n\n(computed_TT_cu_multiscale .== outputs_singlescale.TT_cu)[105]\n\n这时的值分别是 132.33333333333331（多尺度）和 132.33333333333334（单尺度）。最终输出值分别为 2193.8166666666643（多尺度）和 2193.816666666666（单尺度）。\n\n两者的差异很小，但在更多时间步或累积更多节点后，这个偏差就有可能逐步扩大并变为潜在问题。","category":"section"},{"location":"working_with_data/floating_point_accumulation_error.html#浮点数累加","page":"浮点运算注意事项","title":"浮点数累加","text":"数值不完全相等的原因是很多数字无法用浮点数精确地表示。一个经典例子是 0.1 + 0.2 != 0.3 ： \n\nprintln(0.1 + 0.2 - 0.3)\n\n当对许多数字进行累加时，根据加法的顺序不同，浮点误差聚积得快慢有别。\n\n本例中的 Toy_Tt_CuModel 模拟每个时间步采用了普通的逐步累加方式。而在单尺度仿真中直接计算 TT_cu 时使用的 cumsum 函数采用了成对（pairwise）累加的方法，这种方式累计误差的位数更少，误差增长更慢。\n\n在我们的简单例子中，由于使用 Float64，误差尚不足以影响整体结果，但对于更长的时间步、更多节点的累计、或更复杂的模型，若模型不加留意，浮点误差很可能逐步放大，最终影响仿真结果的准确性。\n\n根据具体计算值和数学运算方式不同，解决办法可能只是对输入数据缩放、也可能需要较大幅度地重构模型，以降低累加误差的风险。","category":"section"},{"location":"working_with_data/floating_point_accumulation_error.html#其他关于浮点数精度问题的相关链接","page":"浮点运算注意事项","title":"其他关于浮点数精度问题的相关链接","text":"请注意，以下博客文章中的许多示例讨论的是 Float32 精度。Float64 值则有更多额外的精度位可供使用。\n\n关于浮点数精度的一系列博客文章：\n\nhttps://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/\n浮点数直观解释：https://fabiensanglard.net/floatingpointvisually_explained/\n浮点数问题实例：https://jvns.ca/blog/2023/01/13/examples-of-floating-point-problems/\n\n特别关于浮点数求和的资料：\n\n成对求和法：https://en.wikipedia.org/wiki/Pairwise_summation\nKahan 求和算法：https://en.wikipedia.org/wiki/Kahansummationalgorithm\n驯服浮点求和：https://orlp.net/blog/taming-float-sums/","category":"section"},{"location":"multiscale/multiscale.html#多尺度变量映射","page":"更多变量映射示例","title":"多尺度变量映射","text":"上一页介绍了如何将单一尺度的模拟转换为多尺度模拟。\n\n本页将通过一个更复杂的多尺度版本示例，进一步展示变量映射的细节和技巧。所有模型均来自examples文件夹。\n\nPages = [\"multiscale.md\"]\nDepth = 3","category":"section"},{"location":"multiscale/multiscale.html#从单模型映射开始","page":"更多变量映射示例","title":"从单模型映射开始","text":"我们首先导入PlantSimEngine包，以及本教程需要使用的所有示例模型：\n\nusing PlantSimEngine\nusing PlantSimEngine.Examples # 导入一些示例模型\n\n接下来我们将创建一个简单的映射，只有一个初始模型，即负责叶片碳同化过程的ToyAssimModel。 它类似于单尺度模拟中模型切换小节所用的ToyAssimGrowth模型。\n\n因此，我们的尺度与模型映射关系为：\n\nmapping = Dict(\"Leaf\" => ToyAssimModel())\n\n和单尺度模拟类似，我们可以通过调用to_initialize来检查是否有变量需要初始化。不同的是，这次会按尺度进行索引：\n\nto_initialize(mapping)\n\n在此示例中，ToyAssimModel需要:aPPFD与:soil_water_content作为输入，但它们在我们当前的映射中尚未初始化。\n\n这些变量的初始化值可以通过Status对象传递：\n\nmapping = Dict(\n    \"Leaf\" => (\n        ToyAssimModel(),\n        Status(aPPFD=1300.0, soil_water_content=0.5),\n    ),\n)\n\n如果我们对上述新的 mapping 调用 to_initialize，它会返回一个空字典，意味着变量映射已经有效，我们可以开始进行模拟了：\n\nto_initialize(mapping)","category":"section"},{"location":"multiscale/multiscale.html#多尺度下模型与尺度间的变量映射","page":"更多变量映射示例","title":"多尺度下模型与尺度间的变量映射","text":"在之前的示例中，soil_water_content 变量是直接通过 mapping 提供的，并没有被任何模型计算，因此它是一个常量。实际上，我们也可以用模型来动态计算它（例如根据气象数据或更真实的物理过程）。\n\n通常，这类模型应当运行在与 \"Leaf\"（叶片）不同的尺度。例如，examples 文件夹中就有一个简单的土壤模型（ToySoilWaterModel）。我们可以将其放在新的 \"Soil\"（土壤）尺度。\n\n此时，ToyAssimModel 不再通过自身的 Status 初始化获得 soil_water_content，而是从 \"Soil\" 尺度获取。为此，我们需要将 ToyAssimModel 包装为 MultiScaleModel，并指定 soil_water_content 要从 \"Soil\" 尺度映射而来：\n\nmapping = Dict(\n    \"Soil\" => ToySoilWaterModel(),\n    \"Leaf\" => (\n        MultiScaleModel(\n            model=ToyAssimModel(),\n            mapped_variables=[:soil_water_content => \"Soil\" => :soil_water_content,],\n        ),\n        Status(aPPFD=1300.0),        \n    ),\n);\nnothing # hide\n\n在这个例子里，我们把 \"Leaf\" 尺度下的 soil_water_content 变量与 \"Soil\" 尺度下的同名变量进行了映射。如果两个尺度之间变量名称相同，还可以省略目标尺度的变量名，比如写为 [:soil_water_content => \"Soil\"] 即可。\n\n变量 aPPFD 依然作为常量通过 Status 进行初始化。\n\n我们可以再次用 to_initialize 检查映射是否合理：\n\nto_initialize(mapping)\n\n如前，同样会返回空字典，说明映射已经完全满足要求。","category":"section"},{"location":"multiscale/multiscale.html#一个更复杂的多尺度模型映射","page":"更多变量映射示例","title":"一个更复杂的多尺度模型映射","text":"现在，我们来扩展这个 mapping，展示变量如何以不同方式从一个尺度映射到另一个尺度。我们保留前两个模型，并添加几个新模型，以模拟植物体内的其他过程。\n\nmapping = Dict(\n    \"Scene\" => ToyDegreeDaysCumulModel(),\n    \"Plant\" => (\n        MultiScaleModel(\n            model=ToyLAIModel(),\n            mapped_variables=[\n                :TT_cu => \"Scene\",\n            ],\n        ),\n        Beer(0.6),\n        MultiScaleModel(\n            model=ToyCAllocationModel(),\n            mapped_variables=[\n                :carbon_assimilation => [\"Leaf\"],\n                :carbon_demand => [\"Leaf\", \"Internode\"],\n                :carbon_allocation => [\"Leaf\", \"Internode\"]\n            ],\n        ),\n        MultiScaleModel(\n            model=ToyPlantRmModel(),\n            mapped_variables=[:Rm_organs => [\"Leaf\" => :Rm, \"Internode\" => :Rm],],\n        ),\n    ),\n    \"Internode\" => (\n        MultiScaleModel(\n            model=ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0),\n            mapped_variables=[:TT => \"Scene\",],\n        ),\n        ToyMaintenanceRespirationModel(1.5, 0.06, 25.0, 0.6, 0.004),\n        Status(carbon_biomass=1.0),\n    ),\n    \"Leaf\" => (\n        MultiScaleModel(\n            model=ToyAssimModel(),\n            mapped_variables=[:soil_water_content => \"Soil\", :aPPFD => \"Plant\"],\n        ),\n        MultiScaleModel(\n            model=ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0),\n            mapped_variables=[:TT => \"Scene\",],\n        ),\n        ToyMaintenanceRespirationModel(2.1, 0.06, 25.0, 1.0, 0.025),\n        Status(carbon_biomass=0.5),\n    ),\n    \"Soil\" => (\n        ToySoilWaterModel(),\n    ),\n);\nnothing # hide\n\n这种变量映射相比之前的例子看起来要复杂一些，但细看仍然能发现很多熟悉的模型。实际上，你可以认为这里的变量映射，是在模型切换小节中那个包含光合模型、LAI模型和碳生物量增长模型的单尺度示例的增强和更复杂的多尺度版本。\n\nmodels2 = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    ToyAssimGrowthModel(),\n    status=(TT_cu=cumsum(meteo_day.TT),),\n)\n\n在该多尺度建模中，模型模拟了通过光合作用获得碳，以及碳在植物器官间分配用于维持呼吸和生长发育的过程。\n\nLAI和光合模型与ModelList示例中的是相同的。ToyDegreeDaysCumulModel为植物提供累计温度时间（Cumulative Thermal Time）。\n\n新引入的各个模型动态如下：\n\n碳分配（ToyCAllocationModel）依赖于“叶片”（\"Leaf\"）层次的同化值（即供给），以及各器官（“叶片”、“节间”）的碳需求（ToyCDemandModel），从而决定植物不同器官的碳分配。在“土壤”层级（\"Soil\" scale）利用(ToySoilWaterModel](@ref)计算土壤含水量，该值用于“叶片”层级的光合模型（ToyAssimModel）进行同化计算。此外，维持呼吸分别在“叶片”和“节间”两级通过ToyMaintenanceRespirationModel单独计算，再在“植株”层级通过ToyPlantRmModel聚合成整体的维持呼吸总量。","category":"section"},{"location":"multiscale/multiscale.html#不同的变量映射方式","page":"更多变量映射示例","title":"不同的变量映射方式","text":"上面的变量映射展示了在 MultiScaleModel 中定义变量映射的几种不同方式：\n\n mapped_variables=[:TT_cu => \"Scene\",],\n\n在 \"Plant\"（植株）层级，变量 TTcu 被作为标量从 \"Scene\"（场景）层级映射过来。在 MTG（多重拓扑图）中只包含一个 \"Scene\" 节点，因此每个仿真步长只有一个 \"TTcu\" 值。\n\n:carbon_allocation => [\"Leaf\"]\n\n另一方面，在“Plant”尺度的 ToyCAllocationModel，我们有 :carbon_allocation => [\"Leaf\"]。这里 carbon_assimilation 变量作为一个向量被映射：因为可能存在多个 \"Leaf\"（叶片）节点，但只有一个 \"Plant\" 节点，该节点聚合所有叶片的值。这样就形成了“多对一”的向量映射，在该尺度下模型的 run! 函数中，status 下的 carbon_allocation 将作为向量提供。\n\n:carbon_allocation => [\"Leaf\", \"Internode\"]\n\n第三种映射方式是 :carbon_allocation => [\"Leaf\", \"Internode\"]，即从多个层级（如 \"Leaf\" 和 \"Internode\"）同时为某变量提供数值。在这种情况下，值也会以向量形式出现在模型内部的 status 的 carbon_assimilation 变量中，节点的顺序与其在图中遍历顺序一致。\n\n:Rm_organs => [\"Leaf\" => :Rm, \"Internode\" => :Rm]\n\n最后，还可以将变量映射到目标层级下的特定变量名，例如 :Rm_organs => [\"Leaf\" => :Rm, \"Internode\" => :Rm]。这种语法适用于不同层级间变量名不一致，希望明确指定映射目标变量名的场景。在本例中，plant 层级下的变量 Rm_organs 从 \"Leaf\" 和 \"Internode\" 层级下的 Rm 变量获取数值（进行映射）。","category":"section"},{"location":"multiscale/multiscale.html#运行模拟","page":"更多变量映射示例","title":"运行模拟","text":"现在我们已经有了有效的变量映射，可以运行一次多尺度模拟。运行一个多尺度模拟需要一棵植物结构图（plant graph），以及为每个层级动态定义我们想要输出的变量。","category":"section"},{"location":"multiscale/multiscale.html#植物结构图","page":"更多变量映射示例","title":"植物结构图","text":"可以通过如下方式导入一个示例多尺度树结构图：\n\nmtg = import_mtg_example()\n\nnote: Note\n只有在预先导入了 PlantSimEngine 的 Examples 子模块（即 using PlantSimEngine.Examples）时，才能使用 import_mtg_example。\n\n这个结构图包含一个根节点（代表“场景”Scene）、一个“土壤”节点，以及包含两个节间和两个叶片的“植株”节点。","category":"section"},{"location":"multiscale/multiscale.html#输出变量","page":"更多变量映射示例","title":"输出变量","text":"对于具有很多器官并且模拟步数较长的模拟来说，输出的数据量可能非常庞大。可以通过限制需要追踪的输出变量，仅追踪所有变量的一个子集，从而减少数据量：\n\nouts = Dict(\n    \"Scene\" => (:TT, :TT_cu,),\n    \"Plant\" => (:aPPFD, :LAI),\n    \"Leaf\" => (:carbon_assimilation, :carbon_demand, :carbon_allocation, :TT),\n    \"Internode\" => (:carbon_allocation,),\n    \"Soil\" => (:soil_water_content,),\n)\n\n这个字典可以作为可选参数 tracked_outputs 传递给 run! 函数（详见下一部分）。如果不提供该字典，则默认会追踪所有变量。\n\n以上这些变量会在 run! 返回的输出结果中提供，并且每个时间步均有相应的取值。输出还会包含对应的时间步和该变量所属的 MTG 节点。","category":"section"},{"location":"multiscale/multiscale.html#气象数据","page":"更多变量映射示例","title":"气象数据","text":"与单尺度模型一样，我们需要为模拟提供气象数据。我们可以使用 PlantMeteo 包生成两个时间步的示例气象数据：\n\nmeteo = Weather(\n    [\n    Atmosphere(T=20.0, Wind=1.0, Rh=0.65, Ri_PAR_f = 200.0),\n    Atmosphere(T=25.0, Wind=0.5, Rh=0.8, Ri_PAR_f = 180.0)\n]\n)","category":"section"},{"location":"multiscale/multiscale.html#模拟运行","page":"更多变量映射示例","title":"模拟运行","text":"让我们用刚才定义的结构图和输出变量来进行一次模拟：\n\noutputs_sim = run!(mtg, mapping, meteo, tracked_outputs = outs);\nnothing # hide\n\n就是这样！现在我们可以以“NamedTuple 对象的向量字典”形式访问各个尺度的模拟输出。\n\n或者，也可以借助 DataFrames 包，将模拟结果转为 DataFrame 组成的字典：\n\nusing DataFrames\ndf_dict = convert_outputs(outputs_sim, DataFrame)","category":"section"},{"location":"step_by_step/quick_and_dirty_examples.html#快速示例","page":"快速示例","title":"快速示例","text":"本页面适用于已经配置好环境，并希望直接复制粘贴一个或两个示例代码、查看 REPL 返回结果并快速上手的用户。\n\n如果你对 Julia 不太熟悉，或者还没有配置好环境，请参阅此页面：Julia 入门指南。 如果你希望获得更详细的示例讲解，可以查阅分步讲解部分，该部分会提供更深入的说明。\n\n以下示例均为单尺度（single-scale）模拟。如需多尺度建模教程和示例，请参考[此节][#multiscale]。\n\n你可以在examples 文件夹中找到所有示例模型的实现以及其它玩具模型。\n\nPages = [\"quick_and_dirty_examples.md\"]\nDepth = 2","category":"section"},{"location":"step_by_step/quick_and_dirty_examples.html#环境说明","page":"快速示例","title":"环境说明","text":"这些示例假定你已拥有安装了 PlantSimEngine 及其它所需包的 Julia 环境。如何配置环境的具体细节请参考 PlantSimEngine 的安装与运行 页面。","category":"section"},{"location":"step_by_step/quick_and_dirty_examples.html#单一光截获模型与单一气象时步的示例","page":"快速示例","title":"单一光截获模型与单一气象时步的示例","text":"using PlantSimEngine, PlantMeteo\nusing PlantSimEngine.Examples\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, Rh = 0.65, Ri_PAR_f = 500.0)\nleaf = ModelList(Beer(0.5), status = (LAI = 2.0,))\nout = run!(leaf, meteo)","category":"section"},{"location":"step_by_step/quick_and_dirty_examples.html#光截获模型与叶面积指数模型的耦合","page":"快速示例","title":"光截获模型与叶面积指数模型的耦合","text":"本示例中的气象数据包含 365 天的数据，因此模拟将有同样数量的时步。\n\nusing PlantSimEngine\nusing PlantMeteo, CSV, DataFrames\n\nusing PlantSimEngine.Examples\n\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n\nmodels = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    status=(TT_cu=cumsum(meteo_day.TT),),\n)\n\noutputs_coupled = run!(models, meteo_day)","category":"section"},{"location":"step_by_step/quick_and_dirty_examples.html#光截获模型、叶面积指数模型与生物量增长模型的耦合示例","page":"快速示例","title":"光截获模型、叶面积指数模型与生物量增长模型的耦合示例","text":"using PlantSimEngine\nusing PlantMeteo, CSV, DataFrames\n\nusing PlantSimEngine.Examples\n\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n\nmodels = ModelList(\n    ToyLAIModel(),\n    Beer(0.5),\n    ToyRUEGrowthModel(0.2),\n    status=(TT_cu=cumsum(meteo_day.TT),),\n)\n\noutputs_coupled = run!(models, meteo_day)","category":"section"},{"location":"step_by_step/quick_and_dirty_examples.html#使用-PlantBioPhysics-的示例","page":"快速示例","title":"使用 PlantBioPhysics 的示例","text":"PlantBioPhysics 是一个与 PlantSimEngine 配套的软件包，内置了诸多应用于生态生理模拟的模型。\n\n你可以在此处查看它的文档。\n\n该文档中提供了数个示例模拟。以下是摘自此页面的一个示例：\n\nusing PlantBiophysics, PlantSimEngine\n\nmeteo = Atmosphere(T = 22.0, Wind = 0.8333, P = 101.325, Rh = 0.4490995)\n\nleaf = ModelList(\n        Monteith(),\n        Fvcb(),\n        Medlyn(0.03, 12.0),\n        status = (Ra_SW_f = 13.747, sky_fraction = 1.0, aPPFD = 1500.0, d = 0.03)\n    )\n\nout = run!(leaf,meteo)","category":"section"},{"location":"index.html#PlantSimEngine","page":"首页","title":"PlantSimEngine","text":"(Image: 构建状态) (Image: 覆盖率) (Image: ColPrac: 社区包协作实践贡献者指南) (Image: Aqua 质量保证) (Image: DOI) (Image: JOSS)\n\nPages = [\"index.md\"]\nDepth = 5","category":"section"},{"location":"index.html#概述","page":"首页","title":"概述","text":"PlantSimEngine 是一个专为构建土壤-植株-大气连续体模型而设计的综合性框架。它为在任何尺度上原型设计、评估、测试和部署植物/作物模型提供了所需的一切，极大地强调了性能和效率，让您能专注于模型的构建与完善。\n\n为什么选择 PlantSimEngine？\n\n简单性：极大减少代码量，专注于模型逻辑，其余交给框架自动处理。\n模块化：每个模型组件都可独立开发、测试与改进。可通过复用高质量的预构建模块，灵活组装复杂仿真。\n标准化：具有清晰且可执行的规范，保证所有模型都遵循最佳实践。如此一来，模型可在整个生态系统内无缝协作。\n性能优化：无需重复造轮子。低层的繁琐任务全部交由 PlantSimEngine 负责，您的模型能享受到底层框架的每一次优化和性能提升。以 Julia 的高性能保证高效的原型迭代与模型运行。","category":"section"},{"location":"index.html#独特特性","page":"首页","title":"独特特性","text":"","category":"section"},{"location":"index.html#自动耦合模型","page":"首页","title":"自动耦合模型","text":"无缝集成：PlantSimEngine 充分利用 Julia 多重分派的强大能力，能够自动计算模型间的依赖图，研究人员无需编写复杂的连接代码或手动处理依赖关系，即可便捷实现模型耦合。\n\n直观的多尺度支持：框架能够自然支持不同空间尺度（从细胞器到生态系统）的模型间耦合，仅需极小的工作量，即可维护不同尺度间的状态一致性。","category":"section"},{"location":"index.html#灵活且精细可控","page":"首页","title":"灵活且精细可控","text":"轻松切换模型组件：通过简洁直观的语法，用户可在不更改模型底层代码的情况下切换不同的组件，实现不同假设与模型版本之间的快速对比，极大加速科学发现过程。","category":"section"},{"location":"index.html#集成“电池”——开箱即用的功能","page":"首页","title":"集成“电池”——开箱即用的功能","text":"自动化管理：自动处理输入、输出、时间步长、对象及依赖关系。\n迭代开发：拥有内建约束，避免错误，同时具备合理默认值，加快模型的交互式原型设计。\n自由度管理：可固定变量为常数或观测值，也可针对具体过程采用简化模型以降低整体复杂度。\n高速计算：已在复杂模型中实现了百纳秒级的性能表现（见此基准测试脚本）。\n并行与分布式计算：借助 Floops.jl，对象、时间步或独立过程均可自动支持串行、多线程或分布式计算。\n无缝扩展：支持对象、时间步和 多尺度树结构的高效计算方法。\n自由组合：输入可以是任意类型，包括 Unitful 用于单位传播，以及 MonteCarloMeasurements.jl 用于测量误差传播。","category":"section"},{"location":"index.html#性能表现","page":"首页","title":"性能表现","text":"PlantSimEngine 在植物建模任务中展现了令人瞩目的性能表现。例如在一台 M1 MacBook Pro 上：\n\n一个叶面积指数（LAI）玩具模型，以逐日时间步模拟全年，仅耗时 260 微秒（约为每一天 688 纳秒）\n同一个模型与光截获模型耦合后，所需时间为 275 微秒（每一天约为 756 纳秒）\n\n这些基准测试表明，其性能已媲美 Fortran 或 C 等编译型语言，远超多数解释型语言的典型实现。例如，基于 PlantSimEngine 实现生态生理学模型的 PlantBiophysics.jl，被测得运行速度可比其它科学计算语言中的等价实现快 38,000 倍。","category":"section"},{"location":"index.html#问题反馈","page":"首页","title":"问题反馈","text":"如果有任何疑问或建议，欢迎提交 issue或在 discourse 讨论区咨询。","category":"section"},{"location":"index.html#安装方法","page":"首页","title":"安装方法","text":"要安装本包，请在 Julia REPL 中按下 ] 进入包管理模式，然后输入下列命令：\n\nadd PlantSimEngine\n\n要使用本包，只需在 Julia REPL 输入下列命令：\n\nusing PlantSimEngine","category":"section"},{"location":"index.html#使用示例","page":"首页","title":"使用示例","text":"本包设计为易于上手，并帮助用户在实现、耦合和模拟模型过程中减少出错。","category":"section"},{"location":"index.html#简单示例","page":"首页","title":"简单示例","text":"以下是一个简单的模型示例，模拟了植物的生长过程，采用了指数生长模型：\n\n# ] add PlantSimEngine\nusing PlantSimEngine\n\n# 导入 `Examples` 子模块中定义的示例\nusing PlantSimEngine.Examples\n\n# 定义模型：\nmodel = ModelList(\n    ToyLAIModel(),\n    status=(TT_cu=1.0:2000.0,), # 以积温作为模型输入\n)\n\nout = run!(model) # 运行模型并获取输出\n\n注意   ToyLAIModel 可以在示例文件夹中找到，是一个简单的指数生长模型。这里只作为演示使用，实际上你可以使用任意符合 PlantSimEngine 接口的模型。\n\n当然，你也可以很方便地绘制输出结果：\n\n# ] add CairoMakie\nusing CairoMakie\n\nlines(out[:TT_cu], out[:LAI], color=:green, axis=(ylabel=\"LAI (m² m⁻²)\", xlabel=\"Cumulated growing degree days since sowing (°C)\"))","category":"section"},{"location":"index.html#模型耦合","page":"首页","title":"模型耦合","text":"模型的耦合由本包自动完成，基于各模型之间的依赖图实现。要耦合多个模型，只需将它们添加到 ModelList 中即可。例如，下面将 ToyLAIModel 与基于比尔定律（Beer's law）的光截获模型进行耦合：\n\n# ] add PlantSimEngine, DataFrames, CSV\nusing PlantSimEngine, PlantMeteo, DataFrames, CSV\n\n# 导入 `Examples` 子模块中定义的示例\nusing PlantSimEngine.Examples\n\n# 导入示例气象数据：\nmeteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n\n# 定义用于耦合的模型列表：\nmodel2 = ModelList(\n    ToyLAIModel(),\n    Beer(0.6),\n    status=(TT_cu=cumsum(meteo_day[:, :TT]),),  # 将累计生长积温作为 ToyLAIModel 的输入，也可以通过其他模型完成\n)\n\n# 运行模拟：\nout2 = run!(model2, meteo_day)\n\nModelList 会通过自动计算模型之间的依赖图来实现模型的耦合。最终的依赖图如下所示：\n\n╭──── Dependency graph ──────────────────────────────────────────╮\n│  ╭──── LAI_Dynamic ─────────────────────────────────────────╮  │\n│  │  ╭──── Main model ────────╮                              │  │\n│  │  │  Process: LAI_Dynamic  │                              │  │\n│  │  │  Model: ToyLAIModel    │                              │  │\n│  │  │  Dep: nothing          │                              │  │\n│  │  ╰────────────────────────╯                              │  │\n│  │                  │  ╭──── Soft-coupled model ─────────╮  │  │\n│  │                  │  │  Process: light_interception    │  │  │\n│  │                  └──│  Model: Beer                    │  │  │\n│  │                     │  Dep: (LAI_Dynamic = (:LAI,),)  │  │  │\n│  │                     ╰─────────────────────────────────╯  │  │\n│  ╰──────────────────────────────────────────────────────────╯  │\n╰────────────────────────────────────────────────────────────────╯\n\n我们可以通过变量名索引输出结果来绘制模拟结果（如 out2[:LAI]）：\n\nusing CairoMakie\n\nfig = Figure(resolution=(800, 600))\nax = Axis(fig[1, 1], ylabel=\"LAI (m² m⁻²)\")\nlines!(ax, out2[:TT_cu], out2[:LAI], color=:mediumseagreen)\n\nax2 = Axis(fig[2, 1], xlabel=\"Cumulated growing degree days since sowing (°C)\", ylabel=\"aPPFD (mol m⁻² d⁻¹)\")\nlines!(ax2, out2[:TT_cu], out2[:aPPFD], color=:firebrick1)\n\nfig","category":"section"},{"location":"index.html#多尺度的建模","page":"首页","title":"多尺度的建模","text":"更多细节请参见多尺度建模章节。\n\n本包设计高度可扩展，可方便地对不同尺度下的模型进行模拟。例如，可以在叶片尺度模拟模型，再与其他尺度（如节间、植株、土壤、场景等）下的模型进行耦合。下面这个例子展示了一个使用不同尺度下子模型来模拟植物生长的简单模型：\n\nmapping = Dict(\n    \"Scene\" => ToyDegreeDaysCumulModel(),\n    \"Plant\" => (\n        MultiScaleModel(\n            model=ToyLAIModel(),\n            mapped_variables=[\n                :TT_cu => \"Scene\",\n            ],\n        ),\n        Beer(0.6),\n        MultiScaleModel(\n            model=ToyAssimModel(),\n            mapped_variables=[:soil_water_content => \"Soil\"],\n        ),\n        MultiScaleModel(\n            model=ToyCAllocationModel(),\n            mapped_variables=[\n                :carbon_demand => [\"Leaf\", \"Internode\"],\n                :carbon_allocation => [\"Leaf\", \"Internode\"]\n            ],\n        ),\n        MultiScaleModel(\n            model=ToyPlantRmModel(),\n            mapped_variables=[:Rm_organs => [\"Leaf\" => :Rm, \"Internode\" => :Rm],],\n        ),\n    ),\n    \"Internode\" => (\n        MultiScaleModel(\n            model=ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0),\n            mapped_variables=[:TT => \"Scene\",],\n        ),\n        MultiScaleModel(\n            model=ToyInternodeEmergence(TT_emergence=20.0),\n            mapped_variables=[:TT_cu => \"Scene\"],\n        ),\n        ToyMaintenanceRespirationModel(1.5, 0.06, 25.0, 0.6, 0.004),\n        Status(carbon_biomass=1.0)\n    ),\n    \"Leaf\" => (\n        MultiScaleModel(\n            model=ToyCDemandModel(optimal_biomass=10.0, development_duration=200.0),\n            mapped_variables=[:TT => \"Scene\",],\n        ),\n        ToyMaintenanceRespirationModel(2.1, 0.06, 25.0, 1.0, 0.025),\n        Status(carbon_biomass=1.0)\n    ),\n    \"Soil\" => (\n        ToySoilWaterModel(),\n    ),\n);\nnothing # hide\n\n我们可以从包中导入一个示例植物：\n\nmtg = import_mtg_example()\n\n创建一个虚拟气象数据：\n\nmeteo = Weather(\n    [\n    Atmosphere(T=20.0, Wind=1.0, Rh=0.65, Ri_PAR_f=300.0),\n    Atmosphere(T=25.0, Wind=0.5, Rh=0.8, Ri_PAR_f=500.0)\n]\n);\nnothing # hide\n\n然后运行模拟：\n\nout_vars = Dict(\n    \"Scene\" => (:TT_cu,),\n    \"Plant\" => (:carbon_allocation, :carbon_assimilation, :soil_water_content, :aPPFD, :TT_cu, :LAI),\n    \"Leaf\" => (:carbon_demand, :carbon_allocation),\n    \"Internode\" => (:carbon_demand, :carbon_allocation),\n    \"Soil\" => (:soil_water_content,),\n)\n\nout = run!(mtg, mapping, meteo, tracked_outputs=out_vars, executor=SequentialEx());\nnothing # hide\n\n然后我们可以提取输出，并针对每个层级将其转换为 DataFrame 并进行排序：\n\nusing DataFrames\ndf_dict = convert_outputs(out, DataFrame)\nsort!(df_dict[\"Leaf\"], [:timestep, :node])\n\n多尺度模拟的一个示例输出可以在 PlantBiophysics.jl 的文档中看到：\n\n(Image: 植物生长模拟)","category":"section"},{"location":"index.html#领域现状","page":"首页","title":"领域现状","text":"PlantSimEngine 是最前沿的植物模拟软件，相比 OpenAlea、STICS、APSIM 或 DSSAT 等已有工具具备显著优势。\n\nPlantSimEngine 基于 Julia 编程语言，带来了如下好处：\n\n与编译型语言相比，原型开发更加快速、便捷\n性能显著优于典型的解释型语言\n无需将模型转换到其他编译型语言\n\nJulia 的特性赋予 PlantSimEngine 以下能力：\n\n多重分派，自动计算模型依赖图\n类型稳定性，优化运行性能\n与 MultiScaleTreeGraph.jl 等强大工具无缝兼容，支持多尺度计算\n\nPlantSimEngine 的实现大大简化了模型开发流程，可以自动管理：\n\n通过自动依赖图计算实现模型耦合\n时间步长与并行化\n输入与输出变量\n支持多种用于模拟的对象类型（如向量、字典、多尺度树图等）","category":"section"},{"location":"index.html#使用-PlantSimEngine-的项目","page":"首页","title":"使用 PlantSimEngine 的项目","text":"以下项目已经应用了 PlantSimEngine：\n\nPlantBiophysics.jl\nXPalm","category":"section"},{"location":"index.html#让它成为你的工具","page":"首页","title":"让它成为你的工具","text":"本包的开发旨在让任何人都能轻松地实现植物/作物建模，并可凭借 MIT 许可证免费自由地使用。\n\n如果你开发了相关工具但尚未在此列表中，请提交 PR 或与我联系，我们会很高兴地添加你的项目！😃","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting.html#错误信息排查指南","page":"故障排查","title":"错误信息排查指南","text":"PlantSimEngine 致力于为用户提供尽可能舒适和易用的体验，许多用户错误都会被捕获并给出相应的解释以帮助解决问题，但仍然存在一些盲点，以及语法错误，这些通常会生成 Julia 的错误（这类错误有时不易理解）而不是 PlantSimEngine 的专有错误。\n\n为帮助 Julia 新手排查问题，以下列出了一些在当前 API 下容易出现且不易解读的常见错误类型，并给出了修复建议。\n\n这些错误是按“错误性质”而不是错误提示信息分类的，因此你可能需要在本页面搜索才能找到具体的错误。\n\n如果你需要进一步帮助以解读 Julia 错误信息，可以访问 Julia 论坛 寻求帮助。 如果你需要 FSPM（功能-结构植物模型） 方面的建议，研究社区有专属的讨论论坛。\n\n如果你遇到 PlantSimEngine 相关的问题，或者有建模方面的疑问和建议，也可以在 Github 上提交 issue。\n\nPages = [\"plantsimengine_and_julia_troubleshooting.md\"]\nDepth = 3","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting.html#排查技巧与工作流","page":"故障排查","title":"排查技巧与工作流","text":"有些错误的原因非常明确，PlantSimEngine 的错误信息通常会直接指出是哪一个参数/变量/器官导致了错误，方便你定位问题。\n\n有些看似泛泛的错误消息，实际包含了有助于调试的重要线索。例如，由于参数或关键字参数存在问题导致 run! 调度失败时，错误提示往往会明确指出当前冲突的参数。在 VSCode 编辑器中，这些参数会被红色高亮显示（例如下面例子中第一个和最后一个参数）：\n\na = 1\nrun!(a, simple_mtg, mapping, meteo_day, a)\n\nERROR: MethodError: no method matching run!(::Int64, ::Node{NodeMTG, Dict{…}}, ::Dict{String, Tuple{…}}, ::DataFrame, ::Int64)\nThe function [`run!`](@ref) exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  run!(::ToyPlantLeafSurfaceModel, ::Any, ::Any, ::Any, ::Any, ::Any)\n   @ PlantSimEngine /PlantSimEngine/examples/ToyLeafSurfaceModel.jl:75\n   ...\n\n如果你想在本页快速定位某个错误，请复制错误描述中不特定于你脚本的部分，然后在此页面使用 Ctrl+F 搜索。例如上述例子中的泛用搜索词为：\n\nERROR: MethodError: no method matching","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting.html#常见的-Julia-错误","page":"故障排查","title":"常见的 Julia 错误","text":"","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting.html#单元素-NamedTuple-必须带逗号：","page":"故障排查","title":"单元素 NamedTuple 必须带逗号：","text":"这一点很容易被忽略。\n\n空的 NamedTuple 对象可以用 x = NamedTuple() 初始化。有多个变量时可以这样初始化：\n\na = (var1 = 0, var2 = 0)\n\n或者这样写也是可以的：\n\na = (var1 = 0, var2 = 0,)\n\n第二个逗号是可选的。\n\n然而，如果只有一个变量，则必须这样写：\n\na = (var1 = 0,)\n\n这个逗号是必须的。如果省略了逗号：\n\na = (var1 = 0)\n\n此时这行代码会被理解为将变量 a 赋值为 var1 的值（如上即赋为 0），所以 a 会变成 Int64 类型的 0，而不是 NamedTuple。\n\n这在编写自定义模型时很容易出错，因为某些函数需要 NamedTuple 类型的参数。例如：\n\nfunction PlantSimEngine.inputs_(::HardDepSameScaleAvalModel)\n    (e2 = -Inf,)\nend\n\n如果写错，通常会看到类似下面的 Julia 错误信息：\n\n[ERROR: MethodError: no method matching merge(::Float64, ::@NamedTuple{g::Float64})\n\n候选方法有：\nmerge(::NamedTuple{()}, ::NamedTuple)\n@ Base namedtuple.jl:337\nmerge(::NamedTuple{an}, ::NamedTuple{bn}) where {an, bn}\n@ Base namedtuple.jl:324\nmerge(::NamedTuple, ::NamedTuple, NamedTuple...)\n@ Base namedtuple.jl:343\n\nStacktrace:\n[1] variables_multiscale(node::PlantSimEngine.HardDependencyNode{…}, organ::String, vars_mapping::Dict{…}, st::@NamedTuple{})\n...\n\n有时 PlantSimEngine 能检测到并给出友好的提示（如传入 tracked_outputs 时），但在定义状态量等场合此类错误也可能出现。","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting.html#空-inputs/outputs-声明错误","page":"故障排查","title":"空 inputs/outputs 声明错误","text":"空 NamedTuple 的写法是 NamedTuple()。如果错误地写成 () 或 (,)，将分别触发 PlantSimEngine 或 Julia 返回的错误提示。","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting.html#PlantSimEngine-用户常见错误","page":"故障排查","title":"PlantSimEngine 用户常见错误","text":"以下大多数错误仅在多尺度模拟（multi-scale simulation）时出现，因为其 API 更为复杂。但也有一些是单尺度和多尺度模拟都可能遇到的。","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting.html#ModelList/Mapping：错误地提供了类型名而不是实例","page":"故障排查","title":"ModelList/Mapping：错误地提供了类型名而不是实例","text":"m = ModelList(day=MyToyModel, week=MyToyModel2)\n\n这行代码是错误的，会报如下错误：\n\nMethodError: no method matching inputs_(::Type{MyToyDayModel})\n\n正确的写法（假设相应的构造函数存在）是：\n\nm = ModelList(day=MyToyModel(), week=MyToyModel2())","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting.html#实现新模型时：忘记导入函数或加上模块前缀","page":"故障排查","title":"实现新模型时：忘记导入函数或加上模块前缀","text":"在实现新模型时，需要确保你的实现被正确识别为扩展了PlantSimEngine的方法和类型，而不是在当前作用域新建的独立函数。\n\n在下面这个可运行的玩具模型实例中，注意inputs_、outputs_和run!函数都以模块名作前缀。如果有硬依赖管理，dep函数同样需要加模块名前缀。\n\nusing PlantSimEngine\n@process \"toy\" verbose = false\n\nstruct ToyToyModel{T} <: AbstractToyModel \n    internal_constant::T\nend\n\nfunction PlantSimEngine.inputs_(::ToyToyModel)\n    (a = -Inf, b = -Inf, c = -Inf)\nend\n\nfunction PlantSimEngine.outputs_(::ToyToyModel)\n    (d = -Inf, e = -Inf)\nend\n\nfunction PlantSimEngine.run!(m::ToyToyModel, models, status, meteo, constants=nothing, extra_args=nothing)\n    status.d = m.internal_constant * status.a \n    status.e += m.internal_constant\nend\n\nmeteo = Weather([\n        Atmosphere(T=20.0, Wind=1.0, Rh=0.65, Ri_PAR_f=200.0),\n        Atmosphere(T=20.0, Wind=1.0, Rh=0.65, Ri_PAR_f=200.0),\n        Atmosphere(T=18.0, Wind=1.0, Rh=0.65, Ri_PAR_f=100.0),\n])\n\nmodel = ModelList(\n    ToyToyModel(1),\n    status = ( a = 1, b = 0, c = 0),\n)\nto_initialize(model) \nsim = PlantSimEngine.run!(model, meteo)\n\n如果在声明这些函数时没有先导入，或没有加上模块名前缀，它们会被认为是当前作用域下的新函数，而不是扩展PlantSimEngine的方法。这会导致PlantSimEngine无法正确调用这些功能，结果通常会报错或行为异常。\n\n比如忘记给run!函数加模块前缀，会收到如下错误：\n\nERROR: MethodError: no method matching run!(::ModelList{@NamedTuple{…}, Status{…}}, ::TimeStepTable{Atmosphere{…}})\n函数[`run!`](@ref)虽存在，但没有适用于这组参数类型的方法。\n\n最接近的方法候选有:\n  run!(::ToyToyModel, ::Any, ::Any, ::Any, ::Any, ::Any)\n   @ Main ~/path/to/file.jl:20\n\n如果inputs_或outputs_没有加前缀，有时未必立刻出错（取决于你在ModelList或mapping的Status下是否声明了对应变量）。\n\n某些情况下会报如下类错误：\n\nERROR: type NamedTuple has no field d\nStacktrace:\n [1] setproperty!(mnt::Status{(:a, :b, :c), Tuple{…}}, s::Symbol, x::Int64)\n   @ PlantSimEngine ~/path/to/package/PlantSimEngine/src/component_models/Status.jl:100\n [2] run!(m::ToyToyModel{…}, models::@NamedTuple{…}, status::Status{…}, meteo::PlantMeteo.TimeStepRow{…}, constants::Constants{…}, extra_args::Nothing)\n ...\n\nnote: Note\n未来我们或许会在库内部做更多改进以让错误更直接易懂，但目前最佳实践仍然是所有需要声明和调用的相关方法都加上PlantSimEngine.前缀，或明确导入你希望扩展的方法，例如：import PlantSimEngine: inputs_, outputs_。","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting.html#MultiScaleModel：声明时遗漏关键字参数","page":"故障排查","title":"MultiScaleModel：声明时遗漏关键字参数","text":"MultiScaleModel 需要两个关键字参数，分别为 model 和 mapped_variables：\n\nmodels = MultiScaleModel(\n        model=ToyLAIModel(),\n        mapped_variables=[:TT_cu => \"Scene\",],\n    )\n\n忘记写 model= 的情况：\n\nmodels = MultiScaleModel(\n        ToyLAIModel(),\n        mapped_variables=[:TT_cu => \"Scene\",],\n    )\nERROR: MethodError: no method matching MultiScaleModel(::ToyLAIModel; mapped_variables::Vector{Pair{Symbol, String}})\n虽然类型 `MultiScaleModel` 存在，但该参数组合未定义对应的构造方法。\n\n最接近的候选方法有：\n    MultiScaleModel(::T, ::Any) where T<:AbstractModel got unsupported keyword argument \"mapped_variables\"\n    @ PlantSimEngine PlantSimEngine/src/mtg/MultiScaleModel.jl:188\n    MultiScaleModel(; model, mapped_variables)\n    @ PlantSimEngine PlantSimEngine/src/mtg/MultiScaleModel.jl:191\n\n忘记写 mapped_variables= 的情况：\n\nmodels = MultiScaleModel(\n        model=ToyLAIModel(),\n        [:TT_cu => \"Scene\",],\n    )\n\nERROR: MethodError: no method matching MultiScaleModel(::Vector{Pair{Symbol, String}}; model::ToyLAIModel)\n虽然类型 `MultiScaleModel` 存在，但该参数组合未定义对应的构造方法。\n\n最接近的候选方法有：\n  MultiScaleModel(; model, mapping)\n   @ PlantSimEngine PlantSimEngine/src/mtg/MultiScaleModel.jl:191\n  MultiScaleModel(::T, ::Any) where T<:AbstractModel got unsupported keyword argument \"model\"\n\n信息'got unsupported keyword argument \"model\"'可能会产生误导，因为此处的错误并非关键字参数不被支持，而是关键字参数缺失。","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting.html#MultiScaleModel：在映射中未定义变量","page":"故障排查","title":"MultiScaleModel：在映射中未定义变量","text":"导致此类错误的一个常见原因是，在多尺度模型的映射中，使用了变量名而不是符号（Symbol）：\n\nmapping = Dict(\"Scale\" =>\nMultiScaleModel(\n    model = ToyModel(),\n    mapped_variables = [should_be_symbol => \"Other_Scale\"] # should_be_symbol 是变量名，很可能在当前模块中未定义\n),\n...\n),\n\n正确的做法是使用符号（Symbol），例如：\n\nmapping = Dict(\"Scale\" =>\nMultiScaleModel(\n    model = ToyModel(),\n    mapped_variables=[:should_be_symbol => \"Other_Scale\"] # should_be_symbol 现在是符号\n),\n...\n),","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting.html#调用-run!-时位置参数与关键字参数问题","page":"故障排查","title":"调用 run! 时位置参数与关键字参数问题","text":"不幸的是，给 run! 函数传递参数时有多种方式可能会混淆 Julia 的动态分派机制。其中一部分原因是 PlantSimEngine 本身类型声明还不够完善，未来可能会有所改进。\n\n下面举几个典型例子，说明在正常多尺度模型的 run! 调用中稍作修改就容易引发困惑：\n\n    meteo_day = CSV.read(joinpath(pkgdir(PlantSimEngine), \"examples/meteo_day.csv\"), DataFrame, header=18)\n    mtg = Node(MultiScaleTreeGraph.NodeMTG(\"/\", \"Plant\", 1, 1))\n    var1 = 15.0\n\n    mapping = Dict(\n        \"Leaf\" => (\n            Process1Model(1.0),\n            Process2Model(),\n            Process3Model(),\n            Status(var1=var1,)\n        )\n    )\n\n    outs = Dict(\n        \"Leaf\" => (:var1,), # :non_existing_variable 不是任何模型计算的变量\n    )\n\nrun!(mtg, mapping, meteo_day, PlantMeteo.Constants(), tracked_outputs=outs)\n\n该函数的完整签名如下： \n\nfunction run!(\n    object::MultiScaleTreeGraph.Node,\n    mapping::Dict{String,T} where {T},\n    meteo=nothing,\n    constants=PlantMeteo.Constants(),\n    extra=nothing;\n    nsteps=nothing,\n    tracked_outputs=nothing,\n    check=true,\n    executor=ThreadedEx()\n\n在 mtg 和 mapping 之后的参数都有默认值，因此都是可选的；在 ';' 分隔符之后的参数是关键字参数，必须显式命名。\n\n如果你忘记传入 mtg，由于 run! 的定义方式存在缺陷，会出现如下错误：\n\nrun!(mapping, meteo_day, PlantMeteo.Constants(), tracked_outputs=outs)\n\nERROR: MethodError: no method matching check_dimensions(::PlantSimEngine.TableAlike, ::Tuple{…}, ::DataFrame)\n虽然函数 `check_dimensions` 存在，但没有针对这些参数类型的实现。\n\n最接近的候选方法如下：\n  check_dimensions(::Any, ::Any)\n   @ PlantSimEngine PlantSimEngine/src/checks/dimensions.jl:43\n ...\n\n如果在函数调用时忘记添加必要的参数名 tracked_outputs=，outs 会被当作位置参数传递给 extra，而不是作为关键字参数。extra 参数一般默认为 nothing，并在多尺度模式下保留，因此会导致如下报错：\n\nrun!(mtg, mapping, meteo_day, PlantMeteo.Constants(), outs)\n\nERROR: Extra parameters are not allowed for the simulation of an MTG (already used for statuses).\nStacktrace:\n [1] error(s::String)\n   @ Base ./error.jl:35\n [2] run!(::PlantSimEngine.TreeAlike, object::PlantSimEngine.GraphSimulation{…}, meteo::DataFrames.DataFrameRows{…}, constants::Constants{…}, extra::Dict{…}; tracked_outputs::Nothing, check::Bool, executor::ThreadedEx{…})\n\n另外一种情况：如果错用了不存在的关键字参数，则 Julia 会抛出带有更多信息的通用调度错误，例如出现 got unsupported keyword argument \"constants\"\n\nrun!(mtg, mapping, meteo_day, constants=PlantMeteo.Constants(), tracked_outputs=outs)\n\nERROR: MethodError: no method matching run!(::Node{…}, ::Dict{…}, ::DataFrame, ::Dict{…}, ::Nothing; constants::Constants{…})\n这个错误是手动显式抛出的，因此函数本身可能存在，但被明确标记为未实现。\n\n最接近的候选方法如下：\n  run!(::Node, ::Dict{String}, ::Any, ::Any, ::Any; nsteps, tracked_outputs, check, executor) got unsupported keyword argument \"constants\"","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting.html#映射中缺少硬依赖过程的情况","page":"故障排查","title":"映射中缺少硬依赖过程的情况","text":"当前 PlantSimEngine 的错误检查机制存在一个不足：当你的 mapping 中包含模型 A，且 A 存在硬依赖模型 B（即 A 运行前必须有 B），但 mapping 里却没有添加 B，这时 Julia 会抛出一个比较隐晦的报错。\n\n例如，A 是 Process3Model，它声明自己硬依赖一个名为 process2 的模型 B（实现自 Process2Model）。在 Process3Model 的源码中声明如下：\n\nPlantSimEngine.dep(::Process3Model) = (process2=Process2Model,)\n\n但下方的示例 mapping 中，缺少了对应的 Process2Model：\n\nsimple_mtg = Node(MultiScaleTreeGraph.NodeMTG(\"/\", \"Plant\", 1, 1))    \nmapping = Dict(\n    \"Leaf\" => (\n        Process3Model(),\n        Status(var5=15.0,)\n    )\n)\nouts = Dict(\n    \"Leaf\" => (:var5,),\n)\nrun!(simple_mtg, mapping, meteo_day, tracked_outputs=outs)\n\nERROR: type NamedTuple has no field process2\nStacktrace:\n [1] getproperty(x::@NamedTuple{process3::Process3Model}, f::Symbol)\n   @ Base ./Base.jl:49\n [2] run!(::Process3Model, models::@NamedTuple{…}, status::Status{…}, meteo::DataFrameRow{…}, constants::Constants{…}, extra::PlantSimEngine.GraphSimulation{…})\n ...\n\n出现这种报错时，解决方法就是在 mapping 里补上 Process2Model()（或者其它实现该过程的模型）。","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting.html#Status-API-歧义问题","page":"故障排查","title":"Status API 歧义问题","text":"目前 PlantSimEngine 的 API 存在一个问题：在声明仿真的 Status 或 Statuses 时，单尺度与多尺度的写法不同。\n\n回到实现新模型时：忘记导入函数或加上模块前缀中的例子，ModelList 中 status 的声明如下：\n\nmodel = ModelList(\n    ToyToyModel(1),\n    status = ( a = 1, b = 0, c = 0),\n)\n\n如果你把 status = ... 替换为多尺度的写法 Status(...)，会遇到如下报错：\n\nERROR: MethodError: no method matching process(::Status{(:a, :b, :c), Tuple{Base.RefValue{Int64}, Base.RefValue{Int64}, Base.RefValue{Int64}}})\n虽然存在名为 `process` 的函数，但没有为这种参数组合定义该方法。\n\n最接近的方法是：\n  process(::Pair{Symbol, A}) where A<:AbstractModel\n   @ PlantSimEngine ~/path/to/pkg/PlantSimEngine/src/Abstract_model_structs.jl:16\n  process(::A) where A<:AbstractModel\n   @ PlantSimEngine ~/path/to/pkg/PlantSimEngine/src/Abstract_model_structs.jl:13\n\n堆栈跟踪:\n [1] (::PlantSimEngine.var\"#5#6\")(i::Status{(:a, :b, :c), Tuple{Base.RefValue{…}, Base.RefValue{…}, Base.RefValue{…}}})\n   @ PlantSimEngine ./none:0\n [2] iterate\n\n如果你在多尺度仿真中做了相反的事情——即将必需的 Status(...) 写法替换成 status = ...，你可能会遇到 ERROR: syntax: invalid named tuple element 这样的错误。下面是对 Toy Plant 教程的 mapping 做这种修改时出现的典型报错示例：\n\nERROR: syntax: invalid named tuple element \"MultiScaleModel(...)\" around /path/to/Pkg/PlantSimEngine/examples/ToyMultiScalePlantTutorial/ToyPlantSimulation3.jl:196\nStacktrace:\n [1] top-level scope\n   @ ~/path/to/pkg/PlantSimEngine/examples/ToyMultiScalePlantTutorial/ToyPlantSimulation3.jl:196\n\n或\n\nERROR: syntax: invalid named tuple element \"ToyRootGrowthModel(50, 10)\" around /path/to/Pkg/PlantSimEngine/examples/ToyMultiScalePlantTutorial/ToyPlantSimulation3.jl:196\nStacktrace:\n [1] top-level scope\n   @ ~/path/to/Pkg/PlantSimEngine/examples/ToyMultiScalePlantTutorial/ToyPlantSimulation3.jl:196","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting.html#在-mapping-中忘记声明某个尺度，但变量却指向了该尺度","page":"故障排查","title":"在 mapping 中忘记声明某个尺度，但变量却指向了该尺度","text":"如果需要在两个不同尺度上收集变量，但 mapping 里某个尺度完全没有声明模型，目前 Julia 端会报错如下：\n\n# mapping 里没有 E3 尺度的模型！\n\n\"E2\" => (\n        MultiScaleModel(\n        model = HardDepSameScaleEchelle2Model(),\n        mapped_variables=[:c => \"E1\" => :c, :e3 => \"E3\" => :e3, :f3 => \"E3\" => :f3,], \n        ),\n    ),\n\nException has occurred: KeyError\n*\nKeyError: key \"E3\" not found\nStacktrace:\n[1] hard_dependencies(mapping::Dict{String, Tuple{Any, Any}}; verbose::Bool)\n@ PlantSimEngine ......./src/dependencies/hard_dependencies.jl:175\n...","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting.html#mapping-声明时的括号位置问题","page":"故障排查","title":"mapping 声明时的括号位置问题","text":"在声明 mapping 时，曾遇到过一种让人迷惑的错误：\n\nERROR: ArgumentError: AbstractDict(kv): kv needs to be an iterator of 2-tuples or pairs\n\n这个错误经常发生在 mapping 声明中 => 后面应有括号却忘记加，并且与另一个括号写法错误叠加时。例如：\n\nmapping = Dict( \"Scale\" => (ToyAssimGrowthModel(0.0, 0.0, 0.0), ToyCAllocationModel(), Status( TT_cu=Vector(cumsum(meteo_day.TT))), ), )\n\n除此以外，还可能遇到如下错误：\n\nERROR: MethodError: no method matching Dict(::Pair{String, ToyAssimGrowthModel{Float64}}, ::ToyCAllocationModel, ::Status{(:TT_cu,), Tuple{Base.RefValue{…}}})\nThe type `Dict` exists, but no method is defined for this combination of argument types when trying to construct it.\n\nClosest candidates are:\n  Dict(::Pair{K, V}...) where {K, V}\n\n这通常暗示 mapping 声明的语法有误，请仔细检查括号和逗号的位置。","category":"section"},{"location":"troubleshooting_and_testing/plantsimengine_and_julia_troubleshooting.html#多尺度模拟中的空状态向量","page":"故障排查","title":"多尺度模拟中的空状态向量","text":"这种情况下不会直接报错。如果你在 MTG 中忘记在相应尺度上增加某个节点，并且没有为该节点生成器官，对应输出变量会返回空向量，容易让人疑惑。\n\n这里有一个例子，取自将单尺度模拟转换为多尺度模拟页面，并对伪 MTG 做了修改：把传入 run! 函数的 \"Plant\" 节点去掉了。没有 \"Plant\" 节点时，只能先运行 \"Scene\" 尺度的模型，由于没有新节点创建，\"Plant\" 尺度的模型永远不会被运行。\n\nPlantSimEngine.@process \"tt_cu\" verbose = false\n\nstruct ToyTt_CuModel <: AbstractTt_CuModel end\n\nfunction PlantSimEngine.run!(::ToyTt_CuModel, models, status, meteo, constants, extra=nothing)\n    status.TT_cu +=\n        meteo.TT\nend\n\nfunction PlantSimEngine.inputs_(::ToyTt_CuModel)\n    NamedTuple() # 没有输入变量\nend\n\nfunction PlantSimEngine.outputs_(::ToyTt_CuModel)\n    (TT_cu=-Inf,)\nend\n\nmapping_multiscale = Dict(\n    \"Scene\" => ToyTt_CuModel(),\n    \"Plant\" => (\n        MultiScaleModel(\n            model=ToyLAIModel(),\n            mapped_variables=[\n                :TT_cu => \"Scene\",\n            ],\n        ),\n        Beer(0.5),\n        ToyRUEGrowthModel(0.2),\n    ),\n)\n\nmtg_multiscale = MultiScaleTreeGraph.Node(MultiScaleTreeGraph.NodeMTG(\"/\", \"Plant\", 0, 0),)\n#plant = MultiScaleTreeGraph.Node(mtg_multiscale, MultiScaleTreeGraph.NodeMTG(\"+\", \"Plant\", 1, 1))\n\nout_multiscale = run!(mtg_multiscale, mapping_multiscale, meteo_day)\n\nout_multiscale[\"Plant\"][:LAI]\n\n在上述代码中，取消第二行的注释可以为 MTG 增加一个 \"Plant\" 节点，此时模拟的行为会符合我们直觉的预期。","category":"section"},{"location":"prerequisites/installing_plantsimengine.html#PlantSimEngine-的安装与运行","page":"PlantSimEngine 的安装与运行","title":"PlantSimEngine 的安装与运行","text":"Pages = [\"installing_plantsimengine.md\"]\nDepth = 3\n\n本页旨在帮助不太熟悉 Julia 的新手用户。如果你已经很了解 Julia，安装 PlantSimEngine 将会非常简单，你可以直接跳到下一节，或者阅读 PlantSimEngine 的关键概念。","category":"section"},{"location":"prerequisites/installing_plantsimengine.html#安装-Julia","page":"PlantSimEngine 的安装与运行","title":"安装 Julia","text":"Julia 的直接下载链接在这里，更多安装说明可参见官方手册。","category":"section"},{"location":"prerequisites/installing_plantsimengine.html#安装-VSCode","page":"PlantSimEngine 的安装与运行","title":"安装 VSCode","text":"你可以直接使用 REPL（命令行），但如果打算编写较为复杂的软件，推荐使用 IDE。PlantSimEngine 的开发推荐使用 VSCode，你可以按照本页面的指引安装 VSCode。关于在 VSCode 中使用 Julia 的说明可参见这里。","category":"section"},{"location":"prerequisites/installing_plantsimengine.html#安装-PlantSimEngine-及其依赖项","page":"PlantSimEngine 的安装与运行","title":"安装 PlantSimEngine 及其依赖项","text":"","category":"section"},{"location":"prerequisites/installing_plantsimengine.html#Julia-环境","page":"PlantSimEngine 的安装与运行","title":"Julia 环境","text":"Julia 的包管理依赖于 Pkg.jl。你可以在官方文档中详细了解其使用方法及 Julia 环境的管理。\n\n如果本页内容对你来说尚不够详细，本教程会更深入地介绍 Julia 环境的使用细节。","category":"section"},{"location":"prerequisites/installing_plantsimengine.html#运行-Julia-环境","page":"PlantSimEngine 的安装与运行","title":"运行 Julia 环境","text":"当你的环境设置完成后，可以打开命令行并输入 julia。这将启动 Julia，你将在命令行看到 julia> 的提示符。\n\n从这个提示符下，你可以输入 ? 进入帮助模式，然后输入你想了解的函数或语言特性名称来获取相关帮助信息。\n\n你也可以在 Julia 会话中通过输入 pwd() 查看你当前所在的目录。\n\n在 Julia 中，环境和依赖的管理由名为 Pkg 的包负责，它自带于 Julia 的基础安装。你可以像使用其他包一样调用 Pkg 的功能，或通过输入 ] 进入 Pkg 模式。此时，提示符会从 julia> 变为类似 (@v1.11) pkg>，表示你当前所处的环境（比如默认的 julia 环境，我们不建议将其过度膨胀）。\n\n在 Pkg 模式下，你可以通过输入 activate 路径/到/环境 来选择或创建一个环境。\n\n随后，可通过输入 add 包名 来添加已注册在 Julia 全局仓库中的包，输入 remove 包名 来删除包。输入 status 或 st 可以显示当前环境下已安装的包。需要更新某些包时（其名称旁会出现 ^ 符号），可以输入 update 或 up 进行更新。\n\n如果你在本地编辑/开发一个包，或者直接使用本地包，可以输入 develop 路径/到/包源码/ （或简写为 dev 路径/到/包/源码），这样环境将使用该本地版本，而不是注册表中的版本。\n\n输入 instantiate 会根据环境的 manifest 文件（如果有）自动下载所有声明的依赖包。\n\n举例来说，PlantSimEngine 在开发时有一个 test 文件夹用于测试。如果要运行测试，你需要依次输入 ] 进入 Pkg 模式，再输入 activate ../path/to/PlantSimEngine/test 激活测试环境，之后再输入 instantiate 来安装依赖包，这样就可以运行测试脚本了。\n\n因此，要使用 PlantSimEngine，可以进入 Pkg 模式（]），选择一个环境文件夹，并通过 activate ../path/to/your_environment 激活该环境，再用 add PlantSimEngine 添加 PlantSimEngine，最后用 instantiate 下载相关依赖。","category":"section"},{"location":"prerequisites/installing_plantsimengine.html#伴随包","page":"PlantSimEngine 的安装与运行","title":"伴随包","text":"在大部分示例中，你还需安装 PlantMeteo。对于部分多尺度模拟，还需安装 MultiScaleTreeGraph。\n\n一些气象数据的示例会用到 CSV 包，一些输出数据的处理则会用到 DataFrames 包。","category":"section"},{"location":"prerequisites/installing_plantsimengine.html#使用示例模型","page":"PlantSimEngine 的安装与运行","title":"使用示例模型","text":"示例模型被作为 PlantSimEngine 的一个子模块导出，不属于主 API。可以通过以下代码引用：\n\nusing PlantSimEngine.Examples","category":"section"},{"location":"prerequisites/installing_plantsimengine.html#运行测试仿真","page":"PlantSimEngine 的安装与运行","title":"运行测试仿真","text":"假设你已经配置好了环境，并正确地将 PlantMeteo 与 PlantSimEngine 添加进该环境，并通过 instantiate 下载好了全部依赖包。你就可以在 REPL 中逐行输入以下代码进行测试：\n\nusing PlantSimEngine, PlantMeteo\nusing PlantSimEngine.Examples\nmeteo = Atmosphere(T = 20.0, Wind = 1.0, Rh = 0.65, Ri_PAR_f = 500.0)\nleaf = ModelList(Beer(0.5), status = (LAI = 2.0,))\nout_sim = run!(leaf, meteo)","category":"section"},{"location":"prerequisites/installing_plantsimengine.html#在-VSCode-中使用环境","page":"PlantSimEngine 的安装与运行","title":"在 VSCode 中使用环境","text":"有详细文档介绍如何在 VSCode 中结合 Julia 的环境使用，其中包括了如何在 VSCode 管理环境的说明：https://www.julia-vscode.org/docs/stable/userguide/env/","category":"section"}]
}
